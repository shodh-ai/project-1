"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_src_utils_storageUtils_ts"],{

/***/ "(app-pages-browser)/./src/utils/storageUtils.ts":
/*!***********************************!*\
  !*** ./src/utils/storageUtils.ts ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   compressImageDataUrl: function() { return /* binding */ compressImageDataUrl; },\n/* harmony export */   estimateLocalStorageUsage: function() { return /* binding */ estimateLocalStorageUsage; },\n/* harmony export */   optimizeCanvasDataForStorage: function() { return /* binding */ optimizeCanvasDataForStorage; },\n/* harmony export */   safeLocalStorage: function() { return /* binding */ safeLocalStorage; }\n/* harmony export */ });\n/**\n * Utility functions to help with localStorage optimization and management\n */ /**\n * Compresses image data in a canvas state object to reduce localStorage usage.\n * This function will resize/compress any large image URLs in the canvas elements.\n */ function optimizeCanvasDataForStorage(canvasData) {\n    return canvasData.map((element)=>{\n        // Clone the element to avoid modifying the original\n        const optimizedElement = {\n            ...element\n        };\n        // If it's an image element with a data URL\n        if (element.type === \"image\" && typeof element.url === \"string\" && element.url.startsWith(\"data:image\")) {\n            // Replace with a compressed version\n            optimizedElement.url = compressImageDataUrl(element.url, 0.7, 800); // 70% quality, max 800px\n        }\n        // Also check metadata for image data\n        if (element.metadata) {\n            const newMetadata = {\n                ...element.metadata\n            };\n            // Check for originalImage in metadata (often holds a base64 image)\n            if (typeof newMetadata.originalImage === \"string\" && newMetadata.originalImage.startsWith(\"data:image\")) {\n                newMetadata.originalImage = compressImageDataUrl(newMetadata.originalImage, 0.6, 400); // More aggressive compression for metadata\n            }\n            optimizedElement.metadata = newMetadata;\n        }\n        return optimizedElement;\n    });\n}\n/**\n * Compresses a data URL image by resizing and reducing quality.\n * @param dataUrl The original data URL\n * @param quality Quality factor (0-1)\n * @param maxDimension Maximum width or height\n * @returns Compressed data URL\n */ function compressImageDataUrl(dataUrl) {\n    let quality = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0.8, maxDimension = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1024;\n    try {\n        // If the data URL is already small, don't process it\n        if (dataUrl.length < 10000) {\n            return dataUrl;\n        }\n        // Create temporary image and canvas in memory\n        const img = document.createElement(\"img\");\n        img.src = dataUrl;\n        // Create a canvas element to draw the resized image\n        const canvas = document.createElement(\"canvas\");\n        const ctx = canvas.getContext(\"2d\");\n        if (!ctx) {\n            console.warn(\"Unable to get canvas context for compression\");\n            return dataUrl;\n        }\n        // Calculate new dimensions while maintaining aspect ratio\n        let width = img.width;\n        let height = img.height;\n        if (width > height && width > maxDimension) {\n            height = Math.round(height * maxDimension / width);\n            width = maxDimension;\n        } else if (height > maxDimension) {\n            width = Math.round(width * maxDimension / height);\n            height = maxDimension;\n        }\n        // Set canvas size to the new dimensions\n        canvas.width = width;\n        canvas.height = height;\n        // Draw the resized image on the canvas\n        ctx.drawImage(img, 0, 0, width, height);\n        // Convert to compressed data URL\n        return canvas.toDataURL(\"image/jpeg\", quality);\n    } catch (error) {\n        console.error(\"Error compressing image:\", error);\n        // Return original if compression fails\n        return dataUrl;\n    }\n}\n/**\n * Safely stores data in localStorage with size checks\n * @param key localStorage key\n * @param data Data to store\n * @returns true if successful, false if failed\n */ function safeLocalStorage(key, data) {\n    try {\n        // Check data size\n        const sizeInMB = data.length * 2 / 1024 / 1024; // Rough estimation of string size in MB\n        if (sizeInMB > 4) {\n            console.warn(\"Data for \".concat(key, \" is very large (\").concat(sizeInMB.toFixed(2), \"MB), may exceed localStorage limits\"));\n        }\n        // Try to store it\n        localStorage.setItem(key, data);\n        return true;\n    } catch (error) {\n        console.error(\"Failed to save data to localStorage for key \".concat(key, \":\"), error);\n        return false;\n    }\n}\n/**\n * Estimate the current localStorage usage as a percentage of available space\n * This is approximate since browsers don't expose exact quota information\n */ function estimateLocalStorageUsage() {\n    try {\n        // Get all keys\n        const keys = Object.keys(localStorage);\n        let totalSize = 0;\n        // Calculate total size of all items\n        keys.forEach((key)=>{\n            const value = localStorage.getItem(key);\n            if (value) {\n                totalSize += key.length + value.length;\n            }\n        });\n        // Convert to MB (approximate)\n        const sizeInMB = totalSize * 2 / 1024 / 1024;\n        // Estimate quota (most browsers have 5-10MB)\n        const estimatedQuota = 5; // Conservative estimate in MB\n        // Return as percentage\n        return Math.min(100, sizeInMB / estimatedQuota * 100);\n    } catch (error) {\n        console.error(\"Error estimating localStorage usage:\", error);\n        return 0;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9zdG9yYWdlVXRpbHMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztDQUVDLEdBRUQ7OztDQUdDLEdBQ00sU0FBU0EsNkJBQTZCQyxVQUFpQjtJQUM1RCxPQUFPQSxXQUFXQyxHQUFHLENBQUNDLENBQUFBO1FBQ3BCLG9EQUFvRDtRQUNwRCxNQUFNQyxtQkFBbUI7WUFBRSxHQUFHRCxPQUFPO1FBQUM7UUFFdEMsMkNBQTJDO1FBQzNDLElBQUlBLFFBQVFFLElBQUksS0FBSyxXQUFXLE9BQU9GLFFBQVFHLEdBQUcsS0FBSyxZQUFZSCxRQUFRRyxHQUFHLENBQUNDLFVBQVUsQ0FBQyxlQUFlO1lBQ3ZHLG9DQUFvQztZQUNwQ0gsaUJBQWlCRSxHQUFHLEdBQUdFLHFCQUFxQkwsUUFBUUcsR0FBRyxFQUFFLEtBQUssTUFBTSx5QkFBeUI7UUFDL0Y7UUFFQSxxQ0FBcUM7UUFDckMsSUFBSUgsUUFBUU0sUUFBUSxFQUFFO1lBQ3BCLE1BQU1DLGNBQWM7Z0JBQUUsR0FBR1AsUUFBUU0sUUFBUTtZQUFDO1lBRTFDLG1FQUFtRTtZQUNuRSxJQUFJLE9BQU9DLFlBQVlDLGFBQWEsS0FBSyxZQUFZRCxZQUFZQyxhQUFhLENBQUNKLFVBQVUsQ0FBQyxlQUFlO2dCQUN2R0csWUFBWUMsYUFBYSxHQUFHSCxxQkFBcUJFLFlBQVlDLGFBQWEsRUFBRSxLQUFLLE1BQU0sMkNBQTJDO1lBQ3BJO1lBRUFQLGlCQUFpQkssUUFBUSxHQUFHQztRQUM5QjtRQUVBLE9BQU9OO0lBQ1Q7QUFDRjtBQUVBOzs7Ozs7Q0FNQyxHQUNNLFNBQVNJLHFCQUFxQkksT0FBZTtRQUFFQyxVQUFBQSxpRUFBVSxLQUFLQyxlQUFBQSxpRUFBZTtJQUNsRixJQUFJO1FBQ0YscURBQXFEO1FBQ3JELElBQUlGLFFBQVFHLE1BQU0sR0FBRyxPQUFPO1lBQzFCLE9BQU9IO1FBQ1Q7UUFFQSw4Q0FBOEM7UUFDOUMsTUFBTUksTUFBTUMsU0FBU0MsYUFBYSxDQUFDO1FBQ25DRixJQUFJRyxHQUFHLEdBQUdQO1FBRVYsb0RBQW9EO1FBQ3BELE1BQU1RLFNBQVNILFNBQVNDLGFBQWEsQ0FBQztRQUN0QyxNQUFNRyxNQUFNRCxPQUFPRSxVQUFVLENBQUM7UUFFOUIsSUFBSSxDQUFDRCxLQUFLO1lBQ1JFLFFBQVFDLElBQUksQ0FBQztZQUNiLE9BQU9aO1FBQ1Q7UUFFQSwwREFBMEQ7UUFDMUQsSUFBSWEsUUFBUVQsSUFBSVMsS0FBSztRQUNyQixJQUFJQyxTQUFTVixJQUFJVSxNQUFNO1FBRXZCLElBQUlELFFBQVFDLFVBQVVELFFBQVFYLGNBQWM7WUFDMUNZLFNBQVNDLEtBQUtDLEtBQUssQ0FBQ0YsU0FBU1osZUFBZVc7WUFDNUNBLFFBQVFYO1FBQ1YsT0FBTyxJQUFJWSxTQUFTWixjQUFjO1lBQ2hDVyxRQUFRRSxLQUFLQyxLQUFLLENBQUNILFFBQVFYLGVBQWVZO1lBQzFDQSxTQUFTWjtRQUNYO1FBRUEsd0NBQXdDO1FBQ3hDTSxPQUFPSyxLQUFLLEdBQUdBO1FBQ2ZMLE9BQU9NLE1BQU0sR0FBR0E7UUFFaEIsdUNBQXVDO1FBQ3ZDTCxJQUFJUSxTQUFTLENBQUNiLEtBQUssR0FBRyxHQUFHUyxPQUFPQztRQUVoQyxpQ0FBaUM7UUFDakMsT0FBT04sT0FBT1UsU0FBUyxDQUFDLGNBQWNqQjtJQUN4QyxFQUFFLE9BQU9rQixPQUFPO1FBQ2RSLFFBQVFRLEtBQUssQ0FBQyw0QkFBNEJBO1FBQzFDLHVDQUF1QztRQUN2QyxPQUFPbkI7SUFDVDtBQUNGO0FBRUE7Ozs7O0NBS0MsR0FDTSxTQUFTb0IsaUJBQWlCQyxHQUFXLEVBQUVDLElBQVk7SUFDeEQsSUFBSTtRQUNGLGtCQUFrQjtRQUNsQixNQUFNQyxXQUFXRCxLQUFLbkIsTUFBTSxHQUFHLElBQUksT0FBTyxNQUFNLHdDQUF3QztRQUV4RixJQUFJb0IsV0FBVyxHQUFHO1lBQ2hCWixRQUFRQyxJQUFJLENBQUMsWUFBa0NXLE9BQXRCRixLQUFJLG9CQUFzQyxPQUFwQkUsU0FBU0MsT0FBTyxDQUFDLElBQUc7UUFDckU7UUFFQSxrQkFBa0I7UUFDbEJDLGFBQWFDLE9BQU8sQ0FBQ0wsS0FBS0M7UUFDMUIsT0FBTztJQUNULEVBQUUsT0FBT0gsT0FBTztRQUNkUixRQUFRUSxLQUFLLENBQUMsK0NBQW1ELE9BQUpFLEtBQUksTUFBSUY7UUFDckUsT0FBTztJQUNUO0FBQ0Y7QUFFQTs7O0NBR0MsR0FDTSxTQUFTUTtJQUNkLElBQUk7UUFDRixlQUFlO1FBQ2YsTUFBTUMsT0FBT0MsT0FBT0QsSUFBSSxDQUFDSDtRQUN6QixJQUFJSyxZQUFZO1FBRWhCLG9DQUFvQztRQUNwQ0YsS0FBS0csT0FBTyxDQUFDVixDQUFBQTtZQUNYLE1BQU1XLFFBQVFQLGFBQWFRLE9BQU8sQ0FBQ1o7WUFDbkMsSUFBSVcsT0FBTztnQkFDVEYsYUFBYVQsSUFBSWxCLE1BQU0sR0FBRzZCLE1BQU03QixNQUFNO1lBQ3hDO1FBQ0Y7UUFFQSw4QkFBOEI7UUFDOUIsTUFBTW9CLFdBQVdPLFlBQVksSUFBSSxPQUFPO1FBRXhDLDZDQUE2QztRQUM3QyxNQUFNSSxpQkFBaUIsR0FBRyw4QkFBOEI7UUFFeEQsdUJBQXVCO1FBQ3ZCLE9BQU9uQixLQUFLb0IsR0FBRyxDQUFDLEtBQUssV0FBWUQsaUJBQWtCO0lBQ3JELEVBQUUsT0FBT2YsT0FBTztRQUNkUixRQUFRUSxLQUFLLENBQUMsd0NBQXdDQTtRQUN0RCxPQUFPO0lBQ1Q7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvdXRpbHMvc3RvcmFnZVV0aWxzLnRzPzliNjkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyB0byBoZWxwIHdpdGggbG9jYWxTdG9yYWdlIG9wdGltaXphdGlvbiBhbmQgbWFuYWdlbWVudFxuICovXG5cbi8qKlxuICogQ29tcHJlc3NlcyBpbWFnZSBkYXRhIGluIGEgY2FudmFzIHN0YXRlIG9iamVjdCB0byByZWR1Y2UgbG9jYWxTdG9yYWdlIHVzYWdlLlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIHJlc2l6ZS9jb21wcmVzcyBhbnkgbGFyZ2UgaW1hZ2UgVVJMcyBpbiB0aGUgY2FudmFzIGVsZW1lbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gb3B0aW1pemVDYW52YXNEYXRhRm9yU3RvcmFnZShjYW52YXNEYXRhOiBhbnlbXSk6IGFueVtdIHtcbiAgcmV0dXJuIGNhbnZhc0RhdGEubWFwKGVsZW1lbnQgPT4ge1xuICAgIC8vIENsb25lIHRoZSBlbGVtZW50IHRvIGF2b2lkIG1vZGlmeWluZyB0aGUgb3JpZ2luYWxcbiAgICBjb25zdCBvcHRpbWl6ZWRFbGVtZW50ID0geyAuLi5lbGVtZW50IH07XG4gICAgXG4gICAgLy8gSWYgaXQncyBhbiBpbWFnZSBlbGVtZW50IHdpdGggYSBkYXRhIFVSTFxuICAgIGlmIChlbGVtZW50LnR5cGUgPT09ICdpbWFnZScgJiYgdHlwZW9mIGVsZW1lbnQudXJsID09PSAnc3RyaW5nJyAmJiBlbGVtZW50LnVybC5zdGFydHNXaXRoKCdkYXRhOmltYWdlJykpIHtcbiAgICAgIC8vIFJlcGxhY2Ugd2l0aCBhIGNvbXByZXNzZWQgdmVyc2lvblxuICAgICAgb3B0aW1pemVkRWxlbWVudC51cmwgPSBjb21wcmVzc0ltYWdlRGF0YVVybChlbGVtZW50LnVybCwgMC43LCA4MDApOyAvLyA3MCUgcXVhbGl0eSwgbWF4IDgwMHB4XG4gICAgfVxuICAgIFxuICAgIC8vIEFsc28gY2hlY2sgbWV0YWRhdGEgZm9yIGltYWdlIGRhdGFcbiAgICBpZiAoZWxlbWVudC5tZXRhZGF0YSkge1xuICAgICAgY29uc3QgbmV3TWV0YWRhdGEgPSB7IC4uLmVsZW1lbnQubWV0YWRhdGEgfTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgZm9yIG9yaWdpbmFsSW1hZ2UgaW4gbWV0YWRhdGEgKG9mdGVuIGhvbGRzIGEgYmFzZTY0IGltYWdlKVxuICAgICAgaWYgKHR5cGVvZiBuZXdNZXRhZGF0YS5vcmlnaW5hbEltYWdlID09PSAnc3RyaW5nJyAmJiBuZXdNZXRhZGF0YS5vcmlnaW5hbEltYWdlLnN0YXJ0c1dpdGgoJ2RhdGE6aW1hZ2UnKSkge1xuICAgICAgICBuZXdNZXRhZGF0YS5vcmlnaW5hbEltYWdlID0gY29tcHJlc3NJbWFnZURhdGFVcmwobmV3TWV0YWRhdGEub3JpZ2luYWxJbWFnZSwgMC42LCA0MDApOyAvLyBNb3JlIGFnZ3Jlc3NpdmUgY29tcHJlc3Npb24gZm9yIG1ldGFkYXRhXG4gICAgICB9XG4gICAgICBcbiAgICAgIG9wdGltaXplZEVsZW1lbnQubWV0YWRhdGEgPSBuZXdNZXRhZGF0YTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG9wdGltaXplZEVsZW1lbnQ7XG4gIH0pO1xufVxuXG4vKipcbiAqIENvbXByZXNzZXMgYSBkYXRhIFVSTCBpbWFnZSBieSByZXNpemluZyBhbmQgcmVkdWNpbmcgcXVhbGl0eS5cbiAqIEBwYXJhbSBkYXRhVXJsIFRoZSBvcmlnaW5hbCBkYXRhIFVSTFxuICogQHBhcmFtIHF1YWxpdHkgUXVhbGl0eSBmYWN0b3IgKDAtMSlcbiAqIEBwYXJhbSBtYXhEaW1lbnNpb24gTWF4aW11bSB3aWR0aCBvciBoZWlnaHRcbiAqIEByZXR1cm5zIENvbXByZXNzZWQgZGF0YSBVUkxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXByZXNzSW1hZ2VEYXRhVXJsKGRhdGFVcmw6IHN0cmluZywgcXVhbGl0eSA9IDAuOCwgbWF4RGltZW5zaW9uID0gMTAyNCk6IHN0cmluZyB7XG4gIHRyeSB7XG4gICAgLy8gSWYgdGhlIGRhdGEgVVJMIGlzIGFscmVhZHkgc21hbGwsIGRvbid0IHByb2Nlc3MgaXRcbiAgICBpZiAoZGF0YVVybC5sZW5ndGggPCAxMDAwMCkge1xuICAgICAgcmV0dXJuIGRhdGFVcmw7XG4gICAgfVxuICAgIFxuICAgIC8vIENyZWF0ZSB0ZW1wb3JhcnkgaW1hZ2UgYW5kIGNhbnZhcyBpbiBtZW1vcnlcbiAgICBjb25zdCBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICBpbWcuc3JjID0gZGF0YVVybDtcbiAgICBcbiAgICAvLyBDcmVhdGUgYSBjYW52YXMgZWxlbWVudCB0byBkcmF3IHRoZSByZXNpemVkIGltYWdlXG4gICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgXG4gICAgaWYgKCFjdHgpIHtcbiAgICAgIGNvbnNvbGUud2FybignVW5hYmxlIHRvIGdldCBjYW52YXMgY29udGV4dCBmb3IgY29tcHJlc3Npb24nKTtcbiAgICAgIHJldHVybiBkYXRhVXJsO1xuICAgIH1cbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgbmV3IGRpbWVuc2lvbnMgd2hpbGUgbWFpbnRhaW5pbmcgYXNwZWN0IHJhdGlvXG4gICAgbGV0IHdpZHRoID0gaW1nLndpZHRoO1xuICAgIGxldCBoZWlnaHQgPSBpbWcuaGVpZ2h0O1xuICAgIFxuICAgIGlmICh3aWR0aCA+IGhlaWdodCAmJiB3aWR0aCA+IG1heERpbWVuc2lvbikge1xuICAgICAgaGVpZ2h0ID0gTWF0aC5yb3VuZChoZWlnaHQgKiBtYXhEaW1lbnNpb24gLyB3aWR0aCk7XG4gICAgICB3aWR0aCA9IG1heERpbWVuc2lvbjtcbiAgICB9IGVsc2UgaWYgKGhlaWdodCA+IG1heERpbWVuc2lvbikge1xuICAgICAgd2lkdGggPSBNYXRoLnJvdW5kKHdpZHRoICogbWF4RGltZW5zaW9uIC8gaGVpZ2h0KTtcbiAgICAgIGhlaWdodCA9IG1heERpbWVuc2lvbjtcbiAgICB9XG4gICAgXG4gICAgLy8gU2V0IGNhbnZhcyBzaXplIHRvIHRoZSBuZXcgZGltZW5zaW9uc1xuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgXG4gICAgLy8gRHJhdyB0aGUgcmVzaXplZCBpbWFnZSBvbiB0aGUgY2FudmFzXG4gICAgY3R4LmRyYXdJbWFnZShpbWcsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIFxuICAgIC8vIENvbnZlcnQgdG8gY29tcHJlc3NlZCBkYXRhIFVSTFxuICAgIHJldHVybiBjYW52YXMudG9EYXRhVVJMKCdpbWFnZS9qcGVnJywgcXVhbGl0eSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgY29tcHJlc3NpbmcgaW1hZ2U6JywgZXJyb3IpO1xuICAgIC8vIFJldHVybiBvcmlnaW5hbCBpZiBjb21wcmVzc2lvbiBmYWlsc1xuICAgIHJldHVybiBkYXRhVXJsO1xuICB9XG59XG5cbi8qKlxuICogU2FmZWx5IHN0b3JlcyBkYXRhIGluIGxvY2FsU3RvcmFnZSB3aXRoIHNpemUgY2hlY2tzXG4gKiBAcGFyYW0ga2V5IGxvY2FsU3RvcmFnZSBrZXlcbiAqIEBwYXJhbSBkYXRhIERhdGEgdG8gc3RvcmVcbiAqIEByZXR1cm5zIHRydWUgaWYgc3VjY2Vzc2Z1bCwgZmFsc2UgaWYgZmFpbGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYWZlTG9jYWxTdG9yYWdlKGtleTogc3RyaW5nLCBkYXRhOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgdHJ5IHtcbiAgICAvLyBDaGVjayBkYXRhIHNpemVcbiAgICBjb25zdCBzaXplSW5NQiA9IGRhdGEubGVuZ3RoICogMiAvIDEwMjQgLyAxMDI0OyAvLyBSb3VnaCBlc3RpbWF0aW9uIG9mIHN0cmluZyBzaXplIGluIE1CXG4gICAgXG4gICAgaWYgKHNpemVJbk1CID4gNCkge1xuICAgICAgY29uc29sZS53YXJuKGBEYXRhIGZvciAke2tleX0gaXMgdmVyeSBsYXJnZSAoJHtzaXplSW5NQi50b0ZpeGVkKDIpfU1CKSwgbWF5IGV4Y2VlZCBsb2NhbFN0b3JhZ2UgbGltaXRzYCk7XG4gICAgfVxuICAgIFxuICAgIC8vIFRyeSB0byBzdG9yZSBpdFxuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgZGF0YSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIHNhdmUgZGF0YSB0byBsb2NhbFN0b3JhZ2UgZm9yIGtleSAke2tleX06YCwgZXJyb3IpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEVzdGltYXRlIHRoZSBjdXJyZW50IGxvY2FsU3RvcmFnZSB1c2FnZSBhcyBhIHBlcmNlbnRhZ2Ugb2YgYXZhaWxhYmxlIHNwYWNlXG4gKiBUaGlzIGlzIGFwcHJveGltYXRlIHNpbmNlIGJyb3dzZXJzIGRvbid0IGV4cG9zZSBleGFjdCBxdW90YSBpbmZvcm1hdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gZXN0aW1hdGVMb2NhbFN0b3JhZ2VVc2FnZSgpOiBudW1iZXIge1xuICB0cnkge1xuICAgIC8vIEdldCBhbGwga2V5c1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhsb2NhbFN0b3JhZ2UpO1xuICAgIGxldCB0b3RhbFNpemUgPSAwO1xuICAgIFxuICAgIC8vIENhbGN1bGF0ZSB0b3RhbCBzaXplIG9mIGFsbCBpdGVtc1xuICAgIGtleXMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRvdGFsU2l6ZSArPSBrZXkubGVuZ3RoICsgdmFsdWUubGVuZ3RoO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIC8vIENvbnZlcnQgdG8gTUIgKGFwcHJveGltYXRlKVxuICAgIGNvbnN0IHNpemVJbk1CID0gdG90YWxTaXplICogMiAvIDEwMjQgLyAxMDI0O1xuICAgIFxuICAgIC8vIEVzdGltYXRlIHF1b3RhIChtb3N0IGJyb3dzZXJzIGhhdmUgNS0xME1CKVxuICAgIGNvbnN0IGVzdGltYXRlZFF1b3RhID0gNTsgLy8gQ29uc2VydmF0aXZlIGVzdGltYXRlIGluIE1CXG4gICAgXG4gICAgLy8gUmV0dXJuIGFzIHBlcmNlbnRhZ2VcbiAgICByZXR1cm4gTWF0aC5taW4oMTAwLCAoc2l6ZUluTUIgLyBlc3RpbWF0ZWRRdW90YSkgKiAxMDApO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGVzdGltYXRpbmcgbG9jYWxTdG9yYWdlIHVzYWdlOicsIGVycm9yKTtcbiAgICByZXR1cm4gMDtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIm9wdGltaXplQ2FudmFzRGF0YUZvclN0b3JhZ2UiLCJjYW52YXNEYXRhIiwibWFwIiwiZWxlbWVudCIsIm9wdGltaXplZEVsZW1lbnQiLCJ0eXBlIiwidXJsIiwic3RhcnRzV2l0aCIsImNvbXByZXNzSW1hZ2VEYXRhVXJsIiwibWV0YWRhdGEiLCJuZXdNZXRhZGF0YSIsIm9yaWdpbmFsSW1hZ2UiLCJkYXRhVXJsIiwicXVhbGl0eSIsIm1heERpbWVuc2lvbiIsImxlbmd0aCIsImltZyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInNyYyIsImNhbnZhcyIsImN0eCIsImdldENvbnRleHQiLCJjb25zb2xlIiwid2FybiIsIndpZHRoIiwiaGVpZ2h0IiwiTWF0aCIsInJvdW5kIiwiZHJhd0ltYWdlIiwidG9EYXRhVVJMIiwiZXJyb3IiLCJzYWZlTG9jYWxTdG9yYWdlIiwia2V5IiwiZGF0YSIsInNpemVJbk1CIiwidG9GaXhlZCIsImxvY2FsU3RvcmFnZSIsInNldEl0ZW0iLCJlc3RpbWF0ZUxvY2FsU3RvcmFnZVVzYWdlIiwia2V5cyIsIk9iamVjdCIsInRvdGFsU2l6ZSIsImZvckVhY2giLCJ2YWx1ZSIsImdldEl0ZW0iLCJlc3RpbWF0ZWRRdW90YSIsIm1pbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/storageUtils.ts\n"));

/***/ })

}]);