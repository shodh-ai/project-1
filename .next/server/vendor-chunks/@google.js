"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@google";
exports.ids = ["vendor-chunks/@google"];
exports.modules = {

/***/ "(ssr)/./node_modules/@google/genai/dist/node/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@google/genai/dist/node/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar googleAuthLibrary = __webpack_require__(/*! google-auth-library */ \"(ssr)/./node_modules/google-auth-library/build/src/index.js\");\nvar NodeWs = __webpack_require__(/*! ws */ \"(ssr)/./node_modules/ws/index.js\");\nvar fs = __webpack_require__(/*! fs/promises */ \"fs/promises\");\nfunction _interopNamespaceDefault(e) {\n    var n = Object.create(null);\n    if (e) {\n        Object.keys(e).forEach(function(k) {\n            if (k !== \"default\") {\n                var d = Object.getOwnPropertyDescriptor(e, k);\n                Object.defineProperty(n, k, d.get ? d : {\n                    enumerable: true,\n                    get: function() {\n                        return e[k];\n                    }\n                });\n            }\n        });\n    }\n    n.default = e;\n    return Object.freeze(n);\n}\nvar NodeWs__namespace = /*#__PURE__*/ _interopNamespaceDefault(NodeWs);\nvar fs__namespace = /*#__PURE__*/ _interopNamespaceDefault(fs);\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ let _defaultBaseGeminiUrl = undefined;\nlet _defaultBaseVertexUrl = undefined;\n/**\n * Overrides the base URLs for the Gemini API and Vertex AI API.\n *\n * @remarks This function should be called before initializing the SDK. If the\n * base URLs are set after initializing the SDK, the base URLs will not be\n * updated. Base URLs provided in the HttpOptions will also take precedence over\n * URLs set here.\n *\n * @example\n * ```ts\n * import {GoogleGenAI, setDefaultBaseUrls} from '@google/genai';\n * // Override the base URL for the Gemini API.\n * setDefaultBaseUrls({geminiUrl:'https://gemini.google.com'});\n *\n * // Override the base URL for the Vertex AI API.\n * setDefaultBaseUrls({vertexUrl: 'https://vertexai.googleapis.com'});\n *\n * const ai = new GoogleGenAI({apiKey: 'GEMINI_API_KEY'});\n * ```\n */ function setDefaultBaseUrls(baseUrlParams) {\n    _defaultBaseGeminiUrl = baseUrlParams.geminiUrl;\n    _defaultBaseVertexUrl = baseUrlParams.vertexUrl;\n}\n/**\n * Returns the default base URLs for the Gemini API and Vertex AI API.\n */ function getDefaultBaseUrls() {\n    return {\n        geminiUrl: _defaultBaseGeminiUrl,\n        vertexUrl: _defaultBaseVertexUrl\n    };\n}\n/**\n * Returns the default base URL based on the following priority:\n *   1. Base URLs set via HttpOptions.\n *   2. Base URLs set via the latest call to setDefaultBaseUrls.\n *   3. Base URLs set via environment variables.\n */ function getBaseUrl(options, vertexBaseUrlFromEnv, geminiBaseUrlFromEnv) {\n    var _a, _b, _c;\n    if (!((_a = options.httpOptions) === null || _a === void 0 ? void 0 : _a.baseUrl)) {\n        const defaultBaseUrls = getDefaultBaseUrls();\n        if (options.vertexai) {\n            return (_b = defaultBaseUrls.vertexUrl) !== null && _b !== void 0 ? _b : vertexBaseUrlFromEnv;\n        } else {\n            return (_c = defaultBaseUrls.geminiUrl) !== null && _c !== void 0 ? _c : geminiBaseUrlFromEnv;\n        }\n    }\n    return options.httpOptions.baseUrl;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class BaseModule {\n}\nfunction formatMap(templateString, valueMap) {\n    // Use a regular expression to find all placeholders in the template string\n    const regex = /\\{([^}]+)\\}/g;\n    // Replace each placeholder with its corresponding value from the valueMap\n    return templateString.replace(regex, (match, key)=>{\n        if (Object.prototype.hasOwnProperty.call(valueMap, key)) {\n            const value = valueMap[key];\n            // Convert the value to a string if it's not a string already\n            return value !== undefined && value !== null ? String(value) : \"\";\n        } else {\n            // Handle missing keys\n            throw new Error(`Key '${key}' not found in valueMap.`);\n        }\n    });\n}\nfunction setValueByPath(data, keys, value) {\n    for(let i = 0; i < keys.length - 1; i++){\n        const key = keys[i];\n        if (key.endsWith(\"[]\")) {\n            const keyName = key.slice(0, -2);\n            if (!(keyName in data)) {\n                if (Array.isArray(value)) {\n                    data[keyName] = Array.from({\n                        length: value.length\n                    }, ()=>({}));\n                } else {\n                    throw new Error(`Value must be a list given an array path ${key}`);\n                }\n            }\n            if (Array.isArray(data[keyName])) {\n                const arrayData = data[keyName];\n                if (Array.isArray(value)) {\n                    for(let j = 0; j < arrayData.length; j++){\n                        const entry = arrayData[j];\n                        setValueByPath(entry, keys.slice(i + 1), value[j]);\n                    }\n                } else {\n                    for (const d of arrayData){\n                        setValueByPath(d, keys.slice(i + 1), value);\n                    }\n                }\n            }\n            return;\n        } else if (key.endsWith(\"[0]\")) {\n            const keyName = key.slice(0, -3);\n            if (!(keyName in data)) {\n                data[keyName] = [\n                    {}\n                ];\n            }\n            const arrayData = data[keyName];\n            setValueByPath(arrayData[0], keys.slice(i + 1), value);\n            return;\n        }\n        if (!data[key] || typeof data[key] !== \"object\") {\n            data[key] = {};\n        }\n        data = data[key];\n    }\n    const keyToSet = keys[keys.length - 1];\n    const existingData = data[keyToSet];\n    if (existingData !== undefined) {\n        if (!value || typeof value === \"object\" && Object.keys(value).length === 0) {\n            return;\n        }\n        if (value === existingData) {\n            return;\n        }\n        if (typeof existingData === \"object\" && typeof value === \"object\" && existingData !== null && value !== null) {\n            Object.assign(existingData, value);\n        } else {\n            throw new Error(`Cannot set value for an existing key. Key: ${keyToSet}`);\n        }\n    } else {\n        data[keyToSet] = value;\n    }\n}\nfunction getValueByPath(data, keys) {\n    try {\n        if (keys.length === 1 && keys[0] === \"_self\") {\n            return data;\n        }\n        for(let i = 0; i < keys.length; i++){\n            if (typeof data !== \"object\" || data === null) {\n                return undefined;\n            }\n            const key = keys[i];\n            if (key.endsWith(\"[]\")) {\n                const keyName = key.slice(0, -2);\n                if (keyName in data) {\n                    const arrayData = data[keyName];\n                    if (!Array.isArray(arrayData)) {\n                        return undefined;\n                    }\n                    return arrayData.map((d)=>getValueByPath(d, keys.slice(i + 1)));\n                } else {\n                    return undefined;\n                }\n            } else {\n                data = data[key];\n            }\n        }\n        return data;\n    } catch (error) {\n        if (error instanceof TypeError) {\n            return undefined;\n        }\n        throw error;\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ function tModel(apiClient, model) {\n    if (!model || typeof model !== \"string\") {\n        throw new Error(\"model is required and must be a string\");\n    }\n    if (apiClient.isVertexAI()) {\n        if (model.startsWith(\"publishers/\") || model.startsWith(\"projects/\") || model.startsWith(\"models/\")) {\n            return model;\n        } else if (model.indexOf(\"/\") >= 0) {\n            const parts = model.split(\"/\", 2);\n            return `publishers/${parts[0]}/models/${parts[1]}`;\n        } else {\n            return `publishers/google/models/${model}`;\n        }\n    } else {\n        if (model.startsWith(\"models/\") || model.startsWith(\"tunedModels/\")) {\n            return model;\n        } else {\n            return `models/${model}`;\n        }\n    }\n}\nfunction tCachesModel(apiClient, model) {\n    const transformedModel = tModel(apiClient, model);\n    if (!transformedModel) {\n        return \"\";\n    }\n    if (transformedModel.startsWith(\"publishers/\") && apiClient.isVertexAI()) {\n        // vertex caches only support model name start with projects.\n        return `projects/${apiClient.getProject()}/locations/${apiClient.getLocation()}/${transformedModel}`;\n    } else if (transformedModel.startsWith(\"models/\") && apiClient.isVertexAI()) {\n        return `projects/${apiClient.getProject()}/locations/${apiClient.getLocation()}/publishers/google/${transformedModel}`;\n    } else {\n        return transformedModel;\n    }\n}\nfunction tBlobs(apiClient, blobs) {\n    if (Array.isArray(blobs)) {\n        return blobs.map((blob)=>tBlob(apiClient, blob));\n    } else {\n        return [\n            tBlob(apiClient, blobs)\n        ];\n    }\n}\nfunction tBlob(apiClient, blob) {\n    if (typeof blob === \"object\" && blob !== null) {\n        return blob;\n    }\n    throw new Error(`Could not parse input as Blob. Unsupported blob type: ${typeof blob}`);\n}\nfunction tImageBlob(apiClient, blob) {\n    const transformedBlob = tBlob(apiClient, blob);\n    if (transformedBlob.mimeType && transformedBlob.mimeType.startsWith(\"image/\")) {\n        return transformedBlob;\n    }\n    throw new Error(`Unsupported mime type: ${transformedBlob.mimeType}`);\n}\nfunction tAudioBlob(apiClient, blob) {\n    const transformedBlob = tBlob(apiClient, blob);\n    if (transformedBlob.mimeType && transformedBlob.mimeType.startsWith(\"audio/\")) {\n        return transformedBlob;\n    }\n    throw new Error(`Unsupported mime type: ${transformedBlob.mimeType}`);\n}\nfunction tPart(apiClient, origin) {\n    if (origin === null || origin === undefined) {\n        throw new Error(\"PartUnion is required\");\n    }\n    if (typeof origin === \"object\") {\n        return origin;\n    }\n    if (typeof origin === \"string\") {\n        return {\n            text: origin\n        };\n    }\n    throw new Error(`Unsupported part type: ${typeof origin}`);\n}\nfunction tParts(apiClient, origin) {\n    if (origin === null || origin === undefined || Array.isArray(origin) && origin.length === 0) {\n        throw new Error(\"PartListUnion is required\");\n    }\n    if (Array.isArray(origin)) {\n        return origin.map((item)=>tPart(apiClient, item));\n    }\n    return [\n        tPart(apiClient, origin)\n    ];\n}\nfunction _isContent(origin) {\n    return origin !== null && origin !== undefined && typeof origin === \"object\" && \"parts\" in origin && Array.isArray(origin.parts);\n}\nfunction _isFunctionCallPart(origin) {\n    return origin !== null && origin !== undefined && typeof origin === \"object\" && \"functionCall\" in origin;\n}\nfunction _isFunctionResponsePart(origin) {\n    return origin !== null && origin !== undefined && typeof origin === \"object\" && \"functionResponse\" in origin;\n}\nfunction tContent(apiClient, origin) {\n    if (origin === null || origin === undefined) {\n        throw new Error(\"ContentUnion is required\");\n    }\n    if (_isContent(origin)) {\n        // _isContent is a utility function that checks if the\n        // origin is a Content.\n        return origin;\n    }\n    return {\n        role: \"user\",\n        parts: tParts(apiClient, origin)\n    };\n}\nfunction tContentsForEmbed(apiClient, origin) {\n    if (!origin) {\n        return [];\n    }\n    if (apiClient.isVertexAI() && Array.isArray(origin)) {\n        return origin.flatMap((item)=>{\n            const content = tContent(apiClient, item);\n            if (content.parts && content.parts.length > 0 && content.parts[0].text !== undefined) {\n                return [\n                    content.parts[0].text\n                ];\n            }\n            return [];\n        });\n    } else if (apiClient.isVertexAI()) {\n        const content = tContent(apiClient, origin);\n        if (content.parts && content.parts.length > 0 && content.parts[0].text !== undefined) {\n            return [\n                content.parts[0].text\n            ];\n        }\n        return [];\n    }\n    if (Array.isArray(origin)) {\n        return origin.map((item)=>tContent(apiClient, item));\n    }\n    return [\n        tContent(apiClient, origin)\n    ];\n}\nfunction tContents(apiClient, origin) {\n    if (origin === null || origin === undefined || Array.isArray(origin) && origin.length === 0) {\n        throw new Error(\"contents are required\");\n    }\n    if (!Array.isArray(origin)) {\n        // If it's not an array, it's a single content or a single PartUnion.\n        if (_isFunctionCallPart(origin) || _isFunctionResponsePart(origin)) {\n            throw new Error(\"To specify functionCall or functionResponse parts, please wrap them in a Content object, specifying the role for them\");\n        }\n        return [\n            tContent(apiClient, origin)\n        ];\n    }\n    const result = [];\n    const accumulatedParts = [];\n    const isContentArray = _isContent(origin[0]);\n    for (const item of origin){\n        const isContent = _isContent(item);\n        if (isContent != isContentArray) {\n            throw new Error(\"Mixing Content and Parts is not supported, please group the parts into a the appropriate Content objects and specify the roles for them\");\n        }\n        if (isContent) {\n            // `isContent` contains the result of _isContent, which is a utility\n            // function that checks if the item is a Content.\n            result.push(item);\n        } else if (_isFunctionCallPart(item) || _isFunctionResponsePart(item)) {\n            throw new Error(\"To specify functionCall or functionResponse parts, please wrap them, and any other parts, in Content objects as appropriate, specifying the role for them\");\n        } else {\n            accumulatedParts.push(item);\n        }\n    }\n    if (!isContentArray) {\n        result.push({\n            role: \"user\",\n            parts: tParts(apiClient, accumulatedParts)\n        });\n    }\n    return result;\n}\nfunction tSchema(apiClient, schema) {\n    return schema;\n}\nfunction tSpeechConfig(apiClient, speechConfig) {\n    if (typeof speechConfig === \"object\") {\n        return speechConfig;\n    } else if (typeof speechConfig === \"string\") {\n        return {\n            voiceConfig: {\n                prebuiltVoiceConfig: {\n                    voiceName: speechConfig\n                }\n            }\n        };\n    } else {\n        throw new Error(`Unsupported speechConfig type: ${typeof speechConfig}`);\n    }\n}\nfunction tTool(apiClient, tool) {\n    return tool;\n}\nfunction tTools(apiClient, tool) {\n    if (!Array.isArray(tool)) {\n        throw new Error(\"tool is required and must be an array of Tools\");\n    }\n    return tool;\n}\n/**\n * Prepends resource name with project, location, resource_prefix if needed.\n *\n * @param client The API client.\n * @param resourceName The resource name.\n * @param resourcePrefix The resource prefix.\n * @param splitsAfterPrefix The number of splits after the prefix.\n * @returns The completed resource name.\n *\n * Examples:\n *\n * ```\n * resource_name = '123'\n * resource_prefix = 'cachedContents'\n * splits_after_prefix = 1\n * client.vertexai = True\n * client.project = 'bar'\n * client.location = 'us-west1'\n * _resource_name(client, resource_name, resource_prefix, splits_after_prefix)\n * returns: 'projects/bar/locations/us-west1/cachedContents/123'\n * ```\n *\n * ```\n * resource_name = 'projects/foo/locations/us-central1/cachedContents/123'\n * resource_prefix = 'cachedContents'\n * splits_after_prefix = 1\n * client.vertexai = True\n * client.project = 'bar'\n * client.location = 'us-west1'\n * _resource_name(client, resource_name, resource_prefix, splits_after_prefix)\n * returns: 'projects/foo/locations/us-central1/cachedContents/123'\n * ```\n *\n * ```\n * resource_name = '123'\n * resource_prefix = 'cachedContents'\n * splits_after_prefix = 1\n * client.vertexai = False\n * _resource_name(client, resource_name, resource_prefix, splits_after_prefix)\n * returns 'cachedContents/123'\n * ```\n *\n * ```\n * resource_name = 'some/wrong/cachedContents/resource/name/123'\n * resource_prefix = 'cachedContents'\n * splits_after_prefix = 1\n * client.vertexai = False\n * # client.vertexai = True\n * _resource_name(client, resource_name, resource_prefix, splits_after_prefix)\n * -> 'some/wrong/resource/name/123'\n * ```\n */ function resourceName(client, resourceName, resourcePrefix, splitsAfterPrefix = 1) {\n    const shouldAppendPrefix = !resourceName.startsWith(`${resourcePrefix}/`) && resourceName.split(\"/\").length === splitsAfterPrefix;\n    if (client.isVertexAI()) {\n        if (resourceName.startsWith(\"projects/\")) {\n            return resourceName;\n        } else if (resourceName.startsWith(\"locations/\")) {\n            return `projects/${client.getProject()}/${resourceName}`;\n        } else if (resourceName.startsWith(`${resourcePrefix}/`)) {\n            return `projects/${client.getProject()}/locations/${client.getLocation()}/${resourceName}`;\n        } else if (shouldAppendPrefix) {\n            return `projects/${client.getProject()}/locations/${client.getLocation()}/${resourcePrefix}/${resourceName}`;\n        } else {\n            return resourceName;\n        }\n    }\n    if (shouldAppendPrefix) {\n        return `${resourcePrefix}/${resourceName}`;\n    }\n    return resourceName;\n}\nfunction tCachedContentName(apiClient, name) {\n    if (typeof name !== \"string\") {\n        throw new Error(\"name must be a string\");\n    }\n    return resourceName(apiClient, name, \"cachedContents\");\n}\nfunction tBytes(apiClient, fromImageBytes) {\n    if (typeof fromImageBytes !== \"string\") {\n        throw new Error(\"fromImageBytes must be a string\");\n    }\n    // TODO(b/389133914): Remove dummy bytes converter.\n    return fromImageBytes;\n}\nfunction tFileName(apiClient, fromName) {\n    if (typeof fromName !== \"string\") {\n        throw new Error(\"fromName must be a string\");\n    }\n    // Remove the files/ prefx for MLdev urls to get the actual name of the file.\n    if (fromName.startsWith(\"files/\")) {\n        return fromName.split(\"files/\")[1];\n    }\n    return fromName;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ function partToMldev$2(apiClient, fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]) !== undefined) {\n        throw new Error(\"videoMetadata parameter is not supported in Gemini API.\");\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fromFileData);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], fromFunctionCall);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], fromInlineData);\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    return toObject;\n}\nfunction contentToMldev$2(apiClient, fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        if (Array.isArray(fromParts)) {\n            setValueByPath(toObject, [\n                \"parts\"\n            ], fromParts.map((item)=>{\n                return partToMldev$2(apiClient, item);\n            }));\n        } else {\n            setValueByPath(toObject, [\n                \"parts\"\n            ], fromParts);\n        }\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction functionDeclarationToMldev$2(apiClient, fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"response\"\n    ]) !== undefined) {\n        throw new Error(\"response parameter is not supported in Gemini API.\");\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, [\n        \"parameters\"\n    ]);\n    if (fromParameters != null) {\n        setValueByPath(toObject, [\n            \"parameters\"\n        ], fromParameters);\n    }\n    return toObject;\n}\nfunction googleSearchToMldev$2() {\n    const toObject = {};\n    return toObject;\n}\nfunction dynamicRetrievalConfigToMldev$2(apiClient, fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromDynamicThreshold = getValueByPath(fromObject, [\n        \"dynamicThreshold\"\n    ]);\n    if (fromDynamicThreshold != null) {\n        setValueByPath(toObject, [\n            \"dynamicThreshold\"\n        ], fromDynamicThreshold);\n    }\n    return toObject;\n}\nfunction googleSearchRetrievalToMldev$2(apiClient, fromObject) {\n    const toObject = {};\n    const fromDynamicRetrievalConfig = getValueByPath(fromObject, [\n        \"dynamicRetrievalConfig\"\n    ]);\n    if (fromDynamicRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"dynamicRetrievalConfig\"\n        ], dynamicRetrievalConfigToMldev$2(apiClient, fromDynamicRetrievalConfig));\n    }\n    return toObject;\n}\nfunction toolToMldev$2(apiClient, fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        if (Array.isArray(fromFunctionDeclarations)) {\n            setValueByPath(toObject, [\n                \"functionDeclarations\"\n            ], fromFunctionDeclarations.map((item)=>{\n                return functionDeclarationToMldev$2(apiClient, item);\n            }));\n        } else {\n            setValueByPath(toObject, [\n                \"functionDeclarations\"\n            ], fromFunctionDeclarations);\n        }\n    }\n    if (getValueByPath(fromObject, [\n        \"retrieval\"\n    ]) !== undefined) {\n        throw new Error(\"retrieval parameter is not supported in Gemini API.\");\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], googleSearchToMldev$2());\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], googleSearchRetrievalToMldev$2(apiClient, fromGoogleSearchRetrieval));\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    return toObject;\n}\nfunction functionCallingConfigToMldev$1(apiClient, fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromAllowedFunctionNames = getValueByPath(fromObject, [\n        \"allowedFunctionNames\"\n    ]);\n    if (fromAllowedFunctionNames != null) {\n        setValueByPath(toObject, [\n            \"allowedFunctionNames\"\n        ], fromAllowedFunctionNames);\n    }\n    return toObject;\n}\nfunction toolConfigToMldev$1(apiClient, fromObject) {\n    const toObject = {};\n    const fromFunctionCallingConfig = getValueByPath(fromObject, [\n        \"functionCallingConfig\"\n    ]);\n    if (fromFunctionCallingConfig != null) {\n        setValueByPath(toObject, [\n            \"functionCallingConfig\"\n        ], functionCallingConfigToMldev$1(apiClient, fromFunctionCallingConfig));\n    }\n    return toObject;\n}\nfunction createCachedContentConfigToMldev(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromTtl = getValueByPath(fromObject, [\n        \"ttl\"\n    ]);\n    if (parentObject !== undefined && fromTtl != null) {\n        setValueByPath(parentObject, [\n            \"ttl\"\n        ], fromTtl);\n    }\n    const fromExpireTime = getValueByPath(fromObject, [\n        \"expireTime\"\n    ]);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, [\n            \"expireTime\"\n        ], fromExpireTime);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (parentObject !== undefined && fromContents != null) {\n        if (Array.isArray(fromContents)) {\n            setValueByPath(parentObject, [\n                \"contents\"\n            ], tContents(apiClient, tContents(apiClient, fromContents).map((item)=>{\n                return contentToMldev$2(apiClient, item);\n            })));\n        } else {\n            setValueByPath(parentObject, [\n                \"contents\"\n            ], tContents(apiClient, fromContents));\n        }\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"systemInstruction\"\n        ], contentToMldev$2(apiClient, tContent(apiClient, fromSystemInstruction)));\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        if (Array.isArray(fromTools)) {\n            setValueByPath(parentObject, [\n                \"tools\"\n            ], fromTools.map((item)=>{\n                return toolToMldev$2(apiClient, item);\n            }));\n        } else {\n            setValueByPath(parentObject, [\n                \"tools\"\n            ], fromTools);\n        }\n    }\n    const fromToolConfig = getValueByPath(fromObject, [\n        \"toolConfig\"\n    ]);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, [\n            \"toolConfig\"\n        ], toolConfigToMldev$1(apiClient, fromToolConfig));\n    }\n    return toObject;\n}\nfunction createCachedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"model\"\n        ], tCachesModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], createCachedContentConfigToMldev(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction getCachedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tCachedContentName(apiClient, fromName));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction deleteCachedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tCachedContentName(apiClient, fromName));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction updateCachedContentConfigToMldev(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromTtl = getValueByPath(fromObject, [\n        \"ttl\"\n    ]);\n    if (parentObject !== undefined && fromTtl != null) {\n        setValueByPath(parentObject, [\n            \"ttl\"\n        ], fromTtl);\n    }\n    const fromExpireTime = getValueByPath(fromObject, [\n        \"expireTime\"\n    ]);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, [\n            \"expireTime\"\n        ], fromExpireTime);\n    }\n    return toObject;\n}\nfunction updateCachedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tCachedContentName(apiClient, fromName));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], updateCachedContentConfigToMldev(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction listCachedContentsConfigToMldev(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    return toObject;\n}\nfunction listCachedContentsParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], listCachedContentsConfigToMldev(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction partToVertex$2(apiClient, fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], fromVideoMetadata);\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fromFileData);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], fromFunctionCall);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], fromInlineData);\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    return toObject;\n}\nfunction contentToVertex$2(apiClient, fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        if (Array.isArray(fromParts)) {\n            setValueByPath(toObject, [\n                \"parts\"\n            ], fromParts.map((item)=>{\n                return partToVertex$2(apiClient, item);\n            }));\n        } else {\n            setValueByPath(toObject, [\n                \"parts\"\n            ], fromParts);\n        }\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction schemaToVertex$2(apiClient, fromObject) {\n    const toObject = {};\n    const fromExample = getValueByPath(fromObject, [\n        \"example\"\n    ]);\n    if (fromExample != null) {\n        setValueByPath(toObject, [\n            \"example\"\n        ], fromExample);\n    }\n    const fromPattern = getValueByPath(fromObject, [\n        \"pattern\"\n    ]);\n    if (fromPattern != null) {\n        setValueByPath(toObject, [\n            \"pattern\"\n        ], fromPattern);\n    }\n    const fromDefault = getValueByPath(fromObject, [\n        \"default\"\n    ]);\n    if (fromDefault != null) {\n        setValueByPath(toObject, [\n            \"default\"\n        ], fromDefault);\n    }\n    const fromMaxLength = getValueByPath(fromObject, [\n        \"maxLength\"\n    ]);\n    if (fromMaxLength != null) {\n        setValueByPath(toObject, [\n            \"maxLength\"\n        ], fromMaxLength);\n    }\n    const fromMinLength = getValueByPath(fromObject, [\n        \"minLength\"\n    ]);\n    if (fromMinLength != null) {\n        setValueByPath(toObject, [\n            \"minLength\"\n        ], fromMinLength);\n    }\n    const fromMinProperties = getValueByPath(fromObject, [\n        \"minProperties\"\n    ]);\n    if (fromMinProperties != null) {\n        setValueByPath(toObject, [\n            \"minProperties\"\n        ], fromMinProperties);\n    }\n    const fromMaxProperties = getValueByPath(fromObject, [\n        \"maxProperties\"\n    ]);\n    if (fromMaxProperties != null) {\n        setValueByPath(toObject, [\n            \"maxProperties\"\n        ], fromMaxProperties);\n    }\n    const fromAnyOf = getValueByPath(fromObject, [\n        \"anyOf\"\n    ]);\n    if (fromAnyOf != null) {\n        setValueByPath(toObject, [\n            \"anyOf\"\n        ], fromAnyOf);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromEnum = getValueByPath(fromObject, [\n        \"enum\"\n    ]);\n    if (fromEnum != null) {\n        setValueByPath(toObject, [\n            \"enum\"\n        ], fromEnum);\n    }\n    const fromFormat = getValueByPath(fromObject, [\n        \"format\"\n    ]);\n    if (fromFormat != null) {\n        setValueByPath(toObject, [\n            \"format\"\n        ], fromFormat);\n    }\n    const fromItems = getValueByPath(fromObject, [\n        \"items\"\n    ]);\n    if (fromItems != null) {\n        setValueByPath(toObject, [\n            \"items\"\n        ], fromItems);\n    }\n    const fromMaxItems = getValueByPath(fromObject, [\n        \"maxItems\"\n    ]);\n    if (fromMaxItems != null) {\n        setValueByPath(toObject, [\n            \"maxItems\"\n        ], fromMaxItems);\n    }\n    const fromMaximum = getValueByPath(fromObject, [\n        \"maximum\"\n    ]);\n    if (fromMaximum != null) {\n        setValueByPath(toObject, [\n            \"maximum\"\n        ], fromMaximum);\n    }\n    const fromMinItems = getValueByPath(fromObject, [\n        \"minItems\"\n    ]);\n    if (fromMinItems != null) {\n        setValueByPath(toObject, [\n            \"minItems\"\n        ], fromMinItems);\n    }\n    const fromMinimum = getValueByPath(fromObject, [\n        \"minimum\"\n    ]);\n    if (fromMinimum != null) {\n        setValueByPath(toObject, [\n            \"minimum\"\n        ], fromMinimum);\n    }\n    const fromNullable = getValueByPath(fromObject, [\n        \"nullable\"\n    ]);\n    if (fromNullable != null) {\n        setValueByPath(toObject, [\n            \"nullable\"\n        ], fromNullable);\n    }\n    const fromProperties = getValueByPath(fromObject, [\n        \"properties\"\n    ]);\n    if (fromProperties != null) {\n        setValueByPath(toObject, [\n            \"properties\"\n        ], fromProperties);\n    }\n    const fromPropertyOrdering = getValueByPath(fromObject, [\n        \"propertyOrdering\"\n    ]);\n    if (fromPropertyOrdering != null) {\n        setValueByPath(toObject, [\n            \"propertyOrdering\"\n        ], fromPropertyOrdering);\n    }\n    const fromRequired = getValueByPath(fromObject, [\n        \"required\"\n    ]);\n    if (fromRequired != null) {\n        setValueByPath(toObject, [\n            \"required\"\n        ], fromRequired);\n    }\n    const fromTitle = getValueByPath(fromObject, [\n        \"title\"\n    ]);\n    if (fromTitle != null) {\n        setValueByPath(toObject, [\n            \"title\"\n        ], fromTitle);\n    }\n    const fromType = getValueByPath(fromObject, [\n        \"type\"\n    ]);\n    if (fromType != null) {\n        setValueByPath(toObject, [\n            \"type\"\n        ], fromType);\n    }\n    return toObject;\n}\nfunction functionDeclarationToVertex$2(apiClient, fromObject) {\n    const toObject = {};\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], schemaToVertex$2(apiClient, fromResponse));\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, [\n        \"parameters\"\n    ]);\n    if (fromParameters != null) {\n        setValueByPath(toObject, [\n            \"parameters\"\n        ], fromParameters);\n    }\n    return toObject;\n}\nfunction googleSearchToVertex$2() {\n    const toObject = {};\n    return toObject;\n}\nfunction dynamicRetrievalConfigToVertex$2(apiClient, fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromDynamicThreshold = getValueByPath(fromObject, [\n        \"dynamicThreshold\"\n    ]);\n    if (fromDynamicThreshold != null) {\n        setValueByPath(toObject, [\n            \"dynamicThreshold\"\n        ], fromDynamicThreshold);\n    }\n    return toObject;\n}\nfunction googleSearchRetrievalToVertex$2(apiClient, fromObject) {\n    const toObject = {};\n    const fromDynamicRetrievalConfig = getValueByPath(fromObject, [\n        \"dynamicRetrievalConfig\"\n    ]);\n    if (fromDynamicRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"dynamicRetrievalConfig\"\n        ], dynamicRetrievalConfigToVertex$2(apiClient, fromDynamicRetrievalConfig));\n    }\n    return toObject;\n}\nfunction toolToVertex$2(apiClient, fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        if (Array.isArray(fromFunctionDeclarations)) {\n            setValueByPath(toObject, [\n                \"functionDeclarations\"\n            ], fromFunctionDeclarations.map((item)=>{\n                return functionDeclarationToVertex$2(apiClient, item);\n            }));\n        } else {\n            setValueByPath(toObject, [\n                \"functionDeclarations\"\n            ], fromFunctionDeclarations);\n        }\n    }\n    const fromRetrieval = getValueByPath(fromObject, [\n        \"retrieval\"\n    ]);\n    if (fromRetrieval != null) {\n        setValueByPath(toObject, [\n            \"retrieval\"\n        ], fromRetrieval);\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], googleSearchToVertex$2());\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], googleSearchRetrievalToVertex$2(apiClient, fromGoogleSearchRetrieval));\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    return toObject;\n}\nfunction functionCallingConfigToVertex$1(apiClient, fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromAllowedFunctionNames = getValueByPath(fromObject, [\n        \"allowedFunctionNames\"\n    ]);\n    if (fromAllowedFunctionNames != null) {\n        setValueByPath(toObject, [\n            \"allowedFunctionNames\"\n        ], fromAllowedFunctionNames);\n    }\n    return toObject;\n}\nfunction toolConfigToVertex$1(apiClient, fromObject) {\n    const toObject = {};\n    const fromFunctionCallingConfig = getValueByPath(fromObject, [\n        \"functionCallingConfig\"\n    ]);\n    if (fromFunctionCallingConfig != null) {\n        setValueByPath(toObject, [\n            \"functionCallingConfig\"\n        ], functionCallingConfigToVertex$1(apiClient, fromFunctionCallingConfig));\n    }\n    return toObject;\n}\nfunction createCachedContentConfigToVertex(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromTtl = getValueByPath(fromObject, [\n        \"ttl\"\n    ]);\n    if (parentObject !== undefined && fromTtl != null) {\n        setValueByPath(parentObject, [\n            \"ttl\"\n        ], fromTtl);\n    }\n    const fromExpireTime = getValueByPath(fromObject, [\n        \"expireTime\"\n    ]);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, [\n            \"expireTime\"\n        ], fromExpireTime);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (parentObject !== undefined && fromContents != null) {\n        if (Array.isArray(fromContents)) {\n            setValueByPath(parentObject, [\n                \"contents\"\n            ], tContents(apiClient, tContents(apiClient, fromContents).map((item)=>{\n                return contentToVertex$2(apiClient, item);\n            })));\n        } else {\n            setValueByPath(parentObject, [\n                \"contents\"\n            ], tContents(apiClient, fromContents));\n        }\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"systemInstruction\"\n        ], contentToVertex$2(apiClient, tContent(apiClient, fromSystemInstruction)));\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        if (Array.isArray(fromTools)) {\n            setValueByPath(parentObject, [\n                \"tools\"\n            ], fromTools.map((item)=>{\n                return toolToVertex$2(apiClient, item);\n            }));\n        } else {\n            setValueByPath(parentObject, [\n                \"tools\"\n            ], fromTools);\n        }\n    }\n    const fromToolConfig = getValueByPath(fromObject, [\n        \"toolConfig\"\n    ]);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, [\n            \"toolConfig\"\n        ], toolConfigToVertex$1(apiClient, fromToolConfig));\n    }\n    return toObject;\n}\nfunction createCachedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"model\"\n        ], tCachesModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], createCachedContentConfigToVertex(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction getCachedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tCachedContentName(apiClient, fromName));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction deleteCachedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tCachedContentName(apiClient, fromName));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction updateCachedContentConfigToVertex(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromTtl = getValueByPath(fromObject, [\n        \"ttl\"\n    ]);\n    if (parentObject !== undefined && fromTtl != null) {\n        setValueByPath(parentObject, [\n            \"ttl\"\n        ], fromTtl);\n    }\n    const fromExpireTime = getValueByPath(fromObject, [\n        \"expireTime\"\n    ]);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, [\n            \"expireTime\"\n        ], fromExpireTime);\n    }\n    return toObject;\n}\nfunction updateCachedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tCachedContentName(apiClient, fromName));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], updateCachedContentConfigToVertex(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction listCachedContentsConfigToVertex(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    return toObject;\n}\nfunction listCachedContentsParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], listCachedContentsConfigToVertex(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction cachedContentFromMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"model\"\n        ], fromModel);\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    const fromExpireTime = getValueByPath(fromObject, [\n        \"expireTime\"\n    ]);\n    if (fromExpireTime != null) {\n        setValueByPath(toObject, [\n            \"expireTime\"\n        ], fromExpireTime);\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        \"usageMetadata\"\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, [\n            \"usageMetadata\"\n        ], fromUsageMetadata);\n    }\n    return toObject;\n}\nfunction deleteCachedContentResponseFromMldev() {\n    const toObject = {};\n    return toObject;\n}\nfunction listCachedContentsResponseFromMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromCachedContents = getValueByPath(fromObject, [\n        \"cachedContents\"\n    ]);\n    if (fromCachedContents != null) {\n        if (Array.isArray(fromCachedContents)) {\n            setValueByPath(toObject, [\n                \"cachedContents\"\n            ], fromCachedContents.map((item)=>{\n                return cachedContentFromMldev(apiClient, item);\n            }));\n        } else {\n            setValueByPath(toObject, [\n                \"cachedContents\"\n            ], fromCachedContents);\n        }\n    }\n    return toObject;\n}\nfunction cachedContentFromVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"model\"\n        ], fromModel);\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    const fromExpireTime = getValueByPath(fromObject, [\n        \"expireTime\"\n    ]);\n    if (fromExpireTime != null) {\n        setValueByPath(toObject, [\n            \"expireTime\"\n        ], fromExpireTime);\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        \"usageMetadata\"\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, [\n            \"usageMetadata\"\n        ], fromUsageMetadata);\n    }\n    return toObject;\n}\nfunction deleteCachedContentResponseFromVertex() {\n    const toObject = {};\n    return toObject;\n}\nfunction listCachedContentsResponseFromVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromCachedContents = getValueByPath(fromObject, [\n        \"cachedContents\"\n    ]);\n    if (fromCachedContents != null) {\n        if (Array.isArray(fromCachedContents)) {\n            setValueByPath(toObject, [\n                \"cachedContents\"\n            ], fromCachedContents.map((item)=>{\n                return cachedContentFromVertex(apiClient, item);\n            }));\n        } else {\n            setValueByPath(toObject, [\n                \"cachedContents\"\n            ], fromCachedContents);\n        }\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ /**\n * Pagers for the GenAI List APIs.\n */ exports.PagedItem = void 0;\n(function(PagedItem) {\n    PagedItem[\"PAGED_ITEM_BATCH_JOBS\"] = \"batchJobs\";\n    PagedItem[\"PAGED_ITEM_MODELS\"] = \"models\";\n    PagedItem[\"PAGED_ITEM_TUNING_JOBS\"] = \"tuningJobs\";\n    PagedItem[\"PAGED_ITEM_FILES\"] = \"files\";\n    PagedItem[\"PAGED_ITEM_CACHED_CONTENTS\"] = \"cachedContents\";\n})(exports.PagedItem || (exports.PagedItem = {}));\n/**\n * Pager class for iterating through paginated results.\n */ class Pager {\n    constructor(name, request, response, params){\n        this.pageInternal = [];\n        this.paramsInternal = {};\n        this.requestInternal = request;\n        this.init(name, response, params);\n    }\n    init(name, response, params) {\n        var _a, _b;\n        this.nameInternal = name;\n        this.pageInternal = response[this.nameInternal] || [];\n        this.idxInternal = 0;\n        let requestParams = {\n            config: {}\n        };\n        if (!params) {\n            requestParams = {\n                config: {}\n            };\n        } else if (typeof params === \"object\") {\n            requestParams = Object.assign({}, params);\n        } else {\n            requestParams = params;\n        }\n        if (requestParams[\"config\"]) {\n            requestParams[\"config\"][\"pageToken\"] = response[\"nextPageToken\"];\n        }\n        this.paramsInternal = requestParams;\n        this.pageInternalSize = (_b = (_a = requestParams[\"config\"]) === null || _a === void 0 ? void 0 : _a[\"pageSize\"]) !== null && _b !== void 0 ? _b : this.pageInternal.length;\n    }\n    initNextPage(response) {\n        this.init(this.nameInternal, response, this.paramsInternal);\n    }\n    /**\n     * Returns the current page, which is a list of items.\n     *\n     * @remarks\n     * The first page is retrieved when the pager is created. The returned list of\n     * items could be a subset of the entire list.\n     */ get page() {\n        return this.pageInternal;\n    }\n    /**\n     * Returns the type of paged item (for example, ``batch_jobs``).\n     */ get name() {\n        return this.nameInternal;\n    }\n    /**\n     * Returns the length of the page fetched each time by this pager.\n     *\n     * @remarks\n     * The number of items in the page is less than or equal to the page length.\n     */ get pageSize() {\n        return this.pageInternalSize;\n    }\n    /**\n     * Returns the parameters when making the API request for the next page.\n     *\n     * @remarks\n     * Parameters contain a set of optional configs that can be\n     * used to customize the API request. For example, the `pageToken` parameter\n     * contains the token to request the next page.\n     */ get params() {\n        return this.paramsInternal;\n    }\n    /**\n     * Returns the total number of items in the current page.\n     */ get pageLength() {\n        return this.pageInternal.length;\n    }\n    /**\n     * Returns the item at the given index.\n     */ getItem(index) {\n        return this.pageInternal[index];\n    }\n    /**\n     * Returns an async iterator that support iterating through all items\n     * retrieved from the API.\n     *\n     * @remarks\n     * The iterator will automatically fetch the next page if there are more items\n     * to fetch from the API.\n     *\n     * @example\n     *\n     * ```ts\n     * const pager = await ai.files.list({config: {pageSize: 10}});\n     * for await (const file of pager) {\n     *   console.log(file.name);\n     * }\n     * ```\n     */ [Symbol.asyncIterator]() {\n        return {\n            next: async ()=>{\n                if (this.idxInternal >= this.pageLength) {\n                    if (this.hasNextPage()) {\n                        await this.nextPage();\n                    } else {\n                        return {\n                            value: undefined,\n                            done: true\n                        };\n                    }\n                }\n                const item = this.getItem(this.idxInternal);\n                this.idxInternal += 1;\n                return {\n                    value: item,\n                    done: false\n                };\n            },\n            return: async ()=>{\n                return {\n                    value: undefined,\n                    done: true\n                };\n            }\n        };\n    }\n    /**\n     * Fetches the next page of items. This makes a new API request.\n     *\n     * @throws {Error} If there are no more pages to fetch.\n     *\n     * @example\n     *\n     * ```ts\n     * const pager = await ai.files.list({config: {pageSize: 10}});\n     * let page = pager.page;\n     * while (true) {\n     *   for (const file of page) {\n     *     console.log(file.name);\n     *   }\n     *   if (!pager.hasNextPage()) {\n     *     break;\n     *   }\n     *   page = await pager.nextPage();\n     * }\n     * ```\n     */ async nextPage() {\n        if (!this.hasNextPage()) {\n            throw new Error(\"No more pages to fetch.\");\n        }\n        const response = await this.requestInternal(this.params);\n        this.initNextPage(response);\n        return this.page;\n    }\n    /**\n     * Returns true if there are more pages to fetch from the API.\n     */ hasNextPage() {\n        var _a;\n        if (((_a = this.params[\"config\"]) === null || _a === void 0 ? void 0 : _a[\"pageToken\"]) !== undefined) {\n            return true;\n        }\n        return false;\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ // Code generated by the Google Gen AI SDK generator DO NOT EDIT.\n/** Required. Outcome of the code execution. */ exports.Outcome = void 0;\n(function(Outcome) {\n    Outcome[\"OUTCOME_UNSPECIFIED\"] = \"OUTCOME_UNSPECIFIED\";\n    Outcome[\"OUTCOME_OK\"] = \"OUTCOME_OK\";\n    Outcome[\"OUTCOME_FAILED\"] = \"OUTCOME_FAILED\";\n    Outcome[\"OUTCOME_DEADLINE_EXCEEDED\"] = \"OUTCOME_DEADLINE_EXCEEDED\";\n})(exports.Outcome || (exports.Outcome = {}));\n/** Required. Programming language of the `code`. */ exports.Language = void 0;\n(function(Language) {\n    Language[\"LANGUAGE_UNSPECIFIED\"] = \"LANGUAGE_UNSPECIFIED\";\n    Language[\"PYTHON\"] = \"PYTHON\";\n})(exports.Language || (exports.Language = {}));\n/** Optional. The type of the data. */ exports.Type = void 0;\n(function(Type) {\n    Type[\"TYPE_UNSPECIFIED\"] = \"TYPE_UNSPECIFIED\";\n    Type[\"STRING\"] = \"STRING\";\n    Type[\"NUMBER\"] = \"NUMBER\";\n    Type[\"INTEGER\"] = \"INTEGER\";\n    Type[\"BOOLEAN\"] = \"BOOLEAN\";\n    Type[\"ARRAY\"] = \"ARRAY\";\n    Type[\"OBJECT\"] = \"OBJECT\";\n})(exports.Type || (exports.Type = {}));\n/** Required. Harm category. */ exports.HarmCategory = void 0;\n(function(HarmCategory) {\n    HarmCategory[\"HARM_CATEGORY_UNSPECIFIED\"] = \"HARM_CATEGORY_UNSPECIFIED\";\n    HarmCategory[\"HARM_CATEGORY_HATE_SPEECH\"] = \"HARM_CATEGORY_HATE_SPEECH\";\n    HarmCategory[\"HARM_CATEGORY_DANGEROUS_CONTENT\"] = \"HARM_CATEGORY_DANGEROUS_CONTENT\";\n    HarmCategory[\"HARM_CATEGORY_HARASSMENT\"] = \"HARM_CATEGORY_HARASSMENT\";\n    HarmCategory[\"HARM_CATEGORY_SEXUALLY_EXPLICIT\"] = \"HARM_CATEGORY_SEXUALLY_EXPLICIT\";\n    HarmCategory[\"HARM_CATEGORY_CIVIC_INTEGRITY\"] = \"HARM_CATEGORY_CIVIC_INTEGRITY\";\n})(exports.HarmCategory || (exports.HarmCategory = {}));\n/** Optional. Specify if the threshold is used for probability or severity score. If not specified, the threshold is used for probability score. */ exports.HarmBlockMethod = void 0;\n(function(HarmBlockMethod) {\n    HarmBlockMethod[\"HARM_BLOCK_METHOD_UNSPECIFIED\"] = \"HARM_BLOCK_METHOD_UNSPECIFIED\";\n    HarmBlockMethod[\"SEVERITY\"] = \"SEVERITY\";\n    HarmBlockMethod[\"PROBABILITY\"] = \"PROBABILITY\";\n})(exports.HarmBlockMethod || (exports.HarmBlockMethod = {}));\n/** Required. The harm block threshold. */ exports.HarmBlockThreshold = void 0;\n(function(HarmBlockThreshold) {\n    HarmBlockThreshold[\"HARM_BLOCK_THRESHOLD_UNSPECIFIED\"] = \"HARM_BLOCK_THRESHOLD_UNSPECIFIED\";\n    HarmBlockThreshold[\"BLOCK_LOW_AND_ABOVE\"] = \"BLOCK_LOW_AND_ABOVE\";\n    HarmBlockThreshold[\"BLOCK_MEDIUM_AND_ABOVE\"] = \"BLOCK_MEDIUM_AND_ABOVE\";\n    HarmBlockThreshold[\"BLOCK_ONLY_HIGH\"] = \"BLOCK_ONLY_HIGH\";\n    HarmBlockThreshold[\"BLOCK_NONE\"] = \"BLOCK_NONE\";\n    HarmBlockThreshold[\"OFF\"] = \"OFF\";\n})(exports.HarmBlockThreshold || (exports.HarmBlockThreshold = {}));\n/** The mode of the predictor to be used in dynamic retrieval. */ exports.Mode = void 0;\n(function(Mode) {\n    Mode[\"MODE_UNSPECIFIED\"] = \"MODE_UNSPECIFIED\";\n    Mode[\"MODE_DYNAMIC\"] = \"MODE_DYNAMIC\";\n})(exports.Mode || (exports.Mode = {}));\n/** Output only. The reason why the model stopped generating tokens.\n\n  If empty, the model has not stopped generating the tokens.\n   */ exports.FinishReason = void 0;\n(function(FinishReason) {\n    FinishReason[\"FINISH_REASON_UNSPECIFIED\"] = \"FINISH_REASON_UNSPECIFIED\";\n    FinishReason[\"STOP\"] = \"STOP\";\n    FinishReason[\"MAX_TOKENS\"] = \"MAX_TOKENS\";\n    FinishReason[\"SAFETY\"] = \"SAFETY\";\n    FinishReason[\"RECITATION\"] = \"RECITATION\";\n    FinishReason[\"LANGUAGE\"] = \"LANGUAGE\";\n    FinishReason[\"OTHER\"] = \"OTHER\";\n    FinishReason[\"BLOCKLIST\"] = \"BLOCKLIST\";\n    FinishReason[\"PROHIBITED_CONTENT\"] = \"PROHIBITED_CONTENT\";\n    FinishReason[\"SPII\"] = \"SPII\";\n    FinishReason[\"MALFORMED_FUNCTION_CALL\"] = \"MALFORMED_FUNCTION_CALL\";\n    FinishReason[\"IMAGE_SAFETY\"] = \"IMAGE_SAFETY\";\n})(exports.FinishReason || (exports.FinishReason = {}));\n/** Output only. Harm probability levels in the content. */ exports.HarmProbability = void 0;\n(function(HarmProbability) {\n    HarmProbability[\"HARM_PROBABILITY_UNSPECIFIED\"] = \"HARM_PROBABILITY_UNSPECIFIED\";\n    HarmProbability[\"NEGLIGIBLE\"] = \"NEGLIGIBLE\";\n    HarmProbability[\"LOW\"] = \"LOW\";\n    HarmProbability[\"MEDIUM\"] = \"MEDIUM\";\n    HarmProbability[\"HIGH\"] = \"HIGH\";\n})(exports.HarmProbability || (exports.HarmProbability = {}));\n/** Output only. Harm severity levels in the content. */ exports.HarmSeverity = void 0;\n(function(HarmSeverity) {\n    HarmSeverity[\"HARM_SEVERITY_UNSPECIFIED\"] = \"HARM_SEVERITY_UNSPECIFIED\";\n    HarmSeverity[\"HARM_SEVERITY_NEGLIGIBLE\"] = \"HARM_SEVERITY_NEGLIGIBLE\";\n    HarmSeverity[\"HARM_SEVERITY_LOW\"] = \"HARM_SEVERITY_LOW\";\n    HarmSeverity[\"HARM_SEVERITY_MEDIUM\"] = \"HARM_SEVERITY_MEDIUM\";\n    HarmSeverity[\"HARM_SEVERITY_HIGH\"] = \"HARM_SEVERITY_HIGH\";\n})(exports.HarmSeverity || (exports.HarmSeverity = {}));\n/** Output only. Blocked reason. */ exports.BlockedReason = void 0;\n(function(BlockedReason) {\n    BlockedReason[\"BLOCKED_REASON_UNSPECIFIED\"] = \"BLOCKED_REASON_UNSPECIFIED\";\n    BlockedReason[\"SAFETY\"] = \"SAFETY\";\n    BlockedReason[\"OTHER\"] = \"OTHER\";\n    BlockedReason[\"BLOCKLIST\"] = \"BLOCKLIST\";\n    BlockedReason[\"PROHIBITED_CONTENT\"] = \"PROHIBITED_CONTENT\";\n})(exports.BlockedReason || (exports.BlockedReason = {}));\n/** Output only. Traffic type. This shows whether a request consumes Pay-As-You-Go or Provisioned Throughput quota. */ exports.TrafficType = void 0;\n(function(TrafficType) {\n    TrafficType[\"TRAFFIC_TYPE_UNSPECIFIED\"] = \"TRAFFIC_TYPE_UNSPECIFIED\";\n    TrafficType[\"ON_DEMAND\"] = \"ON_DEMAND\";\n    TrafficType[\"PROVISIONED_THROUGHPUT\"] = \"PROVISIONED_THROUGHPUT\";\n})(exports.TrafficType || (exports.TrafficType = {}));\n/** Server content modalities. */ exports.Modality = void 0;\n(function(Modality) {\n    Modality[\"MODALITY_UNSPECIFIED\"] = \"MODALITY_UNSPECIFIED\";\n    Modality[\"TEXT\"] = \"TEXT\";\n    Modality[\"IMAGE\"] = \"IMAGE\";\n    Modality[\"AUDIO\"] = \"AUDIO\";\n})(exports.Modality || (exports.Modality = {}));\n/** The media resolution to use. */ exports.MediaResolution = void 0;\n(function(MediaResolution) {\n    MediaResolution[\"MEDIA_RESOLUTION_UNSPECIFIED\"] = \"MEDIA_RESOLUTION_UNSPECIFIED\";\n    MediaResolution[\"MEDIA_RESOLUTION_LOW\"] = \"MEDIA_RESOLUTION_LOW\";\n    MediaResolution[\"MEDIA_RESOLUTION_MEDIUM\"] = \"MEDIA_RESOLUTION_MEDIUM\";\n    MediaResolution[\"MEDIA_RESOLUTION_HIGH\"] = \"MEDIA_RESOLUTION_HIGH\";\n})(exports.MediaResolution || (exports.MediaResolution = {}));\n/** Options for feature selection preference. */ exports.FeatureSelectionPreference = void 0;\n(function(FeatureSelectionPreference) {\n    FeatureSelectionPreference[\"FEATURE_SELECTION_PREFERENCE_UNSPECIFIED\"] = \"FEATURE_SELECTION_PREFERENCE_UNSPECIFIED\";\n    FeatureSelectionPreference[\"PRIORITIZE_QUALITY\"] = \"PRIORITIZE_QUALITY\";\n    FeatureSelectionPreference[\"BALANCED\"] = \"BALANCED\";\n    FeatureSelectionPreference[\"PRIORITIZE_COST\"] = \"PRIORITIZE_COST\";\n})(exports.FeatureSelectionPreference || (exports.FeatureSelectionPreference = {}));\n/** Config for the dynamic retrieval config mode. */ exports.DynamicRetrievalConfigMode = void 0;\n(function(DynamicRetrievalConfigMode) {\n    DynamicRetrievalConfigMode[\"MODE_UNSPECIFIED\"] = \"MODE_UNSPECIFIED\";\n    DynamicRetrievalConfigMode[\"MODE_DYNAMIC\"] = \"MODE_DYNAMIC\";\n})(exports.DynamicRetrievalConfigMode || (exports.DynamicRetrievalConfigMode = {}));\n/** Config for the function calling config mode. */ exports.FunctionCallingConfigMode = void 0;\n(function(FunctionCallingConfigMode) {\n    FunctionCallingConfigMode[\"MODE_UNSPECIFIED\"] = \"MODE_UNSPECIFIED\";\n    FunctionCallingConfigMode[\"AUTO\"] = \"AUTO\";\n    FunctionCallingConfigMode[\"ANY\"] = \"ANY\";\n    FunctionCallingConfigMode[\"NONE\"] = \"NONE\";\n})(exports.FunctionCallingConfigMode || (exports.FunctionCallingConfigMode = {}));\n/** Enum that controls the safety filter level for objectionable content. */ exports.SafetyFilterLevel = void 0;\n(function(SafetyFilterLevel) {\n    SafetyFilterLevel[\"BLOCK_LOW_AND_ABOVE\"] = \"BLOCK_LOW_AND_ABOVE\";\n    SafetyFilterLevel[\"BLOCK_MEDIUM_AND_ABOVE\"] = \"BLOCK_MEDIUM_AND_ABOVE\";\n    SafetyFilterLevel[\"BLOCK_ONLY_HIGH\"] = \"BLOCK_ONLY_HIGH\";\n    SafetyFilterLevel[\"BLOCK_NONE\"] = \"BLOCK_NONE\";\n})(exports.SafetyFilterLevel || (exports.SafetyFilterLevel = {}));\n/** Enum that controls the generation of people. */ exports.PersonGeneration = void 0;\n(function(PersonGeneration) {\n    PersonGeneration[\"DONT_ALLOW\"] = \"DONT_ALLOW\";\n    PersonGeneration[\"ALLOW_ADULT\"] = \"ALLOW_ADULT\";\n    PersonGeneration[\"ALLOW_ALL\"] = \"ALLOW_ALL\";\n})(exports.PersonGeneration || (exports.PersonGeneration = {}));\n/** Enum that specifies the language of the text in the prompt. */ exports.ImagePromptLanguage = void 0;\n(function(ImagePromptLanguage) {\n    ImagePromptLanguage[\"auto\"] = \"auto\";\n    ImagePromptLanguage[\"en\"] = \"en\";\n    ImagePromptLanguage[\"ja\"] = \"ja\";\n    ImagePromptLanguage[\"ko\"] = \"ko\";\n    ImagePromptLanguage[\"hi\"] = \"hi\";\n})(exports.ImagePromptLanguage || (exports.ImagePromptLanguage = {}));\n/** State for the lifecycle of a File. */ exports.FileState = void 0;\n(function(FileState) {\n    FileState[\"STATE_UNSPECIFIED\"] = \"STATE_UNSPECIFIED\";\n    FileState[\"PROCESSING\"] = \"PROCESSING\";\n    FileState[\"ACTIVE\"] = \"ACTIVE\";\n    FileState[\"FAILED\"] = \"FAILED\";\n})(exports.FileState || (exports.FileState = {}));\n/** Source of the File. */ exports.FileSource = void 0;\n(function(FileSource) {\n    FileSource[\"SOURCE_UNSPECIFIED\"] = \"SOURCE_UNSPECIFIED\";\n    FileSource[\"UPLOADED\"] = \"UPLOADED\";\n    FileSource[\"GENERATED\"] = \"GENERATED\";\n})(exports.FileSource || (exports.FileSource = {}));\n/** Enum representing the mask mode of a mask reference image. */ exports.MaskReferenceMode = void 0;\n(function(MaskReferenceMode) {\n    MaskReferenceMode[\"MASK_MODE_DEFAULT\"] = \"MASK_MODE_DEFAULT\";\n    MaskReferenceMode[\"MASK_MODE_USER_PROVIDED\"] = \"MASK_MODE_USER_PROVIDED\";\n    MaskReferenceMode[\"MASK_MODE_BACKGROUND\"] = \"MASK_MODE_BACKGROUND\";\n    MaskReferenceMode[\"MASK_MODE_FOREGROUND\"] = \"MASK_MODE_FOREGROUND\";\n    MaskReferenceMode[\"MASK_MODE_SEMANTIC\"] = \"MASK_MODE_SEMANTIC\";\n})(exports.MaskReferenceMode || (exports.MaskReferenceMode = {}));\n/** Enum representing the control type of a control reference image. */ exports.ControlReferenceType = void 0;\n(function(ControlReferenceType) {\n    ControlReferenceType[\"CONTROL_TYPE_DEFAULT\"] = \"CONTROL_TYPE_DEFAULT\";\n    ControlReferenceType[\"CONTROL_TYPE_CANNY\"] = \"CONTROL_TYPE_CANNY\";\n    ControlReferenceType[\"CONTROL_TYPE_SCRIBBLE\"] = \"CONTROL_TYPE_SCRIBBLE\";\n    ControlReferenceType[\"CONTROL_TYPE_FACE_MESH\"] = \"CONTROL_TYPE_FACE_MESH\";\n})(exports.ControlReferenceType || (exports.ControlReferenceType = {}));\n/** Enum representing the subject type of a subject reference image. */ exports.SubjectReferenceType = void 0;\n(function(SubjectReferenceType) {\n    SubjectReferenceType[\"SUBJECT_TYPE_DEFAULT\"] = \"SUBJECT_TYPE_DEFAULT\";\n    SubjectReferenceType[\"SUBJECT_TYPE_PERSON\"] = \"SUBJECT_TYPE_PERSON\";\n    SubjectReferenceType[\"SUBJECT_TYPE_ANIMAL\"] = \"SUBJECT_TYPE_ANIMAL\";\n    SubjectReferenceType[\"SUBJECT_TYPE_PRODUCT\"] = \"SUBJECT_TYPE_PRODUCT\";\n})(exports.SubjectReferenceType || (exports.SubjectReferenceType = {}));\n/** Server content modalities. */ exports.MediaModality = void 0;\n(function(MediaModality) {\n    MediaModality[\"MODALITY_UNSPECIFIED\"] = \"MODALITY_UNSPECIFIED\";\n    MediaModality[\"TEXT\"] = \"TEXT\";\n    MediaModality[\"IMAGE\"] = \"IMAGE\";\n    MediaModality[\"VIDEO\"] = \"VIDEO\";\n    MediaModality[\"AUDIO\"] = \"AUDIO\";\n    MediaModality[\"DOCUMENT\"] = \"DOCUMENT\";\n})(exports.MediaModality || (exports.MediaModality = {}));\n/** Start of speech sensitivity. */ exports.StartSensitivity = void 0;\n(function(StartSensitivity) {\n    StartSensitivity[\"START_SENSITIVITY_UNSPECIFIED\"] = \"START_SENSITIVITY_UNSPECIFIED\";\n    StartSensitivity[\"START_SENSITIVITY_HIGH\"] = \"START_SENSITIVITY_HIGH\";\n    StartSensitivity[\"START_SENSITIVITY_LOW\"] = \"START_SENSITIVITY_LOW\";\n})(exports.StartSensitivity || (exports.StartSensitivity = {}));\n/** End of speech sensitivity. */ exports.EndSensitivity = void 0;\n(function(EndSensitivity) {\n    EndSensitivity[\"END_SENSITIVITY_UNSPECIFIED\"] = \"END_SENSITIVITY_UNSPECIFIED\";\n    EndSensitivity[\"END_SENSITIVITY_HIGH\"] = \"END_SENSITIVITY_HIGH\";\n    EndSensitivity[\"END_SENSITIVITY_LOW\"] = \"END_SENSITIVITY_LOW\";\n})(exports.EndSensitivity || (exports.EndSensitivity = {}));\n/** The different ways of handling user activity. */ exports.ActivityHandling = void 0;\n(function(ActivityHandling) {\n    ActivityHandling[\"ACTIVITY_HANDLING_UNSPECIFIED\"] = \"ACTIVITY_HANDLING_UNSPECIFIED\";\n    ActivityHandling[\"START_OF_ACTIVITY_INTERRUPTS\"] = \"START_OF_ACTIVITY_INTERRUPTS\";\n    ActivityHandling[\"NO_INTERRUPTION\"] = \"NO_INTERRUPTION\";\n})(exports.ActivityHandling || (exports.ActivityHandling = {}));\n/** Options about which input is included in the user's turn. */ exports.TurnCoverage = void 0;\n(function(TurnCoverage) {\n    TurnCoverage[\"TURN_COVERAGE_UNSPECIFIED\"] = \"TURN_COVERAGE_UNSPECIFIED\";\n    TurnCoverage[\"TURN_INCLUDES_ONLY_ACTIVITY\"] = \"TURN_INCLUDES_ONLY_ACTIVITY\";\n    TurnCoverage[\"TURN_INCLUDES_ALL_INPUT\"] = \"TURN_INCLUDES_ALL_INPUT\";\n})(exports.TurnCoverage || (exports.TurnCoverage = {}));\n/** A function response. */ class FunctionResponse {\n}\n/**\n * Creates a `Part` object from a `URI` string.\n */ function createPartFromUri(uri, mimeType) {\n    return {\n        fileData: {\n            fileUri: uri,\n            mimeType: mimeType\n        }\n    };\n}\n/**\n * Creates a `Part` object from a `text` string.\n */ function createPartFromText(text) {\n    return {\n        text: text\n    };\n}\n/**\n * Creates a `Part` object from a `FunctionCall` object.\n */ function createPartFromFunctionCall(name, args) {\n    return {\n        functionCall: {\n            name: name,\n            args: args\n        }\n    };\n}\n/**\n * Creates a `Part` object from a `FunctionResponse` object.\n */ function createPartFromFunctionResponse(id, name, response) {\n    return {\n        functionResponse: {\n            id: id,\n            name: name,\n            response: response\n        }\n    };\n}\n/**\n * Creates a `Part` object from a `base64` encoded `string`.\n */ function createPartFromBase64(data, mimeType) {\n    return {\n        inlineData: {\n            data: data,\n            mimeType: mimeType\n        }\n    };\n}\n/**\n * Creates a `Part` object from the `outcome` and `output` of a `CodeExecutionResult` object.\n */ function createPartFromCodeExecutionResult(outcome, output) {\n    return {\n        codeExecutionResult: {\n            outcome: outcome,\n            output: output\n        }\n    };\n}\n/**\n * Creates a `Part` object from the `code` and `language` of an `ExecutableCode` object.\n */ function createPartFromExecutableCode(code, language) {\n    return {\n        executableCode: {\n            code: code,\n            language: language\n        }\n    };\n}\nfunction _isPart(obj) {\n    if (typeof obj === \"object\" && obj !== null) {\n        return \"fileData\" in obj || \"text\" in obj || \"functionCall\" in obj || \"functionResponse\" in obj || \"inlineData\" in obj || \"videoMetadata\" in obj || \"codeExecutionResult\" in obj || \"executableCode\" in obj;\n    }\n    return false;\n}\nfunction _toParts(partOrString) {\n    const parts = [];\n    if (typeof partOrString === \"string\") {\n        parts.push(createPartFromText(partOrString));\n    } else if (_isPart(partOrString)) {\n        parts.push(partOrString);\n    } else if (Array.isArray(partOrString)) {\n        if (partOrString.length === 0) {\n            throw new Error(\"partOrString cannot be an empty array\");\n        }\n        for (const part of partOrString){\n            if (typeof part === \"string\") {\n                parts.push(createPartFromText(part));\n            } else if (_isPart(part)) {\n                parts.push(part);\n            } else {\n                throw new Error(\"element in PartUnion must be a Part object or string\");\n            }\n        }\n    } else {\n        throw new Error(\"partOrString must be a Part object, string, or array\");\n    }\n    return parts;\n}\n/**\n * Creates a `Content` object with a user role from a `PartListUnion` object or `string`.\n */ function createUserContent(partOrString) {\n    return {\n        role: \"user\",\n        parts: _toParts(partOrString)\n    };\n}\n/**\n * Creates a `Content` object with a model role from a `PartListUnion` object or `string`.\n */ function createModelContent(partOrString) {\n    return {\n        role: \"model\",\n        parts: _toParts(partOrString)\n    };\n}\n/** Content filter results for a prompt sent in the request. */ class GenerateContentResponsePromptFeedback {\n}\n/** Usage metadata about response(s). */ class GenerateContentResponseUsageMetadata {\n}\n/** Response message for PredictionService.GenerateContent. */ class GenerateContentResponse {\n    /**\n     * Returns the concatenation of all text parts from the first candidate in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the text from the first\n     * one will be returned.\n     * If there are non-text parts in the response, the concatenation of all text\n     * parts will be returned, and a warning will be logged.\n     * If there are thought parts in the response, the concatenation of all text\n     * parts excluding the thought parts will be returned.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.generateContent({\n     *   model: 'gemini-2.0-flash',\n     *   contents:\n     *     'Why is the sky blue?',\n     * });\n     *\n     * console.debug(response.text);\n     * ```\n     */ get text() {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn(\"there are multiple candidates in the response, returning text from the first one.\");\n        }\n        let text = \"\";\n        let anyTextPartText = false;\n        const nonTextParts = [];\n        for (const part of (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) !== null && _h !== void 0 ? _h : []){\n            for (const [fieldName, fieldValue] of Object.entries(part)){\n                if (fieldName !== \"text\" && fieldName !== \"thought\" && (fieldValue !== null || fieldValue !== undefined)) {\n                    nonTextParts.push(fieldName);\n                }\n            }\n            if (typeof part.text === \"string\") {\n                if (typeof part.thought === \"boolean\" && part.thought) {\n                    continue;\n                }\n                anyTextPartText = true;\n                text += part.text;\n            }\n        }\n        if (nonTextParts.length > 0) {\n            console.warn(`there are non-text parts ${nonTextParts} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`);\n        }\n        // part.text === '' is different from part.text is null\n        return anyTextPartText ? text : undefined;\n    }\n    /**\n     * Returns the concatenation of all inline data parts from the first candidate\n     * in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the inline data from the\n     * first one will be returned. If there are non-inline data parts in the\n     * response, the concatenation of all inline data parts will be returned, and\n     * a warning will be logged.\n     */ get data() {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn(\"there are multiple candidates in the response, returning data from the first one.\");\n        }\n        let data = \"\";\n        const nonDataParts = [];\n        for (const part of (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) !== null && _h !== void 0 ? _h : []){\n            for (const [fieldName, fieldValue] of Object.entries(part)){\n                if (fieldName !== \"inlineData\" && (fieldValue !== null || fieldValue !== undefined)) {\n                    nonDataParts.push(fieldName);\n                }\n            }\n            if (part.inlineData && typeof part.inlineData.data === \"string\") {\n                data += atob(part.inlineData.data);\n            }\n        }\n        if (nonDataParts.length > 0) {\n            console.warn(`there are non-data parts ${nonDataParts} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`);\n        }\n        return data.length > 0 ? btoa(data) : undefined;\n    }\n    /**\n     * Returns the function calls from the first candidate in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the function calls from\n     * the first one will be returned.\n     * If there are no function calls in the response, undefined will be returned.\n     *\n     * @example\n     * ```ts\n     * const controlLightFunctionDeclaration: FunctionDeclaration = {\n     *   name: 'controlLight',\n     *   parameters: {\n     *   type: Type.OBJECT,\n     *   description: 'Set the brightness and color temperature of a room light.',\n     *   properties: {\n     *     brightness: {\n     *       type: Type.NUMBER,\n     *       description:\n     *         'Light level from 0 to 100. Zero is off and 100 is full brightness.',\n     *     },\n     *     colorTemperature: {\n     *       type: Type.STRING,\n     *       description:\n     *         'Color temperature of the light fixture which can be `daylight`, `cool` or `warm`.',\n     *     },\n     *   },\n     *   required: ['brightness', 'colorTemperature'],\n     *  };\n     *  const response = await ai.models.generateContent({\n     *     model: 'gemini-2.0-flash',\n     *     contents: 'Dim the lights so the room feels cozy and warm.',\n     *     config: {\n     *       tools: [{functionDeclarations: [controlLightFunctionDeclaration]}],\n     *       toolConfig: {\n     *         functionCallingConfig: {\n     *           mode: FunctionCallingConfigMode.ANY,\n     *           allowedFunctionNames: ['controlLight'],\n     *         },\n     *       },\n     *     },\n     *   });\n     *  console.debug(JSON.stringify(response.functionCalls));\n     * ```\n     */ get functionCalls() {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn(\"there are multiple candidates in the response, returning function calls from the first one.\");\n        }\n        const functionCalls = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part)=>part.functionCall).map((part)=>part.functionCall).filter((functionCall)=>functionCall !== undefined);\n        if ((functionCalls === null || functionCalls === void 0 ? void 0 : functionCalls.length) === 0) {\n            return undefined;\n        }\n        return functionCalls;\n    }\n    /**\n     * Returns the first executable code from the first candidate in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the executable code from\n     * the first one will be returned.\n     * If there are no executable code in the response, undefined will be\n     * returned.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.generateContent({\n     *   model: 'gemini-2.0-flash',\n     *   contents:\n     *     'What is the sum of the first 50 prime numbers? Generate and run code for the calculation, and make sure you get all 50.'\n     *   config: {\n     *     tools: [{codeExecution: {}}],\n     *   },\n     * });\n     *\n     * console.debug(response.executableCode);\n     * ```\n     */ get executableCode() {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn(\"there are multiple candidates in the response, returning executable code from the first one.\");\n        }\n        const executableCode = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part)=>part.executableCode).map((part)=>part.executableCode).filter((executableCode)=>executableCode !== undefined);\n        if ((executableCode === null || executableCode === void 0 ? void 0 : executableCode.length) === 0) {\n            return undefined;\n        }\n        return (_j = executableCode === null || executableCode === void 0 ? void 0 : executableCode[0]) === null || _j === void 0 ? void 0 : _j.code;\n    }\n    /**\n     * Returns the first code execution result from the first candidate in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the code execution result from\n     * the first one will be returned.\n     * If there are no code execution result in the response, undefined will be returned.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.generateContent({\n     *   model: 'gemini-2.0-flash',\n     *   contents:\n     *     'What is the sum of the first 50 prime numbers? Generate and run code for the calculation, and make sure you get all 50.'\n     *   config: {\n     *     tools: [{codeExecution: {}}],\n     *   },\n     * });\n     *\n     * console.debug(response.codeExecutionResult);\n     * ```\n     */ get codeExecutionResult() {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn(\"there are multiple candidates in the response, returning code execution result from the first one.\");\n        }\n        const codeExecutionResult = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part)=>part.codeExecutionResult).map((part)=>part.codeExecutionResult).filter((codeExecutionResult)=>codeExecutionResult !== undefined);\n        if ((codeExecutionResult === null || codeExecutionResult === void 0 ? void 0 : codeExecutionResult.length) === 0) {\n            return undefined;\n        }\n        return (_j = codeExecutionResult === null || codeExecutionResult === void 0 ? void 0 : codeExecutionResult[0]) === null || _j === void 0 ? void 0 : _j.output;\n    }\n}\n/** Response for the embed_content method. */ class EmbedContentResponse {\n}\n/** The output images response. */ class GenerateImagesResponse {\n}\n/** Response for counting tokens. */ class CountTokensResponse {\n}\n/** Response for computing tokens. */ class ComputeTokensResponse {\n}\n/** Response with generated videos. */ class GenerateVideosResponse {\n}\n/** Empty response for caches.delete method. */ class DeleteCachedContentResponse {\n}\nclass ListCachedContentsResponse {\n}\n/** Response for the list files method. */ class ListFilesResponse {\n}\n/** A wrapper class for the http response. */ class HttpResponse {\n    constructor(response){\n        // Process the headers.\n        const headers = {};\n        for (const pair of response.headers.entries()){\n            headers[pair[0]] = pair[1];\n        }\n        this.headers = headers;\n        // Keep the original response.\n        this.responseInternal = response;\n    }\n    json() {\n        return this.responseInternal.json();\n    }\n}\n/** Response for the create file method. */ class CreateFileResponse {\n}\n/** Response for the delete file method. */ class DeleteFileResponse {\n}\n/** Represents a single response in a replay. */ class ReplayResponse {\n}\n/** Client generated response to a `ToolCall` received from the server.\n\n  Individual `FunctionResponse` objects are matched to the respective\n  `FunctionCall` objects by the `id` field.\n\n  Note that in the unary and server-streaming GenerateContent APIs function\n  calling happens by exchanging the `Content` parts, while in the bidi\n  GenerateContent APIs function calling happens over this dedicated set of\n  messages.\n   */ class LiveClientToolResponse {\n}\n/** Parameters for sending tool responses to the live API. */ class LiveSendToolResponseParameters {\n    constructor(){\n        /** Tool responses to send to the session. */ this.functionResponses = [];\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class Caches extends BaseModule {\n    constructor(apiClient){\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Lists cached content configurations.\n         *\n         * @param params - The parameters for the list request.\n         * @return The paginated results of the list of cached contents.\n         *\n         * @example\n         * ```ts\n         * const cachedContents = await ai.caches.list({config: {'pageSize': 2}});\n         * for (const cachedContent of cachedContents) {\n         *   console.log(cachedContent);\n         * }\n         * ```\n         */ this.list = async (params = {})=>{\n            return new Pager(exports.PagedItem.PAGED_ITEM_CACHED_CONTENTS, (x)=>this.listInternal(x), await this.listInternal(params), params);\n        };\n    }\n    /**\n     * Creates a cached contents resource.\n     *\n     * @remarks\n     * Context caching is only supported for specific models. See [Gemini\n     * Developer API reference](https://ai.google.dev/gemini-api/docs/caching?lang=node/context-cac)\n     * and [Vertex AI reference](https://cloud.google.com/vertex-ai/generative-ai/docs/context-cache/context-cache-overview#supported_models)\n     * for more information.\n     *\n     * @param params - The parameters for the create request.\n     * @return The created cached content.\n     *\n     * @example\n     * ```ts\n     * const contents = ...; // Initialize the content to cache.\n     * const response = await ai.caches.create({\n     *   model: 'gemini-1.5-flash',\n     *   config: {\n     *    'contents': contents,\n     *    'displayName': 'test cache',\n     *    'systemInstruction': 'What is the sum of the two pdfs?',\n     *    'ttl': '86400s',\n     *  }\n     * });\n     * ```\n     */ async create(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = createCachedContentParametersToVertex(this.apiClient, params);\n            path = formatMap(\"cachedContents\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = cachedContentFromVertex(this.apiClient, apiResponse);\n                return resp;\n            });\n        } else {\n            const body = createCachedContentParametersToMldev(this.apiClient, params);\n            path = formatMap(\"cachedContents\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = cachedContentFromMldev(this.apiClient, apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Gets cached content configurations.\n     *\n     * @param params - The parameters for the get request.\n     * @return The cached content.\n     *\n     * @example\n     * ```ts\n     * await ai.caches.get({name: 'gemini-1.5-flash'});\n     * ```\n     */ async get(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getCachedContentParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = cachedContentFromVertex(this.apiClient, apiResponse);\n                return resp;\n            });\n        } else {\n            const body = getCachedContentParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = cachedContentFromMldev(this.apiClient, apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Deletes cached content.\n     *\n     * @param params - The parameters for the delete request.\n     * @return The empty response returned by the API.\n     *\n     * @example\n     * ```ts\n     * await ai.caches.delete({name: 'gemini-1.5-flash'});\n     * ```\n     */ async delete(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = deleteCachedContentParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"DELETE\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then(()=>{\n                const resp = deleteCachedContentResponseFromVertex();\n                const typedResp = new DeleteCachedContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = deleteCachedContentParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"DELETE\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then(()=>{\n                const resp = deleteCachedContentResponseFromMldev();\n                const typedResp = new DeleteCachedContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Updates cached content configurations.\n     *\n     * @param params - The parameters for the update request.\n     * @return The updated cached content.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.caches.update({\n     *   name: 'gemini-1.5-flash',\n     *   config: {'ttl': '7600s'}\n     * });\n     * ```\n     */ async update(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = updateCachedContentParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"PATCH\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = cachedContentFromVertex(this.apiClient, apiResponse);\n                return resp;\n            });\n        } else {\n            const body = updateCachedContentParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"PATCH\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = cachedContentFromMldev(this.apiClient, apiResponse);\n                return resp;\n            });\n        }\n    }\n    async listInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = listCachedContentsParametersToVertex(this.apiClient, params);\n            path = formatMap(\"cachedContents\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = listCachedContentsResponseFromVertex(this.apiClient, apiResponse);\n                const typedResp = new ListCachedContentsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = listCachedContentsParametersToMldev(this.apiClient, params);\n            path = formatMap(\"cachedContents\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = listCachedContentsResponseFromMldev(this.apiClient, apiResponse);\n                const typedResp = new ListCachedContentsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n}\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol, Iterator */ function __values(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function() {\n            if (o && i >= o.length) o = void 0;\n            return {\n                value: o && o[i++],\n                done: !o\n            };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction __await(v) {\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\nfunction __asyncGenerator(thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i;\n    function awaitReturn(f) {\n        return function(v) {\n            return Promise.resolve(v).then(f, reject);\n        };\n    }\n    function verb(n, f) {\n        if (g[n]) {\n            i[n] = function(v) {\n                return new Promise(function(a, b) {\n                    q.push([\n                        n,\n                        v,\n                        a,\n                        b\n                    ]) > 1 || resume(n, v);\n                });\n            };\n            if (f) i[n] = f(i[n]);\n        }\n    }\n    function resume(n, v) {\n        try {\n            step(g[n](v));\n        } catch (e) {\n            settle(q[0][3], e);\n        }\n    }\n    function step(r) {\n        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n    }\n    function fulfill(value) {\n        resume(\"next\", value);\n    }\n    function reject(value) {\n        resume(\"throw\", value);\n    }\n    function settle(f, v) {\n        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);\n    }\n}\nfunction __asyncValues(o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i);\n    function verb(n) {\n        i[n] = o[n] && function(v) {\n            return new Promise(function(resolve, reject) {\n                v = o[n](v), settle(resolve, reject, v.done, v.value);\n            });\n        };\n    }\n    function settle(resolve, reject, d, v) {\n        Promise.resolve(v).then(function(v) {\n            resolve({\n                value: v,\n                done: d\n            });\n        }, reject);\n    }\n}\ntypeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ /**\n * Returns true if the response is valid, false otherwise.\n */ function isValidResponse(response) {\n    var _a;\n    if (response.candidates == undefined || response.candidates.length === 0) {\n        return false;\n    }\n    const content = (_a = response.candidates[0]) === null || _a === void 0 ? void 0 : _a.content;\n    if (content === undefined) {\n        return false;\n    }\n    return isValidContent(content);\n}\nfunction isValidContent(content) {\n    if (content.parts === undefined || content.parts.length === 0) {\n        return false;\n    }\n    for (const part of content.parts){\n        if (part === undefined || Object.keys(part).length === 0) {\n            return false;\n        }\n        if (part.text !== undefined && part.text === \"\") {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Validates the history contains the correct roles.\n *\n * @remarks\n * Expects the history to start with a user turn and then alternate between\n * user and model turns.\n *\n * @throws Error if the history does not start with a user turn.\n * @throws Error if the history contains an invalid role.\n */ function validateHistory(history) {\n    // Empty history is valid.\n    if (history.length === 0) {\n        return;\n    }\n    if (history[0].role !== \"user\") {\n        throw new Error(\"History must start with a user turn.\");\n    }\n    for (const content of history){\n        if (content.role !== \"user\" && content.role !== \"model\") {\n            throw new Error(`Role must be user or model, but got ${content.role}.`);\n        }\n    }\n}\n/**\n * Extracts the curated (valid) history from a comprehensive history.\n *\n * @remarks\n * The model may sometimes generate invalid or empty contents(e.g., due to safty\n * filters or recitation). Extracting valid turns from the history\n * ensures that subsequent requests could be accpeted by the model.\n */ function extractCuratedHistory(comprehensiveHistory) {\n    if (comprehensiveHistory === undefined || comprehensiveHistory.length === 0) {\n        return [];\n    }\n    const curatedHistory = [];\n    const length = comprehensiveHistory.length;\n    let i = 0;\n    let userInput = comprehensiveHistory[0];\n    while(i < length){\n        if (comprehensiveHistory[i].role === \"user\") {\n            userInput = comprehensiveHistory[i];\n            i++;\n        } else {\n            const modelOutput = [];\n            let isValid = true;\n            while(i < length && comprehensiveHistory[i].role === \"model\"){\n                modelOutput.push(comprehensiveHistory[i]);\n                if (isValid && !isValidContent(comprehensiveHistory[i])) {\n                    isValid = false;\n                }\n                i++;\n            }\n            if (isValid) {\n                curatedHistory.push(userInput);\n                curatedHistory.push(...modelOutput);\n            }\n        }\n    }\n    return curatedHistory;\n}\n/**\n * A utility class to create a chat session.\n */ class Chats {\n    constructor(modelsModule, apiClient){\n        this.modelsModule = modelsModule;\n        this.apiClient = apiClient;\n    }\n    /**\n     * Creates a new chat session.\n     *\n     * @remarks\n     * The config in the params will be used for all requests within the chat\n     * session unless overridden by a per-request `config` in\n     * @see {@link types.SendMessageParameters#config}.\n     *\n     * @param params - Parameters for creating a chat session.\n     * @returns A new chat session.\n     *\n     * @example\n     * ```ts\n     * const chat = ai.chats.create({\n     *   model: 'gemini-2.0-flash'\n     *   config: {\n     *     temperature: 0.5,\n     *     maxOutputTokens: 1024,\n     *   }\n     * });\n     * ```\n     */ create(params) {\n        return new Chat(this.apiClient, this.modelsModule, params.model, params.config, params.history);\n    }\n}\n/**\n * Chat session that enables sending messages to the model with previous\n * conversation context.\n *\n * @remarks\n * The session maintains all the turns between user and model.\n */ class Chat {\n    constructor(apiClient, modelsModule, model, config = {}, history = []){\n        this.apiClient = apiClient;\n        this.modelsModule = modelsModule;\n        this.model = model;\n        this.config = config;\n        this.history = history;\n        // A promise to represent the current state of the message being sent to the\n        // model.\n        this.sendPromise = Promise.resolve();\n        validateHistory(history);\n    }\n    /**\n     * Sends a message to the model and returns the response.\n     *\n     * @remarks\n     * This method will wait for the previous message to be processed before\n     * sending the next message.\n     *\n     * @see {@link Chat#sendMessageStream} for streaming method.\n     * @param params - parameters for sending messages within a chat session.\n     * @returns The model's response.\n     *\n     * @example\n     * ```ts\n     * const chat = ai.chats.create({model: 'gemini-2.0-flash'});\n     * const response = await chat.sendMessage({\n     *   message: 'Why is the sky blue?'\n     * });\n     * console.log(response.text);\n     * ```\n     */ async sendMessage(params) {\n        var _a;\n        await this.sendPromise;\n        const inputContent = tContent(this.apiClient, params.message);\n        const responsePromise = this.modelsModule.generateContent({\n            model: this.model,\n            contents: this.getHistory(true).concat(inputContent),\n            config: (_a = params.config) !== null && _a !== void 0 ? _a : this.config\n        });\n        this.sendPromise = (async ()=>{\n            var _a, _b;\n            const response = await responsePromise;\n            const outputContent = (_b = (_a = response.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content;\n            const modelOutput = outputContent ? [\n                outputContent\n            ] : [];\n            this.recordHistory(inputContent, modelOutput);\n            return;\n        })();\n        await this.sendPromise;\n        return responsePromise;\n    }\n    /**\n     * Sends a message to the model and returns the response in chunks.\n     *\n     * @remarks\n     * This method will wait for the previous message to be processed before\n     * sending the next message.\n     *\n     * @see {@link Chat#sendMessage} for non-streaming method.\n     * @param params - parameters for sending the message.\n     * @return The model's response.\n     *\n     * @example\n     * ```ts\n     * const chat = ai.chats.create({model: 'gemini-2.0-flash'});\n     * const response = await chat.sendMessageStream({\n     *   message: 'Why is the sky blue?'\n     * });\n     * for await (const chunk of response) {\n     *   console.log(chunk.text);\n     * }\n     * ```\n     */ async sendMessageStream(params) {\n        var _a;\n        await this.sendPromise;\n        const inputContent = tContent(this.apiClient, params.message);\n        const streamResponse = this.modelsModule.generateContentStream({\n            model: this.model,\n            contents: this.getHistory(true).concat(inputContent),\n            config: (_a = params.config) !== null && _a !== void 0 ? _a : this.config\n        });\n        this.sendPromise = streamResponse.then(()=>undefined);\n        const response = await streamResponse;\n        const result = this.processStreamResponse(response, inputContent);\n        return result;\n    }\n    /**\n     * Returns the chat history.\n     *\n     * @remarks\n     * The history is a list of contents alternating between user and model.\n     *\n     * There are two types of history:\n     * - The `curated history` contains only the valid turns between user and\n     * model, which will be included in the subsequent requests sent to the model.\n     * - The `comprehensive history` contains all turns, including invalid or\n     *   empty model outputs, providing a complete record of the history.\n     *\n     * The history is updated after receiving the response from the model,\n     * for streaming response, it means receiving the last chunk of the response.\n     *\n     * The `comprehensive history` is returned by default. To get the `curated\n     * history`, set the `curated` parameter to `true`.\n     *\n     * @param curated - whether to return the curated history or the comprehensive\n     *     history.\n     * @return History contents alternating between user and model for the entire\n     *     chat session.\n     */ getHistory(curated = false) {\n        return curated ? extractCuratedHistory(this.history) : this.history;\n    }\n    processStreamResponse(streamResponse, inputContent) {\n        var _a, _b;\n        return __asyncGenerator(this, arguments, function* processStreamResponse_1() {\n            var _c, e_1, _d, _e;\n            const outputContent = [];\n            try {\n                for(var _f = true, streamResponse_1 = __asyncValues(streamResponse), streamResponse_1_1; streamResponse_1_1 = yield __await(streamResponse_1.next()), _c = streamResponse_1_1.done, !_c; _f = true){\n                    _e = streamResponse_1_1.value;\n                    _f = false;\n                    const chunk = _e;\n                    if (isValidResponse(chunk)) {\n                        const content = (_b = (_a = chunk.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content;\n                        if (content !== undefined) {\n                            outputContent.push(content);\n                        }\n                    }\n                    yield yield __await(chunk);\n                }\n            } catch (e_1_1) {\n                e_1 = {\n                    error: e_1_1\n                };\n            } finally{\n                try {\n                    if (!_f && !_c && (_d = streamResponse_1.return)) yield __await(_d.call(streamResponse_1));\n                } finally{\n                    if (e_1) throw e_1.error;\n                }\n            }\n            this.recordHistory(inputContent, outputContent);\n        });\n    }\n    recordHistory(userInput, modelOutput) {\n        let outputContents = [];\n        if (modelOutput.length > 0 && modelOutput.every((content)=>content.role === \"model\")) {\n            outputContents = modelOutput;\n        } else {\n            // Appends an empty content when model returns empty response, so that the\n            // history is always alternating between user and model.\n            outputContents.push({\n                role: \"model\",\n                parts: []\n            });\n        }\n        this.history.push(userInput);\n        this.history.push(...outputContents);\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ function listFilesConfigToMldev(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    return toObject;\n}\nfunction listFilesParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], listFilesConfigToMldev(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction fileStatusToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromDetails = getValueByPath(fromObject, [\n        \"details\"\n    ]);\n    if (fromDetails != null) {\n        setValueByPath(toObject, [\n            \"details\"\n        ], fromDetails);\n    }\n    const fromMessage = getValueByPath(fromObject, [\n        \"message\"\n    ]);\n    if (fromMessage != null) {\n        setValueByPath(toObject, [\n            \"message\"\n        ], fromMessage);\n    }\n    const fromCode = getValueByPath(fromObject, [\n        \"code\"\n    ]);\n    if (fromCode != null) {\n        setValueByPath(toObject, [\n            \"code\"\n        ], fromCode);\n    }\n    return toObject;\n}\nfunction fileToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    const fromSizeBytes = getValueByPath(fromObject, [\n        \"sizeBytes\"\n    ]);\n    if (fromSizeBytes != null) {\n        setValueByPath(toObject, [\n            \"sizeBytes\"\n        ], fromSizeBytes);\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromExpirationTime = getValueByPath(fromObject, [\n        \"expirationTime\"\n    ]);\n    if (fromExpirationTime != null) {\n        setValueByPath(toObject, [\n            \"expirationTime\"\n        ], fromExpirationTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    const fromSha256Hash = getValueByPath(fromObject, [\n        \"sha256Hash\"\n    ]);\n    if (fromSha256Hash != null) {\n        setValueByPath(toObject, [\n            \"sha256Hash\"\n        ], fromSha256Hash);\n    }\n    const fromUri = getValueByPath(fromObject, [\n        \"uri\"\n    ]);\n    if (fromUri != null) {\n        setValueByPath(toObject, [\n            \"uri\"\n        ], fromUri);\n    }\n    const fromDownloadUri = getValueByPath(fromObject, [\n        \"downloadUri\"\n    ]);\n    if (fromDownloadUri != null) {\n        setValueByPath(toObject, [\n            \"downloadUri\"\n        ], fromDownloadUri);\n    }\n    const fromState = getValueByPath(fromObject, [\n        \"state\"\n    ]);\n    if (fromState != null) {\n        setValueByPath(toObject, [\n            \"state\"\n        ], fromState);\n    }\n    const fromSource = getValueByPath(fromObject, [\n        \"source\"\n    ]);\n    if (fromSource != null) {\n        setValueByPath(toObject, [\n            \"source\"\n        ], fromSource);\n    }\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], fromVideoMetadata);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fileStatusToMldev(apiClient, fromError));\n    }\n    return toObject;\n}\nfunction createFileParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromFile = getValueByPath(fromObject, [\n        \"file\"\n    ]);\n    if (fromFile != null) {\n        setValueByPath(toObject, [\n            \"file\"\n        ], fileToMldev(apiClient, fromFile));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction getFileParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"file\"\n        ], tFileName(apiClient, fromName));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction deleteFileParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"file\"\n        ], tFileName(apiClient, fromName));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction fileStatusFromMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromDetails = getValueByPath(fromObject, [\n        \"details\"\n    ]);\n    if (fromDetails != null) {\n        setValueByPath(toObject, [\n            \"details\"\n        ], fromDetails);\n    }\n    const fromMessage = getValueByPath(fromObject, [\n        \"message\"\n    ]);\n    if (fromMessage != null) {\n        setValueByPath(toObject, [\n            \"message\"\n        ], fromMessage);\n    }\n    const fromCode = getValueByPath(fromObject, [\n        \"code\"\n    ]);\n    if (fromCode != null) {\n        setValueByPath(toObject, [\n            \"code\"\n        ], fromCode);\n    }\n    return toObject;\n}\nfunction fileFromMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    const fromSizeBytes = getValueByPath(fromObject, [\n        \"sizeBytes\"\n    ]);\n    if (fromSizeBytes != null) {\n        setValueByPath(toObject, [\n            \"sizeBytes\"\n        ], fromSizeBytes);\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromExpirationTime = getValueByPath(fromObject, [\n        \"expirationTime\"\n    ]);\n    if (fromExpirationTime != null) {\n        setValueByPath(toObject, [\n            \"expirationTime\"\n        ], fromExpirationTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    const fromSha256Hash = getValueByPath(fromObject, [\n        \"sha256Hash\"\n    ]);\n    if (fromSha256Hash != null) {\n        setValueByPath(toObject, [\n            \"sha256Hash\"\n        ], fromSha256Hash);\n    }\n    const fromUri = getValueByPath(fromObject, [\n        \"uri\"\n    ]);\n    if (fromUri != null) {\n        setValueByPath(toObject, [\n            \"uri\"\n        ], fromUri);\n    }\n    const fromDownloadUri = getValueByPath(fromObject, [\n        \"downloadUri\"\n    ]);\n    if (fromDownloadUri != null) {\n        setValueByPath(toObject, [\n            \"downloadUri\"\n        ], fromDownloadUri);\n    }\n    const fromState = getValueByPath(fromObject, [\n        \"state\"\n    ]);\n    if (fromState != null) {\n        setValueByPath(toObject, [\n            \"state\"\n        ], fromState);\n    }\n    const fromSource = getValueByPath(fromObject, [\n        \"source\"\n    ]);\n    if (fromSource != null) {\n        setValueByPath(toObject, [\n            \"source\"\n        ], fromSource);\n    }\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], fromVideoMetadata);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fileStatusFromMldev(apiClient, fromError));\n    }\n    return toObject;\n}\nfunction listFilesResponseFromMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromFiles = getValueByPath(fromObject, [\n        \"files\"\n    ]);\n    if (fromFiles != null) {\n        if (Array.isArray(fromFiles)) {\n            setValueByPath(toObject, [\n                \"files\"\n            ], fromFiles.map((item)=>{\n                return fileFromMldev(apiClient, item);\n            }));\n        } else {\n            setValueByPath(toObject, [\n                \"files\"\n            ], fromFiles);\n        }\n    }\n    return toObject;\n}\nfunction createFileResponseFromMldev() {\n    const toObject = {};\n    return toObject;\n}\nfunction deleteFileResponseFromMldev() {\n    const toObject = {};\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class Files extends BaseModule {\n    constructor(apiClient){\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Lists all current project files from the service.\n         *\n         * @param params - The parameters for the list request\n         * @return The paginated results of the list of files\n         *\n         * @example\n         * The following code prints the names of all files from the service, the\n         * size of each page is 10.\n         *\n         * ```ts\n         * const listResponse = await ai.files.list({config: {'pageSize': 10}});\n         * for await (const file of listResponse) {\n         *   console.log(file.name);\n         * }\n         * ```\n         */ this.list = async (params = {})=>{\n            return new Pager(exports.PagedItem.PAGED_ITEM_FILES, (x)=>this.listInternal(x), await this.listInternal(params), params);\n        };\n    }\n    /**\n     * Uploads a file asynchronously to the Gemini API.\n     * This method is not available in Vertex AI.\n     * Supported upload sources:\n     * - Node.js: File path (string) or Blob object.\n     * - Browser: Blob object (e.g., File).\n     *\n     * @remarks\n     * The `mimeType` can be specified in the `config` parameter. If omitted:\n     *  - For file path (string) inputs, the `mimeType` will be inferred from the\n     *     file extension.\n     *  - For Blob object inputs, the `mimeType` will be set to the Blob's `type`\n     *     property.\n     * Somex eamples for file extension to mimeType mapping:\n     * .txt -> text/plain\n     * .json -> application/json\n     * .jpg  -> image/jpeg\n     * .png -> image/png\n     * .mp3 -> audio/mpeg\n     * .mp4 -> video/mp4\n     *\n     * This section can contain multiple paragraphs and code examples.\n     *\n     * @param params - Optional parameters specified in the\n     *        `types.UploadFileParameters` interface.\n     *         @see {@link types.UploadFileParameters#config} for the optional\n     *         config in the parameters.\n     * @return A promise that resolves to a `types.File` object.\n     * @throws An error if called on a Vertex AI client.\n     * @throws An error if the `mimeType` is not provided and can not be inferred,\n     * the `mimeType` can be provided in the `params.config` parameter.\n     * @throws An error occurs if a suitable upload location cannot be established.\n     *\n     * @example\n     * The following code uploads a file to Gemini API.\n     *\n     * ```ts\n     * const file = await ai.files.upload({file: 'file.txt', config: {\n     *   mimeType: 'text/plain',\n     * }});\n     * console.log(file.name);\n     * ```\n     */ async upload(params) {\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"Vertex AI does not support uploading files. You can share files through a GCS bucket.\");\n        }\n        return this.apiClient.uploadFile(params.file, params.config).then((response)=>{\n            const file = fileFromMldev(this.apiClient, response);\n            return file;\n        });\n    }\n    async listInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = listFilesParametersToMldev(this.apiClient, params);\n            path = formatMap(\"files\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = listFilesResponseFromMldev(this.apiClient, apiResponse);\n                const typedResp = new ListFilesResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    async createInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = createFileParametersToMldev(this.apiClient, params);\n            path = formatMap(\"upload/v1beta/files\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then(()=>{\n                const resp = createFileResponseFromMldev();\n                const typedResp = new CreateFileResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Retrieves the file information from the service.\n     *\n     * @param params - The parameters for the get request\n     * @return The Promise that resolves to the types.File object requested.\n     *\n     * @example\n     * ```ts\n     * const config: GetFileParameters = {\n     *   name: fileName,\n     * };\n     * file = await ai.files.get(config);\n     * console.log(file.name);\n     * ```\n     */ async get(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = getFileParametersToMldev(this.apiClient, params);\n            path = formatMap(\"files/{file}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = fileFromMldev(this.apiClient, apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Deletes a remotely stored file.\n     *\n     * @param params - The parameters for the delete request.\n     * @return The DeleteFileResponse, the response for the delete method.\n     *\n     * @example\n     * The following code deletes an example file named \"files/mehozpxf877d\".\n     *\n     * ```ts\n     * await ai.files.delete({name: file.name});\n     * ```\n     */ async delete(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = deleteFileParametersToMldev(this.apiClient, params);\n            path = formatMap(\"files/{file}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"DELETE\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then(()=>{\n                const resp = deleteFileResponseFromMldev();\n                const typedResp = new DeleteFileResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ function partToMldev$1(apiClient, fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]) !== undefined) {\n        throw new Error(\"videoMetadata parameter is not supported in Gemini API.\");\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fromFileData);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], fromFunctionCall);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], fromInlineData);\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    return toObject;\n}\nfunction partToVertex$1(apiClient, fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], fromVideoMetadata);\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fromFileData);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], fromFunctionCall);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], fromInlineData);\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    return toObject;\n}\nfunction contentToMldev$1(apiClient, fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        if (Array.isArray(fromParts)) {\n            setValueByPath(toObject, [\n                \"parts\"\n            ], fromParts.map((item)=>{\n                return partToMldev$1(apiClient, item);\n            }));\n        } else {\n            setValueByPath(toObject, [\n                \"parts\"\n            ], fromParts);\n        }\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction contentToVertex$1(apiClient, fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        if (Array.isArray(fromParts)) {\n            setValueByPath(toObject, [\n                \"parts\"\n            ], fromParts.map((item)=>{\n                return partToVertex$1(apiClient, item);\n            }));\n        } else {\n            setValueByPath(toObject, [\n                \"parts\"\n            ], fromParts);\n        }\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction schemaToVertex$1(apiClient, fromObject) {\n    const toObject = {};\n    const fromExample = getValueByPath(fromObject, [\n        \"example\"\n    ]);\n    if (fromExample != null) {\n        setValueByPath(toObject, [\n            \"example\"\n        ], fromExample);\n    }\n    const fromPattern = getValueByPath(fromObject, [\n        \"pattern\"\n    ]);\n    if (fromPattern != null) {\n        setValueByPath(toObject, [\n            \"pattern\"\n        ], fromPattern);\n    }\n    const fromDefault = getValueByPath(fromObject, [\n        \"default\"\n    ]);\n    if (fromDefault != null) {\n        setValueByPath(toObject, [\n            \"default\"\n        ], fromDefault);\n    }\n    const fromMaxLength = getValueByPath(fromObject, [\n        \"maxLength\"\n    ]);\n    if (fromMaxLength != null) {\n        setValueByPath(toObject, [\n            \"maxLength\"\n        ], fromMaxLength);\n    }\n    const fromMinLength = getValueByPath(fromObject, [\n        \"minLength\"\n    ]);\n    if (fromMinLength != null) {\n        setValueByPath(toObject, [\n            \"minLength\"\n        ], fromMinLength);\n    }\n    const fromMinProperties = getValueByPath(fromObject, [\n        \"minProperties\"\n    ]);\n    if (fromMinProperties != null) {\n        setValueByPath(toObject, [\n            \"minProperties\"\n        ], fromMinProperties);\n    }\n    const fromMaxProperties = getValueByPath(fromObject, [\n        \"maxProperties\"\n    ]);\n    if (fromMaxProperties != null) {\n        setValueByPath(toObject, [\n            \"maxProperties\"\n        ], fromMaxProperties);\n    }\n    const fromAnyOf = getValueByPath(fromObject, [\n        \"anyOf\"\n    ]);\n    if (fromAnyOf != null) {\n        setValueByPath(toObject, [\n            \"anyOf\"\n        ], fromAnyOf);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromEnum = getValueByPath(fromObject, [\n        \"enum\"\n    ]);\n    if (fromEnum != null) {\n        setValueByPath(toObject, [\n            \"enum\"\n        ], fromEnum);\n    }\n    const fromFormat = getValueByPath(fromObject, [\n        \"format\"\n    ]);\n    if (fromFormat != null) {\n        setValueByPath(toObject, [\n            \"format\"\n        ], fromFormat);\n    }\n    const fromItems = getValueByPath(fromObject, [\n        \"items\"\n    ]);\n    if (fromItems != null) {\n        setValueByPath(toObject, [\n            \"items\"\n        ], fromItems);\n    }\n    const fromMaxItems = getValueByPath(fromObject, [\n        \"maxItems\"\n    ]);\n    if (fromMaxItems != null) {\n        setValueByPath(toObject, [\n            \"maxItems\"\n        ], fromMaxItems);\n    }\n    const fromMaximum = getValueByPath(fromObject, [\n        \"maximum\"\n    ]);\n    if (fromMaximum != null) {\n        setValueByPath(toObject, [\n            \"maximum\"\n        ], fromMaximum);\n    }\n    const fromMinItems = getValueByPath(fromObject, [\n        \"minItems\"\n    ]);\n    if (fromMinItems != null) {\n        setValueByPath(toObject, [\n            \"minItems\"\n        ], fromMinItems);\n    }\n    const fromMinimum = getValueByPath(fromObject, [\n        \"minimum\"\n    ]);\n    if (fromMinimum != null) {\n        setValueByPath(toObject, [\n            \"minimum\"\n        ], fromMinimum);\n    }\n    const fromNullable = getValueByPath(fromObject, [\n        \"nullable\"\n    ]);\n    if (fromNullable != null) {\n        setValueByPath(toObject, [\n            \"nullable\"\n        ], fromNullable);\n    }\n    const fromProperties = getValueByPath(fromObject, [\n        \"properties\"\n    ]);\n    if (fromProperties != null) {\n        setValueByPath(toObject, [\n            \"properties\"\n        ], fromProperties);\n    }\n    const fromPropertyOrdering = getValueByPath(fromObject, [\n        \"propertyOrdering\"\n    ]);\n    if (fromPropertyOrdering != null) {\n        setValueByPath(toObject, [\n            \"propertyOrdering\"\n        ], fromPropertyOrdering);\n    }\n    const fromRequired = getValueByPath(fromObject, [\n        \"required\"\n    ]);\n    if (fromRequired != null) {\n        setValueByPath(toObject, [\n            \"required\"\n        ], fromRequired);\n    }\n    const fromTitle = getValueByPath(fromObject, [\n        \"title\"\n    ]);\n    if (fromTitle != null) {\n        setValueByPath(toObject, [\n            \"title\"\n        ], fromTitle);\n    }\n    const fromType = getValueByPath(fromObject, [\n        \"type\"\n    ]);\n    if (fromType != null) {\n        setValueByPath(toObject, [\n            \"type\"\n        ], fromType);\n    }\n    return toObject;\n}\nfunction functionDeclarationToMldev$1(apiClient, fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"response\"\n    ]) !== undefined) {\n        throw new Error(\"response parameter is not supported in Gemini API.\");\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, [\n        \"parameters\"\n    ]);\n    if (fromParameters != null) {\n        setValueByPath(toObject, [\n            \"parameters\"\n        ], fromParameters);\n    }\n    return toObject;\n}\nfunction functionDeclarationToVertex$1(apiClient, fromObject) {\n    const toObject = {};\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], schemaToVertex$1(apiClient, fromResponse));\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, [\n        \"parameters\"\n    ]);\n    if (fromParameters != null) {\n        setValueByPath(toObject, [\n            \"parameters\"\n        ], fromParameters);\n    }\n    return toObject;\n}\nfunction googleSearchToMldev$1() {\n    const toObject = {};\n    return toObject;\n}\nfunction googleSearchToVertex$1() {\n    const toObject = {};\n    return toObject;\n}\nfunction dynamicRetrievalConfigToMldev$1(apiClient, fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromDynamicThreshold = getValueByPath(fromObject, [\n        \"dynamicThreshold\"\n    ]);\n    if (fromDynamicThreshold != null) {\n        setValueByPath(toObject, [\n            \"dynamicThreshold\"\n        ], fromDynamicThreshold);\n    }\n    return toObject;\n}\nfunction dynamicRetrievalConfigToVertex$1(apiClient, fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromDynamicThreshold = getValueByPath(fromObject, [\n        \"dynamicThreshold\"\n    ]);\n    if (fromDynamicThreshold != null) {\n        setValueByPath(toObject, [\n            \"dynamicThreshold\"\n        ], fromDynamicThreshold);\n    }\n    return toObject;\n}\nfunction googleSearchRetrievalToMldev$1(apiClient, fromObject) {\n    const toObject = {};\n    const fromDynamicRetrievalConfig = getValueByPath(fromObject, [\n        \"dynamicRetrievalConfig\"\n    ]);\n    if (fromDynamicRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"dynamicRetrievalConfig\"\n        ], dynamicRetrievalConfigToMldev$1(apiClient, fromDynamicRetrievalConfig));\n    }\n    return toObject;\n}\nfunction googleSearchRetrievalToVertex$1(apiClient, fromObject) {\n    const toObject = {};\n    const fromDynamicRetrievalConfig = getValueByPath(fromObject, [\n        \"dynamicRetrievalConfig\"\n    ]);\n    if (fromDynamicRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"dynamicRetrievalConfig\"\n        ], dynamicRetrievalConfigToVertex$1(apiClient, fromDynamicRetrievalConfig));\n    }\n    return toObject;\n}\nfunction toolToMldev$1(apiClient, fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        if (Array.isArray(fromFunctionDeclarations)) {\n            setValueByPath(toObject, [\n                \"functionDeclarations\"\n            ], fromFunctionDeclarations.map((item)=>{\n                return functionDeclarationToMldev$1(apiClient, item);\n            }));\n        } else {\n            setValueByPath(toObject, [\n                \"functionDeclarations\"\n            ], fromFunctionDeclarations);\n        }\n    }\n    if (getValueByPath(fromObject, [\n        \"retrieval\"\n    ]) !== undefined) {\n        throw new Error(\"retrieval parameter is not supported in Gemini API.\");\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], googleSearchToMldev$1());\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], googleSearchRetrievalToMldev$1(apiClient, fromGoogleSearchRetrieval));\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    return toObject;\n}\nfunction toolToVertex$1(apiClient, fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        if (Array.isArray(fromFunctionDeclarations)) {\n            setValueByPath(toObject, [\n                \"functionDeclarations\"\n            ], fromFunctionDeclarations.map((item)=>{\n                return functionDeclarationToVertex$1(apiClient, item);\n            }));\n        } else {\n            setValueByPath(toObject, [\n                \"functionDeclarations\"\n            ], fromFunctionDeclarations);\n        }\n    }\n    const fromRetrieval = getValueByPath(fromObject, [\n        \"retrieval\"\n    ]);\n    if (fromRetrieval != null) {\n        setValueByPath(toObject, [\n            \"retrieval\"\n        ], fromRetrieval);\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], googleSearchToVertex$1());\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], googleSearchRetrievalToVertex$1(apiClient, fromGoogleSearchRetrieval));\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    return toObject;\n}\nfunction sessionResumptionConfigToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromHandle = getValueByPath(fromObject, [\n        \"handle\"\n    ]);\n    if (fromHandle != null) {\n        setValueByPath(toObject, [\n            \"handle\"\n        ], fromHandle);\n    }\n    if (getValueByPath(fromObject, [\n        \"transparent\"\n    ]) !== undefined) {\n        throw new Error(\"transparent parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction sessionResumptionConfigToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromHandle = getValueByPath(fromObject, [\n        \"handle\"\n    ]);\n    if (fromHandle != null) {\n        setValueByPath(toObject, [\n            \"handle\"\n        ], fromHandle);\n    }\n    const fromTransparent = getValueByPath(fromObject, [\n        \"transparent\"\n    ]);\n    if (fromTransparent != null) {\n        setValueByPath(toObject, [\n            \"transparent\"\n        ], fromTransparent);\n    }\n    return toObject;\n}\nfunction audioTranscriptionConfigToMldev() {\n    const toObject = {};\n    return toObject;\n}\nfunction audioTranscriptionConfigToVertex() {\n    const toObject = {};\n    return toObject;\n}\nfunction automaticActivityDetectionToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromDisabled = getValueByPath(fromObject, [\n        \"disabled\"\n    ]);\n    if (fromDisabled != null) {\n        setValueByPath(toObject, [\n            \"disabled\"\n        ], fromDisabled);\n    }\n    const fromStartOfSpeechSensitivity = getValueByPath(fromObject, [\n        \"startOfSpeechSensitivity\"\n    ]);\n    if (fromStartOfSpeechSensitivity != null) {\n        setValueByPath(toObject, [\n            \"startOfSpeechSensitivity\"\n        ], fromStartOfSpeechSensitivity);\n    }\n    const fromEndOfSpeechSensitivity = getValueByPath(fromObject, [\n        \"endOfSpeechSensitivity\"\n    ]);\n    if (fromEndOfSpeechSensitivity != null) {\n        setValueByPath(toObject, [\n            \"endOfSpeechSensitivity\"\n        ], fromEndOfSpeechSensitivity);\n    }\n    const fromPrefixPaddingMs = getValueByPath(fromObject, [\n        \"prefixPaddingMs\"\n    ]);\n    if (fromPrefixPaddingMs != null) {\n        setValueByPath(toObject, [\n            \"prefixPaddingMs\"\n        ], fromPrefixPaddingMs);\n    }\n    const fromSilenceDurationMs = getValueByPath(fromObject, [\n        \"silenceDurationMs\"\n    ]);\n    if (fromSilenceDurationMs != null) {\n        setValueByPath(toObject, [\n            \"silenceDurationMs\"\n        ], fromSilenceDurationMs);\n    }\n    return toObject;\n}\nfunction automaticActivityDetectionToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromDisabled = getValueByPath(fromObject, [\n        \"disabled\"\n    ]);\n    if (fromDisabled != null) {\n        setValueByPath(toObject, [\n            \"disabled\"\n        ], fromDisabled);\n    }\n    const fromStartOfSpeechSensitivity = getValueByPath(fromObject, [\n        \"startOfSpeechSensitivity\"\n    ]);\n    if (fromStartOfSpeechSensitivity != null) {\n        setValueByPath(toObject, [\n            \"startOfSpeechSensitivity\"\n        ], fromStartOfSpeechSensitivity);\n    }\n    const fromEndOfSpeechSensitivity = getValueByPath(fromObject, [\n        \"endOfSpeechSensitivity\"\n    ]);\n    if (fromEndOfSpeechSensitivity != null) {\n        setValueByPath(toObject, [\n            \"endOfSpeechSensitivity\"\n        ], fromEndOfSpeechSensitivity);\n    }\n    const fromPrefixPaddingMs = getValueByPath(fromObject, [\n        \"prefixPaddingMs\"\n    ]);\n    if (fromPrefixPaddingMs != null) {\n        setValueByPath(toObject, [\n            \"prefixPaddingMs\"\n        ], fromPrefixPaddingMs);\n    }\n    const fromSilenceDurationMs = getValueByPath(fromObject, [\n        \"silenceDurationMs\"\n    ]);\n    if (fromSilenceDurationMs != null) {\n        setValueByPath(toObject, [\n            \"silenceDurationMs\"\n        ], fromSilenceDurationMs);\n    }\n    return toObject;\n}\nfunction realtimeInputConfigToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromAutomaticActivityDetection = getValueByPath(fromObject, [\n        \"automaticActivityDetection\"\n    ]);\n    if (fromAutomaticActivityDetection != null) {\n        setValueByPath(toObject, [\n            \"automaticActivityDetection\"\n        ], automaticActivityDetectionToMldev(apiClient, fromAutomaticActivityDetection));\n    }\n    const fromActivityHandling = getValueByPath(fromObject, [\n        \"activityHandling\"\n    ]);\n    if (fromActivityHandling != null) {\n        setValueByPath(toObject, [\n            \"activityHandling\"\n        ], fromActivityHandling);\n    }\n    const fromTurnCoverage = getValueByPath(fromObject, [\n        \"turnCoverage\"\n    ]);\n    if (fromTurnCoverage != null) {\n        setValueByPath(toObject, [\n            \"turnCoverage\"\n        ], fromTurnCoverage);\n    }\n    return toObject;\n}\nfunction realtimeInputConfigToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromAutomaticActivityDetection = getValueByPath(fromObject, [\n        \"automaticActivityDetection\"\n    ]);\n    if (fromAutomaticActivityDetection != null) {\n        setValueByPath(toObject, [\n            \"automaticActivityDetection\"\n        ], automaticActivityDetectionToVertex(apiClient, fromAutomaticActivityDetection));\n    }\n    const fromActivityHandling = getValueByPath(fromObject, [\n        \"activityHandling\"\n    ]);\n    if (fromActivityHandling != null) {\n        setValueByPath(toObject, [\n            \"activityHandling\"\n        ], fromActivityHandling);\n    }\n    const fromTurnCoverage = getValueByPath(fromObject, [\n        \"turnCoverage\"\n    ]);\n    if (fromTurnCoverage != null) {\n        setValueByPath(toObject, [\n            \"turnCoverage\"\n        ], fromTurnCoverage);\n    }\n    return toObject;\n}\nfunction slidingWindowToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromTargetTokens = getValueByPath(fromObject, [\n        \"targetTokens\"\n    ]);\n    if (fromTargetTokens != null) {\n        setValueByPath(toObject, [\n            \"targetTokens\"\n        ], fromTargetTokens);\n    }\n    return toObject;\n}\nfunction slidingWindowToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromTargetTokens = getValueByPath(fromObject, [\n        \"targetTokens\"\n    ]);\n    if (fromTargetTokens != null) {\n        setValueByPath(toObject, [\n            \"targetTokens\"\n        ], fromTargetTokens);\n    }\n    return toObject;\n}\nfunction contextWindowCompressionConfigToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromTriggerTokens = getValueByPath(fromObject, [\n        \"triggerTokens\"\n    ]);\n    if (fromTriggerTokens != null) {\n        setValueByPath(toObject, [\n            \"triggerTokens\"\n        ], fromTriggerTokens);\n    }\n    const fromSlidingWindow = getValueByPath(fromObject, [\n        \"slidingWindow\"\n    ]);\n    if (fromSlidingWindow != null) {\n        setValueByPath(toObject, [\n            \"slidingWindow\"\n        ], slidingWindowToMldev(apiClient, fromSlidingWindow));\n    }\n    return toObject;\n}\nfunction contextWindowCompressionConfigToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromTriggerTokens = getValueByPath(fromObject, [\n        \"triggerTokens\"\n    ]);\n    if (fromTriggerTokens != null) {\n        setValueByPath(toObject, [\n            \"triggerTokens\"\n        ], fromTriggerTokens);\n    }\n    const fromSlidingWindow = getValueByPath(fromObject, [\n        \"slidingWindow\"\n    ]);\n    if (fromSlidingWindow != null) {\n        setValueByPath(toObject, [\n            \"slidingWindow\"\n        ], slidingWindowToVertex(apiClient, fromSlidingWindow));\n    }\n    return toObject;\n}\nfunction liveConnectConfigToMldev(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromGenerationConfig = getValueByPath(fromObject, [\n        \"generationConfig\"\n    ]);\n    if (parentObject !== undefined && fromGenerationConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\"\n        ], fromGenerationConfig);\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        \"responseModalities\"\n    ]);\n    if (parentObject !== undefined && fromResponseModalities != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"responseModalities\"\n        ], fromResponseModalities);\n    }\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (parentObject !== undefined && fromTemperature != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, [\n        \"topP\"\n    ]);\n    if (parentObject !== undefined && fromTopP != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"topP\"\n        ], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (parentObject !== undefined && fromTopK != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        \"maxOutputTokens\"\n    ]);\n    if (parentObject !== undefined && fromMaxOutputTokens != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"maxOutputTokens\"\n        ], fromMaxOutputTokens);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (parentObject !== undefined && fromMediaResolution != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, [\n        \"speechConfig\"\n    ]);\n    if (parentObject !== undefined && fromSpeechConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"speechConfig\"\n        ], fromSpeechConfig);\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"systemInstruction\"\n        ], contentToMldev$1(apiClient, tContent(apiClient, fromSystemInstruction)));\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        if (Array.isArray(fromTools)) {\n            setValueByPath(parentObject, [\n                \"setup\",\n                \"tools\"\n            ], tTools(apiClient, tTools(apiClient, fromTools).map((item)=>{\n                return toolToMldev$1(apiClient, tTool(apiClient, item));\n            })));\n        } else {\n            setValueByPath(parentObject, [\n                \"setup\",\n                \"tools\"\n            ], tTools(apiClient, fromTools));\n        }\n    }\n    const fromSessionResumption = getValueByPath(fromObject, [\n        \"sessionResumption\"\n    ]);\n    if (parentObject !== undefined && fromSessionResumption != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"sessionResumption\"\n        ], sessionResumptionConfigToMldev(apiClient, fromSessionResumption));\n    }\n    if (getValueByPath(fromObject, [\n        \"inputAudioTranscription\"\n    ]) !== undefined) {\n        throw new Error(\"inputAudioTranscription parameter is not supported in Gemini API.\");\n    }\n    const fromOutputAudioTranscription = getValueByPath(fromObject, [\n        \"outputAudioTranscription\"\n    ]);\n    if (parentObject !== undefined && fromOutputAudioTranscription != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"outputAudioTranscription\"\n        ], audioTranscriptionConfigToMldev());\n    }\n    const fromRealtimeInputConfig = getValueByPath(fromObject, [\n        \"realtimeInputConfig\"\n    ]);\n    if (parentObject !== undefined && fromRealtimeInputConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"realtimeInputConfig\"\n        ], realtimeInputConfigToMldev(apiClient, fromRealtimeInputConfig));\n    }\n    const fromContextWindowCompression = getValueByPath(fromObject, [\n        \"contextWindowCompression\"\n    ]);\n    if (parentObject !== undefined && fromContextWindowCompression != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"contextWindowCompression\"\n        ], contextWindowCompressionConfigToMldev(apiClient, fromContextWindowCompression));\n    }\n    return toObject;\n}\nfunction liveConnectConfigToVertex(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromGenerationConfig = getValueByPath(fromObject, [\n        \"generationConfig\"\n    ]);\n    if (parentObject !== undefined && fromGenerationConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\"\n        ], fromGenerationConfig);\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        \"responseModalities\"\n    ]);\n    if (parentObject !== undefined && fromResponseModalities != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"responseModalities\"\n        ], fromResponseModalities);\n    }\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (parentObject !== undefined && fromTemperature != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, [\n        \"topP\"\n    ]);\n    if (parentObject !== undefined && fromTopP != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"topP\"\n        ], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (parentObject !== undefined && fromTopK != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        \"maxOutputTokens\"\n    ]);\n    if (parentObject !== undefined && fromMaxOutputTokens != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"maxOutputTokens\"\n        ], fromMaxOutputTokens);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (parentObject !== undefined && fromMediaResolution != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, [\n        \"speechConfig\"\n    ]);\n    if (parentObject !== undefined && fromSpeechConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"speechConfig\"\n        ], fromSpeechConfig);\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"systemInstruction\"\n        ], contentToVertex$1(apiClient, tContent(apiClient, fromSystemInstruction)));\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        if (Array.isArray(fromTools)) {\n            setValueByPath(parentObject, [\n                \"setup\",\n                \"tools\"\n            ], tTools(apiClient, tTools(apiClient, fromTools).map((item)=>{\n                return toolToVertex$1(apiClient, tTool(apiClient, item));\n            })));\n        } else {\n            setValueByPath(parentObject, [\n                \"setup\",\n                \"tools\"\n            ], tTools(apiClient, fromTools));\n        }\n    }\n    const fromSessionResumption = getValueByPath(fromObject, [\n        \"sessionResumption\"\n    ]);\n    if (parentObject !== undefined && fromSessionResumption != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"sessionResumption\"\n        ], sessionResumptionConfigToVertex(apiClient, fromSessionResumption));\n    }\n    const fromInputAudioTranscription = getValueByPath(fromObject, [\n        \"inputAudioTranscription\"\n    ]);\n    if (parentObject !== undefined && fromInputAudioTranscription != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"inputAudioTranscription\"\n        ], audioTranscriptionConfigToVertex());\n    }\n    const fromOutputAudioTranscription = getValueByPath(fromObject, [\n        \"outputAudioTranscription\"\n    ]);\n    if (parentObject !== undefined && fromOutputAudioTranscription != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"outputAudioTranscription\"\n        ], audioTranscriptionConfigToVertex());\n    }\n    const fromRealtimeInputConfig = getValueByPath(fromObject, [\n        \"realtimeInputConfig\"\n    ]);\n    if (parentObject !== undefined && fromRealtimeInputConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"realtimeInputConfig\"\n        ], realtimeInputConfigToVertex(apiClient, fromRealtimeInputConfig));\n    }\n    const fromContextWindowCompression = getValueByPath(fromObject, [\n        \"contextWindowCompression\"\n    ]);\n    if (parentObject !== undefined && fromContextWindowCompression != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"contextWindowCompression\"\n        ], contextWindowCompressionConfigToVertex(apiClient, fromContextWindowCompression));\n    }\n    return toObject;\n}\nfunction liveConnectParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"setup\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], liveConnectConfigToMldev(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction liveConnectParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"setup\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], liveConnectConfigToVertex(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction activityStartToMldev() {\n    const toObject = {};\n    return toObject;\n}\nfunction activityStartToVertex() {\n    const toObject = {};\n    return toObject;\n}\nfunction activityEndToMldev() {\n    const toObject = {};\n    return toObject;\n}\nfunction activityEndToVertex() {\n    const toObject = {};\n    return toObject;\n}\nfunction liveSendRealtimeInputParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromMedia = getValueByPath(fromObject, [\n        \"media\"\n    ]);\n    if (fromMedia != null) {\n        setValueByPath(toObject, [\n            \"mediaChunks\"\n        ], tBlobs(apiClient, fromMedia));\n    }\n    const fromAudio = getValueByPath(fromObject, [\n        \"audio\"\n    ]);\n    if (fromAudio != null) {\n        setValueByPath(toObject, [\n            \"audio\"\n        ], tAudioBlob(apiClient, fromAudio));\n    }\n    const fromAudioStreamEnd = getValueByPath(fromObject, [\n        \"audioStreamEnd\"\n    ]);\n    if (fromAudioStreamEnd != null) {\n        setValueByPath(toObject, [\n            \"audioStreamEnd\"\n        ], fromAudioStreamEnd);\n    }\n    const fromVideo = getValueByPath(fromObject, [\n        \"video\"\n    ]);\n    if (fromVideo != null) {\n        setValueByPath(toObject, [\n            \"video\"\n        ], tImageBlob(apiClient, fromVideo));\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    const fromActivityStart = getValueByPath(fromObject, [\n        \"activityStart\"\n    ]);\n    if (fromActivityStart != null) {\n        setValueByPath(toObject, [\n            \"activityStart\"\n        ], activityStartToMldev());\n    }\n    const fromActivityEnd = getValueByPath(fromObject, [\n        \"activityEnd\"\n    ]);\n    if (fromActivityEnd != null) {\n        setValueByPath(toObject, [\n            \"activityEnd\"\n        ], activityEndToMldev());\n    }\n    return toObject;\n}\nfunction liveSendRealtimeInputParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromMedia = getValueByPath(fromObject, [\n        \"media\"\n    ]);\n    if (fromMedia != null) {\n        setValueByPath(toObject, [\n            \"mediaChunks\"\n        ], tBlobs(apiClient, fromMedia));\n    }\n    if (getValueByPath(fromObject, [\n        \"audio\"\n    ]) !== undefined) {\n        throw new Error(\"audio parameter is not supported in Vertex AI.\");\n    }\n    const fromAudioStreamEnd = getValueByPath(fromObject, [\n        \"audioStreamEnd\"\n    ]);\n    if (fromAudioStreamEnd != null) {\n        setValueByPath(toObject, [\n            \"audioStreamEnd\"\n        ], fromAudioStreamEnd);\n    }\n    if (getValueByPath(fromObject, [\n        \"video\"\n    ]) !== undefined) {\n        throw new Error(\"video parameter is not supported in Vertex AI.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"text\"\n    ]) !== undefined) {\n        throw new Error(\"text parameter is not supported in Vertex AI.\");\n    }\n    const fromActivityStart = getValueByPath(fromObject, [\n        \"activityStart\"\n    ]);\n    if (fromActivityStart != null) {\n        setValueByPath(toObject, [\n            \"activityStart\"\n        ], activityStartToVertex());\n    }\n    const fromActivityEnd = getValueByPath(fromObject, [\n        \"activityEnd\"\n    ]);\n    if (fromActivityEnd != null) {\n        setValueByPath(toObject, [\n            \"activityEnd\"\n        ], activityEndToVertex());\n    }\n    return toObject;\n}\nfunction liveServerSetupCompleteFromMldev() {\n    const toObject = {};\n    return toObject;\n}\nfunction liveServerSetupCompleteFromVertex() {\n    const toObject = {};\n    return toObject;\n}\nfunction partFromMldev$1(apiClient, fromObject) {\n    const toObject = {};\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fromFileData);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], fromFunctionCall);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], fromInlineData);\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    return toObject;\n}\nfunction partFromVertex$1(apiClient, fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], fromVideoMetadata);\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fromFileData);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], fromFunctionCall);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], fromInlineData);\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    return toObject;\n}\nfunction contentFromMldev$1(apiClient, fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        if (Array.isArray(fromParts)) {\n            setValueByPath(toObject, [\n                \"parts\"\n            ], fromParts.map((item)=>{\n                return partFromMldev$1(apiClient, item);\n            }));\n        } else {\n            setValueByPath(toObject, [\n                \"parts\"\n            ], fromParts);\n        }\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction contentFromVertex$1(apiClient, fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        if (Array.isArray(fromParts)) {\n            setValueByPath(toObject, [\n                \"parts\"\n            ], fromParts.map((item)=>{\n                return partFromVertex$1(apiClient, item);\n            }));\n        } else {\n            setValueByPath(toObject, [\n                \"parts\"\n            ], fromParts);\n        }\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction transcriptionFromMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    const fromFinished = getValueByPath(fromObject, [\n        \"finished\"\n    ]);\n    if (fromFinished != null) {\n        setValueByPath(toObject, [\n            \"finished\"\n        ], fromFinished);\n    }\n    return toObject;\n}\nfunction transcriptionFromVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    const fromFinished = getValueByPath(fromObject, [\n        \"finished\"\n    ]);\n    if (fromFinished != null) {\n        setValueByPath(toObject, [\n            \"finished\"\n        ], fromFinished);\n    }\n    return toObject;\n}\nfunction liveServerContentFromMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModelTurn = getValueByPath(fromObject, [\n        \"modelTurn\"\n    ]);\n    if (fromModelTurn != null) {\n        setValueByPath(toObject, [\n            \"modelTurn\"\n        ], contentFromMldev$1(apiClient, fromModelTurn));\n    }\n    const fromTurnComplete = getValueByPath(fromObject, [\n        \"turnComplete\"\n    ]);\n    if (fromTurnComplete != null) {\n        setValueByPath(toObject, [\n            \"turnComplete\"\n        ], fromTurnComplete);\n    }\n    const fromInterrupted = getValueByPath(fromObject, [\n        \"interrupted\"\n    ]);\n    if (fromInterrupted != null) {\n        setValueByPath(toObject, [\n            \"interrupted\"\n        ], fromInterrupted);\n    }\n    const fromGenerationComplete = getValueByPath(fromObject, [\n        \"generationComplete\"\n    ]);\n    if (fromGenerationComplete != null) {\n        setValueByPath(toObject, [\n            \"generationComplete\"\n        ], fromGenerationComplete);\n    }\n    const fromInputTranscription = getValueByPath(fromObject, [\n        \"inputTranscription\"\n    ]);\n    if (fromInputTranscription != null) {\n        setValueByPath(toObject, [\n            \"inputTranscription\"\n        ], transcriptionFromMldev(apiClient, fromInputTranscription));\n    }\n    const fromOutputTranscription = getValueByPath(fromObject, [\n        \"outputTranscription\"\n    ]);\n    if (fromOutputTranscription != null) {\n        setValueByPath(toObject, [\n            \"outputTranscription\"\n        ], transcriptionFromMldev(apiClient, fromOutputTranscription));\n    }\n    return toObject;\n}\nfunction liveServerContentFromVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModelTurn = getValueByPath(fromObject, [\n        \"modelTurn\"\n    ]);\n    if (fromModelTurn != null) {\n        setValueByPath(toObject, [\n            \"modelTurn\"\n        ], contentFromVertex$1(apiClient, fromModelTurn));\n    }\n    const fromTurnComplete = getValueByPath(fromObject, [\n        \"turnComplete\"\n    ]);\n    if (fromTurnComplete != null) {\n        setValueByPath(toObject, [\n            \"turnComplete\"\n        ], fromTurnComplete);\n    }\n    const fromInterrupted = getValueByPath(fromObject, [\n        \"interrupted\"\n    ]);\n    if (fromInterrupted != null) {\n        setValueByPath(toObject, [\n            \"interrupted\"\n        ], fromInterrupted);\n    }\n    const fromGenerationComplete = getValueByPath(fromObject, [\n        \"generationComplete\"\n    ]);\n    if (fromGenerationComplete != null) {\n        setValueByPath(toObject, [\n            \"generationComplete\"\n        ], fromGenerationComplete);\n    }\n    const fromInputTranscription = getValueByPath(fromObject, [\n        \"inputTranscription\"\n    ]);\n    if (fromInputTranscription != null) {\n        setValueByPath(toObject, [\n            \"inputTranscription\"\n        ], transcriptionFromVertex(apiClient, fromInputTranscription));\n    }\n    const fromOutputTranscription = getValueByPath(fromObject, [\n        \"outputTranscription\"\n    ]);\n    if (fromOutputTranscription != null) {\n        setValueByPath(toObject, [\n            \"outputTranscription\"\n        ], transcriptionFromVertex(apiClient, fromOutputTranscription));\n    }\n    return toObject;\n}\nfunction functionCallFromMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, [\n        \"id\"\n    ]);\n    if (fromId != null) {\n        setValueByPath(toObject, [\n            \"id\"\n        ], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, [\n        \"args\"\n    ]);\n    if (fromArgs != null) {\n        setValueByPath(toObject, [\n            \"args\"\n        ], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    return toObject;\n}\nfunction functionCallFromVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromArgs = getValueByPath(fromObject, [\n        \"args\"\n    ]);\n    if (fromArgs != null) {\n        setValueByPath(toObject, [\n            \"args\"\n        ], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    return toObject;\n}\nfunction liveServerToolCallFromMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromFunctionCalls = getValueByPath(fromObject, [\n        \"functionCalls\"\n    ]);\n    if (fromFunctionCalls != null) {\n        if (Array.isArray(fromFunctionCalls)) {\n            setValueByPath(toObject, [\n                \"functionCalls\"\n            ], fromFunctionCalls.map((item)=>{\n                return functionCallFromMldev(apiClient, item);\n            }));\n        } else {\n            setValueByPath(toObject, [\n                \"functionCalls\"\n            ], fromFunctionCalls);\n        }\n    }\n    return toObject;\n}\nfunction liveServerToolCallFromVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromFunctionCalls = getValueByPath(fromObject, [\n        \"functionCalls\"\n    ]);\n    if (fromFunctionCalls != null) {\n        if (Array.isArray(fromFunctionCalls)) {\n            setValueByPath(toObject, [\n                \"functionCalls\"\n            ], fromFunctionCalls.map((item)=>{\n                return functionCallFromVertex(apiClient, item);\n            }));\n        } else {\n            setValueByPath(toObject, [\n                \"functionCalls\"\n            ], fromFunctionCalls);\n        }\n    }\n    return toObject;\n}\nfunction liveServerToolCallCancellationFromMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromIds = getValueByPath(fromObject, [\n        \"ids\"\n    ]);\n    if (fromIds != null) {\n        setValueByPath(toObject, [\n            \"ids\"\n        ], fromIds);\n    }\n    return toObject;\n}\nfunction liveServerToolCallCancellationFromVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromIds = getValueByPath(fromObject, [\n        \"ids\"\n    ]);\n    if (fromIds != null) {\n        setValueByPath(toObject, [\n            \"ids\"\n        ], fromIds);\n    }\n    return toObject;\n}\nfunction modalityTokenCountFromMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModality = getValueByPath(fromObject, [\n        \"modality\"\n    ]);\n    if (fromModality != null) {\n        setValueByPath(toObject, [\n            \"modality\"\n        ], fromModality);\n    }\n    const fromTokenCount = getValueByPath(fromObject, [\n        \"tokenCount\"\n    ]);\n    if (fromTokenCount != null) {\n        setValueByPath(toObject, [\n            \"tokenCount\"\n        ], fromTokenCount);\n    }\n    return toObject;\n}\nfunction modalityTokenCountFromVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModality = getValueByPath(fromObject, [\n        \"modality\"\n    ]);\n    if (fromModality != null) {\n        setValueByPath(toObject, [\n            \"modality\"\n        ], fromModality);\n    }\n    const fromTokenCount = getValueByPath(fromObject, [\n        \"tokenCount\"\n    ]);\n    if (fromTokenCount != null) {\n        setValueByPath(toObject, [\n            \"tokenCount\"\n        ], fromTokenCount);\n    }\n    return toObject;\n}\nfunction usageMetadataFromMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromPromptTokenCount = getValueByPath(fromObject, [\n        \"promptTokenCount\"\n    ]);\n    if (fromPromptTokenCount != null) {\n        setValueByPath(toObject, [\n            \"promptTokenCount\"\n        ], fromPromptTokenCount);\n    }\n    const fromCachedContentTokenCount = getValueByPath(fromObject, [\n        \"cachedContentTokenCount\"\n    ]);\n    if (fromCachedContentTokenCount != null) {\n        setValueByPath(toObject, [\n            \"cachedContentTokenCount\"\n        ], fromCachedContentTokenCount);\n    }\n    const fromResponseTokenCount = getValueByPath(fromObject, [\n        \"responseTokenCount\"\n    ]);\n    if (fromResponseTokenCount != null) {\n        setValueByPath(toObject, [\n            \"responseTokenCount\"\n        ], fromResponseTokenCount);\n    }\n    const fromToolUsePromptTokenCount = getValueByPath(fromObject, [\n        \"toolUsePromptTokenCount\"\n    ]);\n    if (fromToolUsePromptTokenCount != null) {\n        setValueByPath(toObject, [\n            \"toolUsePromptTokenCount\"\n        ], fromToolUsePromptTokenCount);\n    }\n    const fromThoughtsTokenCount = getValueByPath(fromObject, [\n        \"thoughtsTokenCount\"\n    ]);\n    if (fromThoughtsTokenCount != null) {\n        setValueByPath(toObject, [\n            \"thoughtsTokenCount\"\n        ], fromThoughtsTokenCount);\n    }\n    const fromTotalTokenCount = getValueByPath(fromObject, [\n        \"totalTokenCount\"\n    ]);\n    if (fromTotalTokenCount != null) {\n        setValueByPath(toObject, [\n            \"totalTokenCount\"\n        ], fromTotalTokenCount);\n    }\n    const fromPromptTokensDetails = getValueByPath(fromObject, [\n        \"promptTokensDetails\"\n    ]);\n    if (fromPromptTokensDetails != null) {\n        if (Array.isArray(fromPromptTokensDetails)) {\n            setValueByPath(toObject, [\n                \"promptTokensDetails\"\n            ], fromPromptTokensDetails.map((item)=>{\n                return modalityTokenCountFromMldev(apiClient, item);\n            }));\n        } else {\n            setValueByPath(toObject, [\n                \"promptTokensDetails\"\n            ], fromPromptTokensDetails);\n        }\n    }\n    const fromCacheTokensDetails = getValueByPath(fromObject, [\n        \"cacheTokensDetails\"\n    ]);\n    if (fromCacheTokensDetails != null) {\n        if (Array.isArray(fromCacheTokensDetails)) {\n            setValueByPath(toObject, [\n                \"cacheTokensDetails\"\n            ], fromCacheTokensDetails.map((item)=>{\n                return modalityTokenCountFromMldev(apiClient, item);\n            }));\n        } else {\n            setValueByPath(toObject, [\n                \"cacheTokensDetails\"\n            ], fromCacheTokensDetails);\n        }\n    }\n    const fromResponseTokensDetails = getValueByPath(fromObject, [\n        \"responseTokensDetails\"\n    ]);\n    if (fromResponseTokensDetails != null) {\n        if (Array.isArray(fromResponseTokensDetails)) {\n            setValueByPath(toObject, [\n                \"responseTokensDetails\"\n            ], fromResponseTokensDetails.map((item)=>{\n                return modalityTokenCountFromMldev(apiClient, item);\n            }));\n        } else {\n            setValueByPath(toObject, [\n                \"responseTokensDetails\"\n            ], fromResponseTokensDetails);\n        }\n    }\n    const fromToolUsePromptTokensDetails = getValueByPath(fromObject, [\n        \"toolUsePromptTokensDetails\"\n    ]);\n    if (fromToolUsePromptTokensDetails != null) {\n        if (Array.isArray(fromToolUsePromptTokensDetails)) {\n            setValueByPath(toObject, [\n                \"toolUsePromptTokensDetails\"\n            ], fromToolUsePromptTokensDetails.map((item)=>{\n                return modalityTokenCountFromMldev(apiClient, item);\n            }));\n        } else {\n            setValueByPath(toObject, [\n                \"toolUsePromptTokensDetails\"\n            ], fromToolUsePromptTokensDetails);\n        }\n    }\n    return toObject;\n}\nfunction usageMetadataFromVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromPromptTokenCount = getValueByPath(fromObject, [\n        \"promptTokenCount\"\n    ]);\n    if (fromPromptTokenCount != null) {\n        setValueByPath(toObject, [\n            \"promptTokenCount\"\n        ], fromPromptTokenCount);\n    }\n    const fromCachedContentTokenCount = getValueByPath(fromObject, [\n        \"cachedContentTokenCount\"\n    ]);\n    if (fromCachedContentTokenCount != null) {\n        setValueByPath(toObject, [\n            \"cachedContentTokenCount\"\n        ], fromCachedContentTokenCount);\n    }\n    const fromResponseTokenCount = getValueByPath(fromObject, [\n        \"candidatesTokenCount\"\n    ]);\n    if (fromResponseTokenCount != null) {\n        setValueByPath(toObject, [\n            \"responseTokenCount\"\n        ], fromResponseTokenCount);\n    }\n    const fromToolUsePromptTokenCount = getValueByPath(fromObject, [\n        \"toolUsePromptTokenCount\"\n    ]);\n    if (fromToolUsePromptTokenCount != null) {\n        setValueByPath(toObject, [\n            \"toolUsePromptTokenCount\"\n        ], fromToolUsePromptTokenCount);\n    }\n    const fromThoughtsTokenCount = getValueByPath(fromObject, [\n        \"thoughtsTokenCount\"\n    ]);\n    if (fromThoughtsTokenCount != null) {\n        setValueByPath(toObject, [\n            \"thoughtsTokenCount\"\n        ], fromThoughtsTokenCount);\n    }\n    const fromTotalTokenCount = getValueByPath(fromObject, [\n        \"totalTokenCount\"\n    ]);\n    if (fromTotalTokenCount != null) {\n        setValueByPath(toObject, [\n            \"totalTokenCount\"\n        ], fromTotalTokenCount);\n    }\n    const fromPromptTokensDetails = getValueByPath(fromObject, [\n        \"promptTokensDetails\"\n    ]);\n    if (fromPromptTokensDetails != null) {\n        if (Array.isArray(fromPromptTokensDetails)) {\n            setValueByPath(toObject, [\n                \"promptTokensDetails\"\n            ], fromPromptTokensDetails.map((item)=>{\n                return modalityTokenCountFromVertex(apiClient, item);\n            }));\n        } else {\n            setValueByPath(toObject, [\n                \"promptTokensDetails\"\n            ], fromPromptTokensDetails);\n        }\n    }\n    const fromCacheTokensDetails = getValueByPath(fromObject, [\n        \"cacheTokensDetails\"\n    ]);\n    if (fromCacheTokensDetails != null) {\n        if (Array.isArray(fromCacheTokensDetails)) {\n            setValueByPath(toObject, [\n                \"cacheTokensDetails\"\n            ], fromCacheTokensDetails.map((item)=>{\n                return modalityTokenCountFromVertex(apiClient, item);\n            }));\n        } else {\n            setValueByPath(toObject, [\n                \"cacheTokensDetails\"\n            ], fromCacheTokensDetails);\n        }\n    }\n    const fromResponseTokensDetails = getValueByPath(fromObject, [\n        \"candidatesTokensDetails\"\n    ]);\n    if (fromResponseTokensDetails != null) {\n        if (Array.isArray(fromResponseTokensDetails)) {\n            setValueByPath(toObject, [\n                \"responseTokensDetails\"\n            ], fromResponseTokensDetails.map((item)=>{\n                return modalityTokenCountFromVertex(apiClient, item);\n            }));\n        } else {\n            setValueByPath(toObject, [\n                \"responseTokensDetails\"\n            ], fromResponseTokensDetails);\n        }\n    }\n    const fromToolUsePromptTokensDetails = getValueByPath(fromObject, [\n        \"toolUsePromptTokensDetails\"\n    ]);\n    if (fromToolUsePromptTokensDetails != null) {\n        if (Array.isArray(fromToolUsePromptTokensDetails)) {\n            setValueByPath(toObject, [\n                \"toolUsePromptTokensDetails\"\n            ], fromToolUsePromptTokensDetails.map((item)=>{\n                return modalityTokenCountFromVertex(apiClient, item);\n            }));\n        } else {\n            setValueByPath(toObject, [\n                \"toolUsePromptTokensDetails\"\n            ], fromToolUsePromptTokensDetails);\n        }\n    }\n    const fromTrafficType = getValueByPath(fromObject, [\n        \"trafficType\"\n    ]);\n    if (fromTrafficType != null) {\n        setValueByPath(toObject, [\n            \"trafficType\"\n        ], fromTrafficType);\n    }\n    return toObject;\n}\nfunction liveServerGoAwayFromMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromTimeLeft = getValueByPath(fromObject, [\n        \"timeLeft\"\n    ]);\n    if (fromTimeLeft != null) {\n        setValueByPath(toObject, [\n            \"timeLeft\"\n        ], fromTimeLeft);\n    }\n    return toObject;\n}\nfunction liveServerGoAwayFromVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromTimeLeft = getValueByPath(fromObject, [\n        \"timeLeft\"\n    ]);\n    if (fromTimeLeft != null) {\n        setValueByPath(toObject, [\n            \"timeLeft\"\n        ], fromTimeLeft);\n    }\n    return toObject;\n}\nfunction liveServerSessionResumptionUpdateFromMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromNewHandle = getValueByPath(fromObject, [\n        \"newHandle\"\n    ]);\n    if (fromNewHandle != null) {\n        setValueByPath(toObject, [\n            \"newHandle\"\n        ], fromNewHandle);\n    }\n    const fromResumable = getValueByPath(fromObject, [\n        \"resumable\"\n    ]);\n    if (fromResumable != null) {\n        setValueByPath(toObject, [\n            \"resumable\"\n        ], fromResumable);\n    }\n    const fromLastConsumedClientMessageIndex = getValueByPath(fromObject, [\n        \"lastConsumedClientMessageIndex\"\n    ]);\n    if (fromLastConsumedClientMessageIndex != null) {\n        setValueByPath(toObject, [\n            \"lastConsumedClientMessageIndex\"\n        ], fromLastConsumedClientMessageIndex);\n    }\n    return toObject;\n}\nfunction liveServerSessionResumptionUpdateFromVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromNewHandle = getValueByPath(fromObject, [\n        \"newHandle\"\n    ]);\n    if (fromNewHandle != null) {\n        setValueByPath(toObject, [\n            \"newHandle\"\n        ], fromNewHandle);\n    }\n    const fromResumable = getValueByPath(fromObject, [\n        \"resumable\"\n    ]);\n    if (fromResumable != null) {\n        setValueByPath(toObject, [\n            \"resumable\"\n        ], fromResumable);\n    }\n    const fromLastConsumedClientMessageIndex = getValueByPath(fromObject, [\n        \"lastConsumedClientMessageIndex\"\n    ]);\n    if (fromLastConsumedClientMessageIndex != null) {\n        setValueByPath(toObject, [\n            \"lastConsumedClientMessageIndex\"\n        ], fromLastConsumedClientMessageIndex);\n    }\n    return toObject;\n}\nfunction liveServerMessageFromMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromSetupComplete = getValueByPath(fromObject, [\n        \"setupComplete\"\n    ]);\n    if (fromSetupComplete != null) {\n        setValueByPath(toObject, [\n            \"setupComplete\"\n        ], liveServerSetupCompleteFromMldev());\n    }\n    const fromServerContent = getValueByPath(fromObject, [\n        \"serverContent\"\n    ]);\n    if (fromServerContent != null) {\n        setValueByPath(toObject, [\n            \"serverContent\"\n        ], liveServerContentFromMldev(apiClient, fromServerContent));\n    }\n    const fromToolCall = getValueByPath(fromObject, [\n        \"toolCall\"\n    ]);\n    if (fromToolCall != null) {\n        setValueByPath(toObject, [\n            \"toolCall\"\n        ], liveServerToolCallFromMldev(apiClient, fromToolCall));\n    }\n    const fromToolCallCancellation = getValueByPath(fromObject, [\n        \"toolCallCancellation\"\n    ]);\n    if (fromToolCallCancellation != null) {\n        setValueByPath(toObject, [\n            \"toolCallCancellation\"\n        ], liveServerToolCallCancellationFromMldev(apiClient, fromToolCallCancellation));\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        \"usageMetadata\"\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, [\n            \"usageMetadata\"\n        ], usageMetadataFromMldev(apiClient, fromUsageMetadata));\n    }\n    const fromGoAway = getValueByPath(fromObject, [\n        \"goAway\"\n    ]);\n    if (fromGoAway != null) {\n        setValueByPath(toObject, [\n            \"goAway\"\n        ], liveServerGoAwayFromMldev(apiClient, fromGoAway));\n    }\n    const fromSessionResumptionUpdate = getValueByPath(fromObject, [\n        \"sessionResumptionUpdate\"\n    ]);\n    if (fromSessionResumptionUpdate != null) {\n        setValueByPath(toObject, [\n            \"sessionResumptionUpdate\"\n        ], liveServerSessionResumptionUpdateFromMldev(apiClient, fromSessionResumptionUpdate));\n    }\n    return toObject;\n}\nfunction liveServerMessageFromVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromSetupComplete = getValueByPath(fromObject, [\n        \"setupComplete\"\n    ]);\n    if (fromSetupComplete != null) {\n        setValueByPath(toObject, [\n            \"setupComplete\"\n        ], liveServerSetupCompleteFromVertex());\n    }\n    const fromServerContent = getValueByPath(fromObject, [\n        \"serverContent\"\n    ]);\n    if (fromServerContent != null) {\n        setValueByPath(toObject, [\n            \"serverContent\"\n        ], liveServerContentFromVertex(apiClient, fromServerContent));\n    }\n    const fromToolCall = getValueByPath(fromObject, [\n        \"toolCall\"\n    ]);\n    if (fromToolCall != null) {\n        setValueByPath(toObject, [\n            \"toolCall\"\n        ], liveServerToolCallFromVertex(apiClient, fromToolCall));\n    }\n    const fromToolCallCancellation = getValueByPath(fromObject, [\n        \"toolCallCancellation\"\n    ]);\n    if (fromToolCallCancellation != null) {\n        setValueByPath(toObject, [\n            \"toolCallCancellation\"\n        ], liveServerToolCallCancellationFromVertex(apiClient, fromToolCallCancellation));\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        \"usageMetadata\"\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, [\n            \"usageMetadata\"\n        ], usageMetadataFromVertex(apiClient, fromUsageMetadata));\n    }\n    const fromGoAway = getValueByPath(fromObject, [\n        \"goAway\"\n    ]);\n    if (fromGoAway != null) {\n        setValueByPath(toObject, [\n            \"goAway\"\n        ], liveServerGoAwayFromVertex(apiClient, fromGoAway));\n    }\n    const fromSessionResumptionUpdate = getValueByPath(fromObject, [\n        \"sessionResumptionUpdate\"\n    ]);\n    if (fromSessionResumptionUpdate != null) {\n        setValueByPath(toObject, [\n            \"sessionResumptionUpdate\"\n        ], liveServerSessionResumptionUpdateFromVertex(apiClient, fromSessionResumptionUpdate));\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ function partToMldev(apiClient, fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]) !== undefined) {\n        throw new Error(\"videoMetadata parameter is not supported in Gemini API.\");\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fromFileData);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], fromFunctionCall);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], fromInlineData);\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    return toObject;\n}\nfunction contentToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        if (Array.isArray(fromParts)) {\n            setValueByPath(toObject, [\n                \"parts\"\n            ], fromParts.map((item)=>{\n                return partToMldev(apiClient, item);\n            }));\n        } else {\n            setValueByPath(toObject, [\n                \"parts\"\n            ], fromParts);\n        }\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction schemaToMldev(apiClient, fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"example\"\n    ]) !== undefined) {\n        throw new Error(\"example parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"pattern\"\n    ]) !== undefined) {\n        throw new Error(\"pattern parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"default\"\n    ]) !== undefined) {\n        throw new Error(\"default parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"maxLength\"\n    ]) !== undefined) {\n        throw new Error(\"maxLength parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"minLength\"\n    ]) !== undefined) {\n        throw new Error(\"minLength parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"minProperties\"\n    ]) !== undefined) {\n        throw new Error(\"minProperties parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"maxProperties\"\n    ]) !== undefined) {\n        throw new Error(\"maxProperties parameter is not supported in Gemini API.\");\n    }\n    const fromAnyOf = getValueByPath(fromObject, [\n        \"anyOf\"\n    ]);\n    if (fromAnyOf != null) {\n        setValueByPath(toObject, [\n            \"anyOf\"\n        ], fromAnyOf);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromEnum = getValueByPath(fromObject, [\n        \"enum\"\n    ]);\n    if (fromEnum != null) {\n        setValueByPath(toObject, [\n            \"enum\"\n        ], fromEnum);\n    }\n    const fromFormat = getValueByPath(fromObject, [\n        \"format\"\n    ]);\n    if (fromFormat != null) {\n        setValueByPath(toObject, [\n            \"format\"\n        ], fromFormat);\n    }\n    const fromItems = getValueByPath(fromObject, [\n        \"items\"\n    ]);\n    if (fromItems != null) {\n        setValueByPath(toObject, [\n            \"items\"\n        ], fromItems);\n    }\n    const fromMaxItems = getValueByPath(fromObject, [\n        \"maxItems\"\n    ]);\n    if (fromMaxItems != null) {\n        setValueByPath(toObject, [\n            \"maxItems\"\n        ], fromMaxItems);\n    }\n    const fromMaximum = getValueByPath(fromObject, [\n        \"maximum\"\n    ]);\n    if (fromMaximum != null) {\n        setValueByPath(toObject, [\n            \"maximum\"\n        ], fromMaximum);\n    }\n    const fromMinItems = getValueByPath(fromObject, [\n        \"minItems\"\n    ]);\n    if (fromMinItems != null) {\n        setValueByPath(toObject, [\n            \"minItems\"\n        ], fromMinItems);\n    }\n    const fromMinimum = getValueByPath(fromObject, [\n        \"minimum\"\n    ]);\n    if (fromMinimum != null) {\n        setValueByPath(toObject, [\n            \"minimum\"\n        ], fromMinimum);\n    }\n    const fromNullable = getValueByPath(fromObject, [\n        \"nullable\"\n    ]);\n    if (fromNullable != null) {\n        setValueByPath(toObject, [\n            \"nullable\"\n        ], fromNullable);\n    }\n    const fromProperties = getValueByPath(fromObject, [\n        \"properties\"\n    ]);\n    if (fromProperties != null) {\n        setValueByPath(toObject, [\n            \"properties\"\n        ], fromProperties);\n    }\n    const fromPropertyOrdering = getValueByPath(fromObject, [\n        \"propertyOrdering\"\n    ]);\n    if (fromPropertyOrdering != null) {\n        setValueByPath(toObject, [\n            \"propertyOrdering\"\n        ], fromPropertyOrdering);\n    }\n    const fromRequired = getValueByPath(fromObject, [\n        \"required\"\n    ]);\n    if (fromRequired != null) {\n        setValueByPath(toObject, [\n            \"required\"\n        ], fromRequired);\n    }\n    const fromTitle = getValueByPath(fromObject, [\n        \"title\"\n    ]);\n    if (fromTitle != null) {\n        setValueByPath(toObject, [\n            \"title\"\n        ], fromTitle);\n    }\n    const fromType = getValueByPath(fromObject, [\n        \"type\"\n    ]);\n    if (fromType != null) {\n        setValueByPath(toObject, [\n            \"type\"\n        ], fromType);\n    }\n    return toObject;\n}\nfunction safetySettingToMldev(apiClient, fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"method\"\n    ]) !== undefined) {\n        throw new Error(\"method parameter is not supported in Gemini API.\");\n    }\n    const fromCategory = getValueByPath(fromObject, [\n        \"category\"\n    ]);\n    if (fromCategory != null) {\n        setValueByPath(toObject, [\n            \"category\"\n        ], fromCategory);\n    }\n    const fromThreshold = getValueByPath(fromObject, [\n        \"threshold\"\n    ]);\n    if (fromThreshold != null) {\n        setValueByPath(toObject, [\n            \"threshold\"\n        ], fromThreshold);\n    }\n    return toObject;\n}\nfunction functionDeclarationToMldev(apiClient, fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"response\"\n    ]) !== undefined) {\n        throw new Error(\"response parameter is not supported in Gemini API.\");\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, [\n        \"parameters\"\n    ]);\n    if (fromParameters != null) {\n        setValueByPath(toObject, [\n            \"parameters\"\n        ], fromParameters);\n    }\n    return toObject;\n}\nfunction googleSearchToMldev() {\n    const toObject = {};\n    return toObject;\n}\nfunction dynamicRetrievalConfigToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromDynamicThreshold = getValueByPath(fromObject, [\n        \"dynamicThreshold\"\n    ]);\n    if (fromDynamicThreshold != null) {\n        setValueByPath(toObject, [\n            \"dynamicThreshold\"\n        ], fromDynamicThreshold);\n    }\n    return toObject;\n}\nfunction googleSearchRetrievalToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromDynamicRetrievalConfig = getValueByPath(fromObject, [\n        \"dynamicRetrievalConfig\"\n    ]);\n    if (fromDynamicRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"dynamicRetrievalConfig\"\n        ], dynamicRetrievalConfigToMldev(apiClient, fromDynamicRetrievalConfig));\n    }\n    return toObject;\n}\nfunction toolToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        if (Array.isArray(fromFunctionDeclarations)) {\n            setValueByPath(toObject, [\n                \"functionDeclarations\"\n            ], fromFunctionDeclarations.map((item)=>{\n                return functionDeclarationToMldev(apiClient, item);\n            }));\n        } else {\n            setValueByPath(toObject, [\n                \"functionDeclarations\"\n            ], fromFunctionDeclarations);\n        }\n    }\n    if (getValueByPath(fromObject, [\n        \"retrieval\"\n    ]) !== undefined) {\n        throw new Error(\"retrieval parameter is not supported in Gemini API.\");\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], googleSearchToMldev());\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], googleSearchRetrievalToMldev(apiClient, fromGoogleSearchRetrieval));\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    return toObject;\n}\nfunction functionCallingConfigToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromAllowedFunctionNames = getValueByPath(fromObject, [\n        \"allowedFunctionNames\"\n    ]);\n    if (fromAllowedFunctionNames != null) {\n        setValueByPath(toObject, [\n            \"allowedFunctionNames\"\n        ], fromAllowedFunctionNames);\n    }\n    return toObject;\n}\nfunction toolConfigToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromFunctionCallingConfig = getValueByPath(fromObject, [\n        \"functionCallingConfig\"\n    ]);\n    if (fromFunctionCallingConfig != null) {\n        setValueByPath(toObject, [\n            \"functionCallingConfig\"\n        ], functionCallingConfigToMldev(apiClient, fromFunctionCallingConfig));\n    }\n    return toObject;\n}\nfunction prebuiltVoiceConfigToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromVoiceName = getValueByPath(fromObject, [\n        \"voiceName\"\n    ]);\n    if (fromVoiceName != null) {\n        setValueByPath(toObject, [\n            \"voiceName\"\n        ], fromVoiceName);\n    }\n    return toObject;\n}\nfunction voiceConfigToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromPrebuiltVoiceConfig = getValueByPath(fromObject, [\n        \"prebuiltVoiceConfig\"\n    ]);\n    if (fromPrebuiltVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"prebuiltVoiceConfig\"\n        ], prebuiltVoiceConfigToMldev(apiClient, fromPrebuiltVoiceConfig));\n    }\n    return toObject;\n}\nfunction speechConfigToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromVoiceConfig = getValueByPath(fromObject, [\n        \"voiceConfig\"\n    ]);\n    if (fromVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"voiceConfig\"\n        ], voiceConfigToMldev(apiClient, fromVoiceConfig));\n    }\n    const fromLanguageCode = getValueByPath(fromObject, [\n        \"languageCode\"\n    ]);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, [\n            \"languageCode\"\n        ], fromLanguageCode);\n    }\n    return toObject;\n}\nfunction thinkingConfigToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromIncludeThoughts = getValueByPath(fromObject, [\n        \"includeThoughts\"\n    ]);\n    if (fromIncludeThoughts != null) {\n        setValueByPath(toObject, [\n            \"includeThoughts\"\n        ], fromIncludeThoughts);\n    }\n    const fromThinkingBudget = getValueByPath(fromObject, [\n        \"thinkingBudget\"\n    ]);\n    if (fromThinkingBudget != null) {\n        setValueByPath(toObject, [\n            \"thinkingBudget\"\n        ], fromThinkingBudget);\n    }\n    return toObject;\n}\nfunction generateContentConfigToMldev(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"systemInstruction\"\n        ], contentToMldev(apiClient, tContent(apiClient, fromSystemInstruction)));\n    }\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, [\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, [\n        \"topP\"\n    ]);\n    if (fromTopP != null) {\n        setValueByPath(toObject, [\n            \"topP\"\n        ], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (fromTopK != null) {\n        setValueByPath(toObject, [\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromCandidateCount = getValueByPath(fromObject, [\n        \"candidateCount\"\n    ]);\n    if (fromCandidateCount != null) {\n        setValueByPath(toObject, [\n            \"candidateCount\"\n        ], fromCandidateCount);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        \"maxOutputTokens\"\n    ]);\n    if (fromMaxOutputTokens != null) {\n        setValueByPath(toObject, [\n            \"maxOutputTokens\"\n        ], fromMaxOutputTokens);\n    }\n    const fromStopSequences = getValueByPath(fromObject, [\n        \"stopSequences\"\n    ]);\n    if (fromStopSequences != null) {\n        setValueByPath(toObject, [\n            \"stopSequences\"\n        ], fromStopSequences);\n    }\n    const fromResponseLogprobs = getValueByPath(fromObject, [\n        \"responseLogprobs\"\n    ]);\n    if (fromResponseLogprobs != null) {\n        setValueByPath(toObject, [\n            \"responseLogprobs\"\n        ], fromResponseLogprobs);\n    }\n    const fromLogprobs = getValueByPath(fromObject, [\n        \"logprobs\"\n    ]);\n    if (fromLogprobs != null) {\n        setValueByPath(toObject, [\n            \"logprobs\"\n        ], fromLogprobs);\n    }\n    const fromPresencePenalty = getValueByPath(fromObject, [\n        \"presencePenalty\"\n    ]);\n    if (fromPresencePenalty != null) {\n        setValueByPath(toObject, [\n            \"presencePenalty\"\n        ], fromPresencePenalty);\n    }\n    const fromFrequencyPenalty = getValueByPath(fromObject, [\n        \"frequencyPenalty\"\n    ]);\n    if (fromFrequencyPenalty != null) {\n        setValueByPath(toObject, [\n            \"frequencyPenalty\"\n        ], fromFrequencyPenalty);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (fromSeed != null) {\n        setValueByPath(toObject, [\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromResponseMimeType = getValueByPath(fromObject, [\n        \"responseMimeType\"\n    ]);\n    if (fromResponseMimeType != null) {\n        setValueByPath(toObject, [\n            \"responseMimeType\"\n        ], fromResponseMimeType);\n    }\n    const fromResponseSchema = getValueByPath(fromObject, [\n        \"responseSchema\"\n    ]);\n    if (fromResponseSchema != null) {\n        setValueByPath(toObject, [\n            \"responseSchema\"\n        ], schemaToMldev(apiClient, tSchema(apiClient, fromResponseSchema)));\n    }\n    if (getValueByPath(fromObject, [\n        \"routingConfig\"\n    ]) !== undefined) {\n        throw new Error(\"routingConfig parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"modelSelectionConfig\"\n    ]) !== undefined) {\n        throw new Error(\"modelSelectionConfig parameter is not supported in Gemini API.\");\n    }\n    const fromSafetySettings = getValueByPath(fromObject, [\n        \"safetySettings\"\n    ]);\n    if (parentObject !== undefined && fromSafetySettings != null) {\n        if (Array.isArray(fromSafetySettings)) {\n            setValueByPath(parentObject, [\n                \"safetySettings\"\n            ], fromSafetySettings.map((item)=>{\n                return safetySettingToMldev(apiClient, item);\n            }));\n        } else {\n            setValueByPath(parentObject, [\n                \"safetySettings\"\n            ], fromSafetySettings);\n        }\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        if (Array.isArray(fromTools)) {\n            setValueByPath(parentObject, [\n                \"tools\"\n            ], tTools(apiClient, tTools(apiClient, fromTools).map((item)=>{\n                return toolToMldev(apiClient, tTool(apiClient, item));\n            })));\n        } else {\n            setValueByPath(parentObject, [\n                \"tools\"\n            ], tTools(apiClient, fromTools));\n        }\n    }\n    const fromToolConfig = getValueByPath(fromObject, [\n        \"toolConfig\"\n    ]);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, [\n            \"toolConfig\"\n        ], toolConfigToMldev(apiClient, fromToolConfig));\n    }\n    if (getValueByPath(fromObject, [\n        \"labels\"\n    ]) !== undefined) {\n        throw new Error(\"labels parameter is not supported in Gemini API.\");\n    }\n    const fromCachedContent = getValueByPath(fromObject, [\n        \"cachedContent\"\n    ]);\n    if (parentObject !== undefined && fromCachedContent != null) {\n        setValueByPath(parentObject, [\n            \"cachedContent\"\n        ], tCachedContentName(apiClient, fromCachedContent));\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        \"responseModalities\"\n    ]);\n    if (fromResponseModalities != null) {\n        setValueByPath(toObject, [\n            \"responseModalities\"\n        ], fromResponseModalities);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, [\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, [\n        \"speechConfig\"\n    ]);\n    if (fromSpeechConfig != null) {\n        setValueByPath(toObject, [\n            \"speechConfig\"\n        ], speechConfigToMldev(apiClient, tSpeechConfig(apiClient, fromSpeechConfig)));\n    }\n    if (getValueByPath(fromObject, [\n        \"audioTimestamp\"\n    ]) !== undefined) {\n        throw new Error(\"audioTimestamp parameter is not supported in Gemini API.\");\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        \"thinkingConfig\"\n    ]);\n    if (fromThinkingConfig != null) {\n        setValueByPath(toObject, [\n            \"thinkingConfig\"\n        ], thinkingConfigToMldev(apiClient, fromThinkingConfig));\n    }\n    return toObject;\n}\nfunction generateContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        if (Array.isArray(fromContents)) {\n            setValueByPath(toObject, [\n                \"contents\"\n            ], tContents(apiClient, tContents(apiClient, fromContents).map((item)=>{\n                return contentToMldev(apiClient, item);\n            })));\n        } else {\n            setValueByPath(toObject, [\n                \"contents\"\n            ], tContents(apiClient, fromContents));\n        }\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"generationConfig\"\n        ], generateContentConfigToMldev(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction embedContentConfigToMldev(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromTaskType = getValueByPath(fromObject, [\n        \"taskType\"\n    ]);\n    if (parentObject !== undefined && fromTaskType != null) {\n        setValueByPath(parentObject, [\n            \"requests[]\",\n            \"taskType\"\n        ], fromTaskType);\n    }\n    const fromTitle = getValueByPath(fromObject, [\n        \"title\"\n    ]);\n    if (parentObject !== undefined && fromTitle != null) {\n        setValueByPath(parentObject, [\n            \"requests[]\",\n            \"title\"\n        ], fromTitle);\n    }\n    const fromOutputDimensionality = getValueByPath(fromObject, [\n        \"outputDimensionality\"\n    ]);\n    if (parentObject !== undefined && fromOutputDimensionality != null) {\n        setValueByPath(parentObject, [\n            \"requests[]\",\n            \"outputDimensionality\"\n        ], fromOutputDimensionality);\n    }\n    if (getValueByPath(fromObject, [\n        \"mimeType\"\n    ]) !== undefined) {\n        throw new Error(\"mimeType parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"autoTruncate\"\n    ]) !== undefined) {\n        throw new Error(\"autoTruncate parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction embedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        setValueByPath(toObject, [\n            \"requests[]\",\n            \"content\"\n        ], tContentsForEmbed(apiClient, fromContents));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], embedContentConfigToMldev(apiClient, fromConfig, toObject));\n    }\n    const fromModelForEmbedContent = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModelForEmbedContent !== undefined) {\n        setValueByPath(toObject, [\n            \"requests[]\",\n            \"model\"\n        ], tModel(apiClient, fromModelForEmbedContent));\n    }\n    return toObject;\n}\nfunction generateImagesConfigToMldev(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"outputGcsUri\"\n    ]) !== undefined) {\n        throw new Error(\"outputGcsUri parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"negativePrompt\"\n    ]) !== undefined) {\n        throw new Error(\"negativePrompt parameter is not supported in Gemini API.\");\n    }\n    const fromNumberOfImages = getValueByPath(fromObject, [\n        \"numberOfImages\"\n    ]);\n    if (parentObject !== undefined && fromNumberOfImages != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleCount\"\n        ], fromNumberOfImages);\n    }\n    const fromAspectRatio = getValueByPath(fromObject, [\n        \"aspectRatio\"\n    ]);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"aspectRatio\"\n        ], fromAspectRatio);\n    }\n    const fromGuidanceScale = getValueByPath(fromObject, [\n        \"guidanceScale\"\n    ]);\n    if (parentObject !== undefined && fromGuidanceScale != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"guidanceScale\"\n        ], fromGuidanceScale);\n    }\n    if (getValueByPath(fromObject, [\n        \"seed\"\n    ]) !== undefined) {\n        throw new Error(\"seed parameter is not supported in Gemini API.\");\n    }\n    const fromSafetyFilterLevel = getValueByPath(fromObject, [\n        \"safetyFilterLevel\"\n    ]);\n    if (parentObject !== undefined && fromSafetyFilterLevel != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"safetySetting\"\n        ], fromSafetyFilterLevel);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        \"personGeneration\"\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"personGeneration\"\n        ], fromPersonGeneration);\n    }\n    const fromIncludeSafetyAttributes = getValueByPath(fromObject, [\n        \"includeSafetyAttributes\"\n    ]);\n    if (parentObject !== undefined && fromIncludeSafetyAttributes != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"includeSafetyAttributes\"\n        ], fromIncludeSafetyAttributes);\n    }\n    const fromIncludeRaiReason = getValueByPath(fromObject, [\n        \"includeRaiReason\"\n    ]);\n    if (parentObject !== undefined && fromIncludeRaiReason != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"includeRaiReason\"\n        ], fromIncludeRaiReason);\n    }\n    const fromLanguage = getValueByPath(fromObject, [\n        \"language\"\n    ]);\n    if (parentObject !== undefined && fromLanguage != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"language\"\n        ], fromLanguage);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        \"outputMimeType\"\n    ]);\n    if (parentObject !== undefined && fromOutputMimeType != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"mimeType\"\n        ], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        \"outputCompressionQuality\"\n    ]);\n    if (parentObject !== undefined && fromOutputCompressionQuality != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"compressionQuality\"\n        ], fromOutputCompressionQuality);\n    }\n    if (getValueByPath(fromObject, [\n        \"addWatermark\"\n    ]) !== undefined) {\n        throw new Error(\"addWatermark parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"enhancePrompt\"\n    ]) !== undefined) {\n        throw new Error(\"enhancePrompt parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction generateImagesParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"prompt\"\n        ], fromPrompt);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], generateImagesConfigToMldev(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction getModelParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction countTokensConfigToMldev(apiClient, fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]) !== undefined) {\n        throw new Error(\"systemInstruction parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"tools\"\n    ]) !== undefined) {\n        throw new Error(\"tools parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"generationConfig\"\n    ]) !== undefined) {\n        throw new Error(\"generationConfig parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction countTokensParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        if (Array.isArray(fromContents)) {\n            setValueByPath(toObject, [\n                \"contents\"\n            ], tContents(apiClient, tContents(apiClient, fromContents).map((item)=>{\n                return contentToMldev(apiClient, item);\n            })));\n        } else {\n            setValueByPath(toObject, [\n                \"contents\"\n            ], tContents(apiClient, fromContents));\n        }\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], countTokensConfigToMldev(apiClient, fromConfig));\n    }\n    return toObject;\n}\nfunction imageToMldev(apiClient, fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]) !== undefined) {\n        throw new Error(\"gcsUri parameter is not supported in Gemini API.\");\n    }\n    const fromImageBytes = getValueByPath(fromObject, [\n        \"imageBytes\"\n    ]);\n    if (fromImageBytes != null) {\n        setValueByPath(toObject, [\n            \"bytesBase64Encoded\"\n        ], tBytes(apiClient, fromImageBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction generateVideosConfigToMldev(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromNumberOfVideos = getValueByPath(fromObject, [\n        \"numberOfVideos\"\n    ]);\n    if (parentObject !== undefined && fromNumberOfVideos != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleCount\"\n        ], fromNumberOfVideos);\n    }\n    if (getValueByPath(fromObject, [\n        \"outputGcsUri\"\n    ]) !== undefined) {\n        throw new Error(\"outputGcsUri parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"fps\"\n    ]) !== undefined) {\n        throw new Error(\"fps parameter is not supported in Gemini API.\");\n    }\n    const fromDurationSeconds = getValueByPath(fromObject, [\n        \"durationSeconds\"\n    ]);\n    if (parentObject !== undefined && fromDurationSeconds != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"durationSeconds\"\n        ], fromDurationSeconds);\n    }\n    if (getValueByPath(fromObject, [\n        \"seed\"\n    ]) !== undefined) {\n        throw new Error(\"seed parameter is not supported in Gemini API.\");\n    }\n    const fromAspectRatio = getValueByPath(fromObject, [\n        \"aspectRatio\"\n    ]);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"aspectRatio\"\n        ], fromAspectRatio);\n    }\n    if (getValueByPath(fromObject, [\n        \"resolution\"\n    ]) !== undefined) {\n        throw new Error(\"resolution parameter is not supported in Gemini API.\");\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        \"personGeneration\"\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"personGeneration\"\n        ], fromPersonGeneration);\n    }\n    if (getValueByPath(fromObject, [\n        \"pubsubTopic\"\n    ]) !== undefined) {\n        throw new Error(\"pubsubTopic parameter is not supported in Gemini API.\");\n    }\n    const fromNegativePrompt = getValueByPath(fromObject, [\n        \"negativePrompt\"\n    ]);\n    if (parentObject !== undefined && fromNegativePrompt != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"negativePrompt\"\n        ], fromNegativePrompt);\n    }\n    if (getValueByPath(fromObject, [\n        \"enhancePrompt\"\n    ]) !== undefined) {\n        throw new Error(\"enhancePrompt parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction generateVideosParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"prompt\"\n        ], fromPrompt);\n    }\n    const fromImage = getValueByPath(fromObject, [\n        \"image\"\n    ]);\n    if (fromImage != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"image\"\n        ], imageToMldev(apiClient, fromImage));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], generateVideosConfigToMldev(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction partToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], fromVideoMetadata);\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fromFileData);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], fromFunctionCall);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], fromInlineData);\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    return toObject;\n}\nfunction contentToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        if (Array.isArray(fromParts)) {\n            setValueByPath(toObject, [\n                \"parts\"\n            ], fromParts.map((item)=>{\n                return partToVertex(apiClient, item);\n            }));\n        } else {\n            setValueByPath(toObject, [\n                \"parts\"\n            ], fromParts);\n        }\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction schemaToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromExample = getValueByPath(fromObject, [\n        \"example\"\n    ]);\n    if (fromExample != null) {\n        setValueByPath(toObject, [\n            \"example\"\n        ], fromExample);\n    }\n    const fromPattern = getValueByPath(fromObject, [\n        \"pattern\"\n    ]);\n    if (fromPattern != null) {\n        setValueByPath(toObject, [\n            \"pattern\"\n        ], fromPattern);\n    }\n    const fromDefault = getValueByPath(fromObject, [\n        \"default\"\n    ]);\n    if (fromDefault != null) {\n        setValueByPath(toObject, [\n            \"default\"\n        ], fromDefault);\n    }\n    const fromMaxLength = getValueByPath(fromObject, [\n        \"maxLength\"\n    ]);\n    if (fromMaxLength != null) {\n        setValueByPath(toObject, [\n            \"maxLength\"\n        ], fromMaxLength);\n    }\n    const fromMinLength = getValueByPath(fromObject, [\n        \"minLength\"\n    ]);\n    if (fromMinLength != null) {\n        setValueByPath(toObject, [\n            \"minLength\"\n        ], fromMinLength);\n    }\n    const fromMinProperties = getValueByPath(fromObject, [\n        \"minProperties\"\n    ]);\n    if (fromMinProperties != null) {\n        setValueByPath(toObject, [\n            \"minProperties\"\n        ], fromMinProperties);\n    }\n    const fromMaxProperties = getValueByPath(fromObject, [\n        \"maxProperties\"\n    ]);\n    if (fromMaxProperties != null) {\n        setValueByPath(toObject, [\n            \"maxProperties\"\n        ], fromMaxProperties);\n    }\n    const fromAnyOf = getValueByPath(fromObject, [\n        \"anyOf\"\n    ]);\n    if (fromAnyOf != null) {\n        setValueByPath(toObject, [\n            \"anyOf\"\n        ], fromAnyOf);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromEnum = getValueByPath(fromObject, [\n        \"enum\"\n    ]);\n    if (fromEnum != null) {\n        setValueByPath(toObject, [\n            \"enum\"\n        ], fromEnum);\n    }\n    const fromFormat = getValueByPath(fromObject, [\n        \"format\"\n    ]);\n    if (fromFormat != null) {\n        setValueByPath(toObject, [\n            \"format\"\n        ], fromFormat);\n    }\n    const fromItems = getValueByPath(fromObject, [\n        \"items\"\n    ]);\n    if (fromItems != null) {\n        setValueByPath(toObject, [\n            \"items\"\n        ], fromItems);\n    }\n    const fromMaxItems = getValueByPath(fromObject, [\n        \"maxItems\"\n    ]);\n    if (fromMaxItems != null) {\n        setValueByPath(toObject, [\n            \"maxItems\"\n        ], fromMaxItems);\n    }\n    const fromMaximum = getValueByPath(fromObject, [\n        \"maximum\"\n    ]);\n    if (fromMaximum != null) {\n        setValueByPath(toObject, [\n            \"maximum\"\n        ], fromMaximum);\n    }\n    const fromMinItems = getValueByPath(fromObject, [\n        \"minItems\"\n    ]);\n    if (fromMinItems != null) {\n        setValueByPath(toObject, [\n            \"minItems\"\n        ], fromMinItems);\n    }\n    const fromMinimum = getValueByPath(fromObject, [\n        \"minimum\"\n    ]);\n    if (fromMinimum != null) {\n        setValueByPath(toObject, [\n            \"minimum\"\n        ], fromMinimum);\n    }\n    const fromNullable = getValueByPath(fromObject, [\n        \"nullable\"\n    ]);\n    if (fromNullable != null) {\n        setValueByPath(toObject, [\n            \"nullable\"\n        ], fromNullable);\n    }\n    const fromProperties = getValueByPath(fromObject, [\n        \"properties\"\n    ]);\n    if (fromProperties != null) {\n        setValueByPath(toObject, [\n            \"properties\"\n        ], fromProperties);\n    }\n    const fromPropertyOrdering = getValueByPath(fromObject, [\n        \"propertyOrdering\"\n    ]);\n    if (fromPropertyOrdering != null) {\n        setValueByPath(toObject, [\n            \"propertyOrdering\"\n        ], fromPropertyOrdering);\n    }\n    const fromRequired = getValueByPath(fromObject, [\n        \"required\"\n    ]);\n    if (fromRequired != null) {\n        setValueByPath(toObject, [\n            \"required\"\n        ], fromRequired);\n    }\n    const fromTitle = getValueByPath(fromObject, [\n        \"title\"\n    ]);\n    if (fromTitle != null) {\n        setValueByPath(toObject, [\n            \"title\"\n        ], fromTitle);\n    }\n    const fromType = getValueByPath(fromObject, [\n        \"type\"\n    ]);\n    if (fromType != null) {\n        setValueByPath(toObject, [\n            \"type\"\n        ], fromType);\n    }\n    return toObject;\n}\nfunction modelSelectionConfigToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromFeatureSelectionPreference = getValueByPath(fromObject, [\n        \"featureSelectionPreference\"\n    ]);\n    if (fromFeatureSelectionPreference != null) {\n        setValueByPath(toObject, [\n            \"featureSelectionPreference\"\n        ], fromFeatureSelectionPreference);\n    }\n    return toObject;\n}\nfunction safetySettingToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromMethod = getValueByPath(fromObject, [\n        \"method\"\n    ]);\n    if (fromMethod != null) {\n        setValueByPath(toObject, [\n            \"method\"\n        ], fromMethod);\n    }\n    const fromCategory = getValueByPath(fromObject, [\n        \"category\"\n    ]);\n    if (fromCategory != null) {\n        setValueByPath(toObject, [\n            \"category\"\n        ], fromCategory);\n    }\n    const fromThreshold = getValueByPath(fromObject, [\n        \"threshold\"\n    ]);\n    if (fromThreshold != null) {\n        setValueByPath(toObject, [\n            \"threshold\"\n        ], fromThreshold);\n    }\n    return toObject;\n}\nfunction functionDeclarationToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], schemaToVertex(apiClient, fromResponse));\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, [\n        \"parameters\"\n    ]);\n    if (fromParameters != null) {\n        setValueByPath(toObject, [\n            \"parameters\"\n        ], fromParameters);\n    }\n    return toObject;\n}\nfunction googleSearchToVertex() {\n    const toObject = {};\n    return toObject;\n}\nfunction dynamicRetrievalConfigToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromDynamicThreshold = getValueByPath(fromObject, [\n        \"dynamicThreshold\"\n    ]);\n    if (fromDynamicThreshold != null) {\n        setValueByPath(toObject, [\n            \"dynamicThreshold\"\n        ], fromDynamicThreshold);\n    }\n    return toObject;\n}\nfunction googleSearchRetrievalToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromDynamicRetrievalConfig = getValueByPath(fromObject, [\n        \"dynamicRetrievalConfig\"\n    ]);\n    if (fromDynamicRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"dynamicRetrievalConfig\"\n        ], dynamicRetrievalConfigToVertex(apiClient, fromDynamicRetrievalConfig));\n    }\n    return toObject;\n}\nfunction toolToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        if (Array.isArray(fromFunctionDeclarations)) {\n            setValueByPath(toObject, [\n                \"functionDeclarations\"\n            ], fromFunctionDeclarations.map((item)=>{\n                return functionDeclarationToVertex(apiClient, item);\n            }));\n        } else {\n            setValueByPath(toObject, [\n                \"functionDeclarations\"\n            ], fromFunctionDeclarations);\n        }\n    }\n    const fromRetrieval = getValueByPath(fromObject, [\n        \"retrieval\"\n    ]);\n    if (fromRetrieval != null) {\n        setValueByPath(toObject, [\n            \"retrieval\"\n        ], fromRetrieval);\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], googleSearchToVertex());\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], googleSearchRetrievalToVertex(apiClient, fromGoogleSearchRetrieval));\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    return toObject;\n}\nfunction functionCallingConfigToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromAllowedFunctionNames = getValueByPath(fromObject, [\n        \"allowedFunctionNames\"\n    ]);\n    if (fromAllowedFunctionNames != null) {\n        setValueByPath(toObject, [\n            \"allowedFunctionNames\"\n        ], fromAllowedFunctionNames);\n    }\n    return toObject;\n}\nfunction toolConfigToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromFunctionCallingConfig = getValueByPath(fromObject, [\n        \"functionCallingConfig\"\n    ]);\n    if (fromFunctionCallingConfig != null) {\n        setValueByPath(toObject, [\n            \"functionCallingConfig\"\n        ], functionCallingConfigToVertex(apiClient, fromFunctionCallingConfig));\n    }\n    return toObject;\n}\nfunction prebuiltVoiceConfigToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromVoiceName = getValueByPath(fromObject, [\n        \"voiceName\"\n    ]);\n    if (fromVoiceName != null) {\n        setValueByPath(toObject, [\n            \"voiceName\"\n        ], fromVoiceName);\n    }\n    return toObject;\n}\nfunction voiceConfigToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromPrebuiltVoiceConfig = getValueByPath(fromObject, [\n        \"prebuiltVoiceConfig\"\n    ]);\n    if (fromPrebuiltVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"prebuiltVoiceConfig\"\n        ], prebuiltVoiceConfigToVertex(apiClient, fromPrebuiltVoiceConfig));\n    }\n    return toObject;\n}\nfunction speechConfigToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromVoiceConfig = getValueByPath(fromObject, [\n        \"voiceConfig\"\n    ]);\n    if (fromVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"voiceConfig\"\n        ], voiceConfigToVertex(apiClient, fromVoiceConfig));\n    }\n    const fromLanguageCode = getValueByPath(fromObject, [\n        \"languageCode\"\n    ]);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, [\n            \"languageCode\"\n        ], fromLanguageCode);\n    }\n    return toObject;\n}\nfunction thinkingConfigToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromIncludeThoughts = getValueByPath(fromObject, [\n        \"includeThoughts\"\n    ]);\n    if (fromIncludeThoughts != null) {\n        setValueByPath(toObject, [\n            \"includeThoughts\"\n        ], fromIncludeThoughts);\n    }\n    const fromThinkingBudget = getValueByPath(fromObject, [\n        \"thinkingBudget\"\n    ]);\n    if (fromThinkingBudget != null) {\n        setValueByPath(toObject, [\n            \"thinkingBudget\"\n        ], fromThinkingBudget);\n    }\n    return toObject;\n}\nfunction generateContentConfigToVertex(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"systemInstruction\"\n        ], contentToVertex(apiClient, tContent(apiClient, fromSystemInstruction)));\n    }\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, [\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, [\n        \"topP\"\n    ]);\n    if (fromTopP != null) {\n        setValueByPath(toObject, [\n            \"topP\"\n        ], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (fromTopK != null) {\n        setValueByPath(toObject, [\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromCandidateCount = getValueByPath(fromObject, [\n        \"candidateCount\"\n    ]);\n    if (fromCandidateCount != null) {\n        setValueByPath(toObject, [\n            \"candidateCount\"\n        ], fromCandidateCount);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        \"maxOutputTokens\"\n    ]);\n    if (fromMaxOutputTokens != null) {\n        setValueByPath(toObject, [\n            \"maxOutputTokens\"\n        ], fromMaxOutputTokens);\n    }\n    const fromStopSequences = getValueByPath(fromObject, [\n        \"stopSequences\"\n    ]);\n    if (fromStopSequences != null) {\n        setValueByPath(toObject, [\n            \"stopSequences\"\n        ], fromStopSequences);\n    }\n    const fromResponseLogprobs = getValueByPath(fromObject, [\n        \"responseLogprobs\"\n    ]);\n    if (fromResponseLogprobs != null) {\n        setValueByPath(toObject, [\n            \"responseLogprobs\"\n        ], fromResponseLogprobs);\n    }\n    const fromLogprobs = getValueByPath(fromObject, [\n        \"logprobs\"\n    ]);\n    if (fromLogprobs != null) {\n        setValueByPath(toObject, [\n            \"logprobs\"\n        ], fromLogprobs);\n    }\n    const fromPresencePenalty = getValueByPath(fromObject, [\n        \"presencePenalty\"\n    ]);\n    if (fromPresencePenalty != null) {\n        setValueByPath(toObject, [\n            \"presencePenalty\"\n        ], fromPresencePenalty);\n    }\n    const fromFrequencyPenalty = getValueByPath(fromObject, [\n        \"frequencyPenalty\"\n    ]);\n    if (fromFrequencyPenalty != null) {\n        setValueByPath(toObject, [\n            \"frequencyPenalty\"\n        ], fromFrequencyPenalty);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (fromSeed != null) {\n        setValueByPath(toObject, [\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromResponseMimeType = getValueByPath(fromObject, [\n        \"responseMimeType\"\n    ]);\n    if (fromResponseMimeType != null) {\n        setValueByPath(toObject, [\n            \"responseMimeType\"\n        ], fromResponseMimeType);\n    }\n    const fromResponseSchema = getValueByPath(fromObject, [\n        \"responseSchema\"\n    ]);\n    if (fromResponseSchema != null) {\n        setValueByPath(toObject, [\n            \"responseSchema\"\n        ], schemaToVertex(apiClient, tSchema(apiClient, fromResponseSchema)));\n    }\n    const fromRoutingConfig = getValueByPath(fromObject, [\n        \"routingConfig\"\n    ]);\n    if (fromRoutingConfig != null) {\n        setValueByPath(toObject, [\n            \"routingConfig\"\n        ], fromRoutingConfig);\n    }\n    const fromModelSelectionConfig = getValueByPath(fromObject, [\n        \"modelSelectionConfig\"\n    ]);\n    if (fromModelSelectionConfig != null) {\n        setValueByPath(toObject, [\n            \"modelConfig\"\n        ], modelSelectionConfigToVertex(apiClient, fromModelSelectionConfig));\n    }\n    const fromSafetySettings = getValueByPath(fromObject, [\n        \"safetySettings\"\n    ]);\n    if (parentObject !== undefined && fromSafetySettings != null) {\n        if (Array.isArray(fromSafetySettings)) {\n            setValueByPath(parentObject, [\n                \"safetySettings\"\n            ], fromSafetySettings.map((item)=>{\n                return safetySettingToVertex(apiClient, item);\n            }));\n        } else {\n            setValueByPath(parentObject, [\n                \"safetySettings\"\n            ], fromSafetySettings);\n        }\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        if (Array.isArray(fromTools)) {\n            setValueByPath(parentObject, [\n                \"tools\"\n            ], tTools(apiClient, tTools(apiClient, fromTools).map((item)=>{\n                return toolToVertex(apiClient, tTool(apiClient, item));\n            })));\n        } else {\n            setValueByPath(parentObject, [\n                \"tools\"\n            ], tTools(apiClient, fromTools));\n        }\n    }\n    const fromToolConfig = getValueByPath(fromObject, [\n        \"toolConfig\"\n    ]);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, [\n            \"toolConfig\"\n        ], toolConfigToVertex(apiClient, fromToolConfig));\n    }\n    const fromLabels = getValueByPath(fromObject, [\n        \"labels\"\n    ]);\n    if (parentObject !== undefined && fromLabels != null) {\n        setValueByPath(parentObject, [\n            \"labels\"\n        ], fromLabels);\n    }\n    const fromCachedContent = getValueByPath(fromObject, [\n        \"cachedContent\"\n    ]);\n    if (parentObject !== undefined && fromCachedContent != null) {\n        setValueByPath(parentObject, [\n            \"cachedContent\"\n        ], tCachedContentName(apiClient, fromCachedContent));\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        \"responseModalities\"\n    ]);\n    if (fromResponseModalities != null) {\n        setValueByPath(toObject, [\n            \"responseModalities\"\n        ], fromResponseModalities);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, [\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, [\n        \"speechConfig\"\n    ]);\n    if (fromSpeechConfig != null) {\n        setValueByPath(toObject, [\n            \"speechConfig\"\n        ], speechConfigToVertex(apiClient, tSpeechConfig(apiClient, fromSpeechConfig)));\n    }\n    const fromAudioTimestamp = getValueByPath(fromObject, [\n        \"audioTimestamp\"\n    ]);\n    if (fromAudioTimestamp != null) {\n        setValueByPath(toObject, [\n            \"audioTimestamp\"\n        ], fromAudioTimestamp);\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        \"thinkingConfig\"\n    ]);\n    if (fromThinkingConfig != null) {\n        setValueByPath(toObject, [\n            \"thinkingConfig\"\n        ], thinkingConfigToVertex(apiClient, fromThinkingConfig));\n    }\n    return toObject;\n}\nfunction generateContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        if (Array.isArray(fromContents)) {\n            setValueByPath(toObject, [\n                \"contents\"\n            ], tContents(apiClient, tContents(apiClient, fromContents).map((item)=>{\n                return contentToVertex(apiClient, item);\n            })));\n        } else {\n            setValueByPath(toObject, [\n                \"contents\"\n            ], tContents(apiClient, fromContents));\n        }\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"generationConfig\"\n        ], generateContentConfigToVertex(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction embedContentConfigToVertex(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromTaskType = getValueByPath(fromObject, [\n        \"taskType\"\n    ]);\n    if (parentObject !== undefined && fromTaskType != null) {\n        setValueByPath(parentObject, [\n            \"instances[]\",\n            \"task_type\"\n        ], fromTaskType);\n    }\n    const fromTitle = getValueByPath(fromObject, [\n        \"title\"\n    ]);\n    if (parentObject !== undefined && fromTitle != null) {\n        setValueByPath(parentObject, [\n            \"instances[]\",\n            \"title\"\n        ], fromTitle);\n    }\n    const fromOutputDimensionality = getValueByPath(fromObject, [\n        \"outputDimensionality\"\n    ]);\n    if (parentObject !== undefined && fromOutputDimensionality != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputDimensionality\"\n        ], fromOutputDimensionality);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (parentObject !== undefined && fromMimeType != null) {\n        setValueByPath(parentObject, [\n            \"instances[]\",\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    const fromAutoTruncate = getValueByPath(fromObject, [\n        \"autoTruncate\"\n    ]);\n    if (parentObject !== undefined && fromAutoTruncate != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"autoTruncate\"\n        ], fromAutoTruncate);\n    }\n    return toObject;\n}\nfunction embedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        setValueByPath(toObject, [\n            \"instances[]\",\n            \"content\"\n        ], tContentsForEmbed(apiClient, fromContents));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], embedContentConfigToVertex(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction generateImagesConfigToVertex(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromOutputGcsUri = getValueByPath(fromObject, [\n        \"outputGcsUri\"\n    ]);\n    if (parentObject !== undefined && fromOutputGcsUri != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"storageUri\"\n        ], fromOutputGcsUri);\n    }\n    const fromNegativePrompt = getValueByPath(fromObject, [\n        \"negativePrompt\"\n    ]);\n    if (parentObject !== undefined && fromNegativePrompt != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"negativePrompt\"\n        ], fromNegativePrompt);\n    }\n    const fromNumberOfImages = getValueByPath(fromObject, [\n        \"numberOfImages\"\n    ]);\n    if (parentObject !== undefined && fromNumberOfImages != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleCount\"\n        ], fromNumberOfImages);\n    }\n    const fromAspectRatio = getValueByPath(fromObject, [\n        \"aspectRatio\"\n    ]);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"aspectRatio\"\n        ], fromAspectRatio);\n    }\n    const fromGuidanceScale = getValueByPath(fromObject, [\n        \"guidanceScale\"\n    ]);\n    if (parentObject !== undefined && fromGuidanceScale != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"guidanceScale\"\n        ], fromGuidanceScale);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromSafetyFilterLevel = getValueByPath(fromObject, [\n        \"safetyFilterLevel\"\n    ]);\n    if (parentObject !== undefined && fromSafetyFilterLevel != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"safetySetting\"\n        ], fromSafetyFilterLevel);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        \"personGeneration\"\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"personGeneration\"\n        ], fromPersonGeneration);\n    }\n    const fromIncludeSafetyAttributes = getValueByPath(fromObject, [\n        \"includeSafetyAttributes\"\n    ]);\n    if (parentObject !== undefined && fromIncludeSafetyAttributes != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"includeSafetyAttributes\"\n        ], fromIncludeSafetyAttributes);\n    }\n    const fromIncludeRaiReason = getValueByPath(fromObject, [\n        \"includeRaiReason\"\n    ]);\n    if (parentObject !== undefined && fromIncludeRaiReason != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"includeRaiReason\"\n        ], fromIncludeRaiReason);\n    }\n    const fromLanguage = getValueByPath(fromObject, [\n        \"language\"\n    ]);\n    if (parentObject !== undefined && fromLanguage != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"language\"\n        ], fromLanguage);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        \"outputMimeType\"\n    ]);\n    if (parentObject !== undefined && fromOutputMimeType != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"mimeType\"\n        ], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        \"outputCompressionQuality\"\n    ]);\n    if (parentObject !== undefined && fromOutputCompressionQuality != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"compressionQuality\"\n        ], fromOutputCompressionQuality);\n    }\n    const fromAddWatermark = getValueByPath(fromObject, [\n        \"addWatermark\"\n    ]);\n    if (parentObject !== undefined && fromAddWatermark != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"addWatermark\"\n        ], fromAddWatermark);\n    }\n    const fromEnhancePrompt = getValueByPath(fromObject, [\n        \"enhancePrompt\"\n    ]);\n    if (parentObject !== undefined && fromEnhancePrompt != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"enhancePrompt\"\n        ], fromEnhancePrompt);\n    }\n    return toObject;\n}\nfunction generateImagesParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"prompt\"\n        ], fromPrompt);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], generateImagesConfigToVertex(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction getModelParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction countTokensConfigToVertex(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"systemInstruction\"\n        ], contentToVertex(apiClient, tContent(apiClient, fromSystemInstruction)));\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        if (Array.isArray(fromTools)) {\n            setValueByPath(parentObject, [\n                \"tools\"\n            ], fromTools.map((item)=>{\n                return toolToVertex(apiClient, item);\n            }));\n        } else {\n            setValueByPath(parentObject, [\n                \"tools\"\n            ], fromTools);\n        }\n    }\n    const fromGenerationConfig = getValueByPath(fromObject, [\n        \"generationConfig\"\n    ]);\n    if (parentObject !== undefined && fromGenerationConfig != null) {\n        setValueByPath(parentObject, [\n            \"generationConfig\"\n        ], fromGenerationConfig);\n    }\n    return toObject;\n}\nfunction countTokensParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        if (Array.isArray(fromContents)) {\n            setValueByPath(toObject, [\n                \"contents\"\n            ], tContents(apiClient, tContents(apiClient, fromContents).map((item)=>{\n                return contentToVertex(apiClient, item);\n            })));\n        } else {\n            setValueByPath(toObject, [\n                \"contents\"\n            ], tContents(apiClient, fromContents));\n        }\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], countTokensConfigToVertex(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction computeTokensParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        if (Array.isArray(fromContents)) {\n            setValueByPath(toObject, [\n                \"contents\"\n            ], tContents(apiClient, tContents(apiClient, fromContents).map((item)=>{\n                return contentToVertex(apiClient, item);\n            })));\n        } else {\n            setValueByPath(toObject, [\n                \"contents\"\n            ], tContents(apiClient, fromContents));\n        }\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction imageToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromGcsUri = getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, [\n            \"gcsUri\"\n        ], fromGcsUri);\n    }\n    const fromImageBytes = getValueByPath(fromObject, [\n        \"imageBytes\"\n    ]);\n    if (fromImageBytes != null) {\n        setValueByPath(toObject, [\n            \"bytesBase64Encoded\"\n        ], tBytes(apiClient, fromImageBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction generateVideosConfigToVertex(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromNumberOfVideos = getValueByPath(fromObject, [\n        \"numberOfVideos\"\n    ]);\n    if (parentObject !== undefined && fromNumberOfVideos != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleCount\"\n        ], fromNumberOfVideos);\n    }\n    const fromOutputGcsUri = getValueByPath(fromObject, [\n        \"outputGcsUri\"\n    ]);\n    if (parentObject !== undefined && fromOutputGcsUri != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"storageUri\"\n        ], fromOutputGcsUri);\n    }\n    const fromFps = getValueByPath(fromObject, [\n        \"fps\"\n    ]);\n    if (parentObject !== undefined && fromFps != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"fps\"\n        ], fromFps);\n    }\n    const fromDurationSeconds = getValueByPath(fromObject, [\n        \"durationSeconds\"\n    ]);\n    if (parentObject !== undefined && fromDurationSeconds != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"durationSeconds\"\n        ], fromDurationSeconds);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromAspectRatio = getValueByPath(fromObject, [\n        \"aspectRatio\"\n    ]);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"aspectRatio\"\n        ], fromAspectRatio);\n    }\n    const fromResolution = getValueByPath(fromObject, [\n        \"resolution\"\n    ]);\n    if (parentObject !== undefined && fromResolution != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"resolution\"\n        ], fromResolution);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        \"personGeneration\"\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"personGeneration\"\n        ], fromPersonGeneration);\n    }\n    const fromPubsubTopic = getValueByPath(fromObject, [\n        \"pubsubTopic\"\n    ]);\n    if (parentObject !== undefined && fromPubsubTopic != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"pubsubTopic\"\n        ], fromPubsubTopic);\n    }\n    const fromNegativePrompt = getValueByPath(fromObject, [\n        \"negativePrompt\"\n    ]);\n    if (parentObject !== undefined && fromNegativePrompt != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"negativePrompt\"\n        ], fromNegativePrompt);\n    }\n    const fromEnhancePrompt = getValueByPath(fromObject, [\n        \"enhancePrompt\"\n    ]);\n    if (parentObject !== undefined && fromEnhancePrompt != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"enhancePrompt\"\n        ], fromEnhancePrompt);\n    }\n    return toObject;\n}\nfunction generateVideosParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"prompt\"\n        ], fromPrompt);\n    }\n    const fromImage = getValueByPath(fromObject, [\n        \"image\"\n    ]);\n    if (fromImage != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"image\"\n        ], imageToVertex(apiClient, fromImage));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], generateVideosConfigToVertex(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction partFromMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fromFileData);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], fromFunctionCall);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], fromInlineData);\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    return toObject;\n}\nfunction contentFromMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        if (Array.isArray(fromParts)) {\n            setValueByPath(toObject, [\n                \"parts\"\n            ], fromParts.map((item)=>{\n                return partFromMldev(apiClient, item);\n            }));\n        } else {\n            setValueByPath(toObject, [\n                \"parts\"\n            ], fromParts);\n        }\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction citationMetadataFromMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromCitations = getValueByPath(fromObject, [\n        \"citationSources\"\n    ]);\n    if (fromCitations != null) {\n        setValueByPath(toObject, [\n            \"citations\"\n        ], fromCitations);\n    }\n    return toObject;\n}\nfunction candidateFromMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromContent = getValueByPath(fromObject, [\n        \"content\"\n    ]);\n    if (fromContent != null) {\n        setValueByPath(toObject, [\n            \"content\"\n        ], contentFromMldev(apiClient, fromContent));\n    }\n    const fromCitationMetadata = getValueByPath(fromObject, [\n        \"citationMetadata\"\n    ]);\n    if (fromCitationMetadata != null) {\n        setValueByPath(toObject, [\n            \"citationMetadata\"\n        ], citationMetadataFromMldev(apiClient, fromCitationMetadata));\n    }\n    const fromTokenCount = getValueByPath(fromObject, [\n        \"tokenCount\"\n    ]);\n    if (fromTokenCount != null) {\n        setValueByPath(toObject, [\n            \"tokenCount\"\n        ], fromTokenCount);\n    }\n    const fromFinishReason = getValueByPath(fromObject, [\n        \"finishReason\"\n    ]);\n    if (fromFinishReason != null) {\n        setValueByPath(toObject, [\n            \"finishReason\"\n        ], fromFinishReason);\n    }\n    const fromAvgLogprobs = getValueByPath(fromObject, [\n        \"avgLogprobs\"\n    ]);\n    if (fromAvgLogprobs != null) {\n        setValueByPath(toObject, [\n            \"avgLogprobs\"\n        ], fromAvgLogprobs);\n    }\n    const fromGroundingMetadata = getValueByPath(fromObject, [\n        \"groundingMetadata\"\n    ]);\n    if (fromGroundingMetadata != null) {\n        setValueByPath(toObject, [\n            \"groundingMetadata\"\n        ], fromGroundingMetadata);\n    }\n    const fromIndex = getValueByPath(fromObject, [\n        \"index\"\n    ]);\n    if (fromIndex != null) {\n        setValueByPath(toObject, [\n            \"index\"\n        ], fromIndex);\n    }\n    const fromLogprobsResult = getValueByPath(fromObject, [\n        \"logprobsResult\"\n    ]);\n    if (fromLogprobsResult != null) {\n        setValueByPath(toObject, [\n            \"logprobsResult\"\n        ], fromLogprobsResult);\n    }\n    const fromSafetyRatings = getValueByPath(fromObject, [\n        \"safetyRatings\"\n    ]);\n    if (fromSafetyRatings != null) {\n        setValueByPath(toObject, [\n            \"safetyRatings\"\n        ], fromSafetyRatings);\n    }\n    return toObject;\n}\nfunction generateContentResponseFromMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromCandidates = getValueByPath(fromObject, [\n        \"candidates\"\n    ]);\n    if (fromCandidates != null) {\n        if (Array.isArray(fromCandidates)) {\n            setValueByPath(toObject, [\n                \"candidates\"\n            ], fromCandidates.map((item)=>{\n                return candidateFromMldev(apiClient, item);\n            }));\n        } else {\n            setValueByPath(toObject, [\n                \"candidates\"\n            ], fromCandidates);\n        }\n    }\n    const fromModelVersion = getValueByPath(fromObject, [\n        \"modelVersion\"\n    ]);\n    if (fromModelVersion != null) {\n        setValueByPath(toObject, [\n            \"modelVersion\"\n        ], fromModelVersion);\n    }\n    const fromPromptFeedback = getValueByPath(fromObject, [\n        \"promptFeedback\"\n    ]);\n    if (fromPromptFeedback != null) {\n        setValueByPath(toObject, [\n            \"promptFeedback\"\n        ], fromPromptFeedback);\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        \"usageMetadata\"\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, [\n            \"usageMetadata\"\n        ], fromUsageMetadata);\n    }\n    return toObject;\n}\nfunction contentEmbeddingFromMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromValues = getValueByPath(fromObject, [\n        \"values\"\n    ]);\n    if (fromValues != null) {\n        setValueByPath(toObject, [\n            \"values\"\n        ], fromValues);\n    }\n    return toObject;\n}\nfunction embedContentMetadataFromMldev() {\n    const toObject = {};\n    return toObject;\n}\nfunction embedContentResponseFromMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromEmbeddings = getValueByPath(fromObject, [\n        \"embeddings\"\n    ]);\n    if (fromEmbeddings != null) {\n        if (Array.isArray(fromEmbeddings)) {\n            setValueByPath(toObject, [\n                \"embeddings\"\n            ], fromEmbeddings.map((item)=>{\n                return contentEmbeddingFromMldev(apiClient, item);\n            }));\n        } else {\n            setValueByPath(toObject, [\n                \"embeddings\"\n            ], fromEmbeddings);\n        }\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], embedContentMetadataFromMldev());\n    }\n    return toObject;\n}\nfunction imageFromMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromImageBytes = getValueByPath(fromObject, [\n        \"bytesBase64Encoded\"\n    ]);\n    if (fromImageBytes != null) {\n        setValueByPath(toObject, [\n            \"imageBytes\"\n        ], tBytes(apiClient, fromImageBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction safetyAttributesFromMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromCategories = getValueByPath(fromObject, [\n        \"safetyAttributes\",\n        \"categories\"\n    ]);\n    if (fromCategories != null) {\n        setValueByPath(toObject, [\n            \"categories\"\n        ], fromCategories);\n    }\n    const fromScores = getValueByPath(fromObject, [\n        \"safetyAttributes\",\n        \"scores\"\n    ]);\n    if (fromScores != null) {\n        setValueByPath(toObject, [\n            \"scores\"\n        ], fromScores);\n    }\n    const fromContentType = getValueByPath(fromObject, [\n        \"contentType\"\n    ]);\n    if (fromContentType != null) {\n        setValueByPath(toObject, [\n            \"contentType\"\n        ], fromContentType);\n    }\n    return toObject;\n}\nfunction generatedImageFromMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromImage != null) {\n        setValueByPath(toObject, [\n            \"image\"\n        ], imageFromMldev(apiClient, fromImage));\n    }\n    const fromRaiFilteredReason = getValueByPath(fromObject, [\n        \"raiFilteredReason\"\n    ]);\n    if (fromRaiFilteredReason != null) {\n        setValueByPath(toObject, [\n            \"raiFilteredReason\"\n        ], fromRaiFilteredReason);\n    }\n    const fromSafetyAttributes = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromSafetyAttributes != null) {\n        setValueByPath(toObject, [\n            \"safetyAttributes\"\n        ], safetyAttributesFromMldev(apiClient, fromSafetyAttributes));\n    }\n    return toObject;\n}\nfunction generateImagesResponseFromMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromGeneratedImages = getValueByPath(fromObject, [\n        \"predictions\"\n    ]);\n    if (fromGeneratedImages != null) {\n        if (Array.isArray(fromGeneratedImages)) {\n            setValueByPath(toObject, [\n                \"generatedImages\"\n            ], fromGeneratedImages.map((item)=>{\n                return generatedImageFromMldev(apiClient, item);\n            }));\n        } else {\n            setValueByPath(toObject, [\n                \"generatedImages\"\n            ], fromGeneratedImages);\n        }\n    }\n    const fromPositivePromptSafetyAttributes = getValueByPath(fromObject, [\n        \"positivePromptSafetyAttributes\"\n    ]);\n    if (fromPositivePromptSafetyAttributes != null) {\n        setValueByPath(toObject, [\n            \"positivePromptSafetyAttributes\"\n        ], safetyAttributesFromMldev(apiClient, fromPositivePromptSafetyAttributes));\n    }\n    return toObject;\n}\nfunction tunedModelInfoFromMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromBaseModel = getValueByPath(fromObject, [\n        \"baseModel\"\n    ]);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, [\n            \"baseModel\"\n        ], fromBaseModel);\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    return toObject;\n}\nfunction modelFromMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromVersion = getValueByPath(fromObject, [\n        \"version\"\n    ]);\n    if (fromVersion != null) {\n        setValueByPath(toObject, [\n            \"version\"\n        ], fromVersion);\n    }\n    const fromTunedModelInfo = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromTunedModelInfo != null) {\n        setValueByPath(toObject, [\n            \"tunedModelInfo\"\n        ], tunedModelInfoFromMldev(apiClient, fromTunedModelInfo));\n    }\n    const fromInputTokenLimit = getValueByPath(fromObject, [\n        \"inputTokenLimit\"\n    ]);\n    if (fromInputTokenLimit != null) {\n        setValueByPath(toObject, [\n            \"inputTokenLimit\"\n        ], fromInputTokenLimit);\n    }\n    const fromOutputTokenLimit = getValueByPath(fromObject, [\n        \"outputTokenLimit\"\n    ]);\n    if (fromOutputTokenLimit != null) {\n        setValueByPath(toObject, [\n            \"outputTokenLimit\"\n        ], fromOutputTokenLimit);\n    }\n    const fromSupportedActions = getValueByPath(fromObject, [\n        \"supportedGenerationMethods\"\n    ]);\n    if (fromSupportedActions != null) {\n        setValueByPath(toObject, [\n            \"supportedActions\"\n        ], fromSupportedActions);\n    }\n    return toObject;\n}\nfunction countTokensResponseFromMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromTotalTokens = getValueByPath(fromObject, [\n        \"totalTokens\"\n    ]);\n    if (fromTotalTokens != null) {\n        setValueByPath(toObject, [\n            \"totalTokens\"\n        ], fromTotalTokens);\n    }\n    const fromCachedContentTokenCount = getValueByPath(fromObject, [\n        \"cachedContentTokenCount\"\n    ]);\n    if (fromCachedContentTokenCount != null) {\n        setValueByPath(toObject, [\n            \"cachedContentTokenCount\"\n        ], fromCachedContentTokenCount);\n    }\n    return toObject;\n}\nfunction videoFromMldev$1(apiClient, fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, [\n        \"video\",\n        \"uri\"\n    ]);\n    if (fromUri != null) {\n        setValueByPath(toObject, [\n            \"uri\"\n        ], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, [\n        \"video\",\n        \"encodedVideo\"\n    ]);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, [\n            \"videoBytes\"\n        ], tBytes(apiClient, fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"encoding\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction generatedVideoFromMldev$1(apiClient, fromObject) {\n    const toObject = {};\n    const fromVideo = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromVideo != null) {\n        setValueByPath(toObject, [\n            \"video\"\n        ], videoFromMldev$1(apiClient, fromVideo));\n    }\n    return toObject;\n}\nfunction generateVideosResponseFromMldev$1(apiClient, fromObject) {\n    const toObject = {};\n    const fromGeneratedVideos = getValueByPath(fromObject, [\n        \"generatedSamples\"\n    ]);\n    if (fromGeneratedVideos != null) {\n        if (Array.isArray(fromGeneratedVideos)) {\n            setValueByPath(toObject, [\n                \"generatedVideos\"\n            ], fromGeneratedVideos.map((item)=>{\n                return generatedVideoFromMldev$1(apiClient, item);\n            }));\n        } else {\n            setValueByPath(toObject, [\n                \"generatedVideos\"\n            ], fromGeneratedVideos);\n        }\n    }\n    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [\n        \"raiMediaFilteredCount\"\n    ]);\n    if (fromRaiMediaFilteredCount != null) {\n        setValueByPath(toObject, [\n            \"raiMediaFilteredCount\"\n        ], fromRaiMediaFilteredCount);\n    }\n    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [\n        \"raiMediaFilteredReasons\"\n    ]);\n    if (fromRaiMediaFilteredReasons != null) {\n        setValueByPath(toObject, [\n            \"raiMediaFilteredReasons\"\n        ], fromRaiMediaFilteredReasons);\n    }\n    return toObject;\n}\nfunction generateVideosOperationFromMldev$1(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, [\n        \"done\"\n    ]);\n    if (fromDone != null) {\n        setValueByPath(toObject, [\n            \"done\"\n        ], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\",\n        \"generateVideoResponse\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], generateVideosResponseFromMldev$1(apiClient, fromResponse));\n    }\n    return toObject;\n}\nfunction partFromVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], fromVideoMetadata);\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fromFileData);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], fromFunctionCall);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], fromInlineData);\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    return toObject;\n}\nfunction contentFromVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        if (Array.isArray(fromParts)) {\n            setValueByPath(toObject, [\n                \"parts\"\n            ], fromParts.map((item)=>{\n                return partFromVertex(apiClient, item);\n            }));\n        } else {\n            setValueByPath(toObject, [\n                \"parts\"\n            ], fromParts);\n        }\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction citationMetadataFromVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromCitations = getValueByPath(fromObject, [\n        \"citations\"\n    ]);\n    if (fromCitations != null) {\n        setValueByPath(toObject, [\n            \"citations\"\n        ], fromCitations);\n    }\n    return toObject;\n}\nfunction candidateFromVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromContent = getValueByPath(fromObject, [\n        \"content\"\n    ]);\n    if (fromContent != null) {\n        setValueByPath(toObject, [\n            \"content\"\n        ], contentFromVertex(apiClient, fromContent));\n    }\n    const fromCitationMetadata = getValueByPath(fromObject, [\n        \"citationMetadata\"\n    ]);\n    if (fromCitationMetadata != null) {\n        setValueByPath(toObject, [\n            \"citationMetadata\"\n        ], citationMetadataFromVertex(apiClient, fromCitationMetadata));\n    }\n    const fromFinishMessage = getValueByPath(fromObject, [\n        \"finishMessage\"\n    ]);\n    if (fromFinishMessage != null) {\n        setValueByPath(toObject, [\n            \"finishMessage\"\n        ], fromFinishMessage);\n    }\n    const fromFinishReason = getValueByPath(fromObject, [\n        \"finishReason\"\n    ]);\n    if (fromFinishReason != null) {\n        setValueByPath(toObject, [\n            \"finishReason\"\n        ], fromFinishReason);\n    }\n    const fromAvgLogprobs = getValueByPath(fromObject, [\n        \"avgLogprobs\"\n    ]);\n    if (fromAvgLogprobs != null) {\n        setValueByPath(toObject, [\n            \"avgLogprobs\"\n        ], fromAvgLogprobs);\n    }\n    const fromGroundingMetadata = getValueByPath(fromObject, [\n        \"groundingMetadata\"\n    ]);\n    if (fromGroundingMetadata != null) {\n        setValueByPath(toObject, [\n            \"groundingMetadata\"\n        ], fromGroundingMetadata);\n    }\n    const fromIndex = getValueByPath(fromObject, [\n        \"index\"\n    ]);\n    if (fromIndex != null) {\n        setValueByPath(toObject, [\n            \"index\"\n        ], fromIndex);\n    }\n    const fromLogprobsResult = getValueByPath(fromObject, [\n        \"logprobsResult\"\n    ]);\n    if (fromLogprobsResult != null) {\n        setValueByPath(toObject, [\n            \"logprobsResult\"\n        ], fromLogprobsResult);\n    }\n    const fromSafetyRatings = getValueByPath(fromObject, [\n        \"safetyRatings\"\n    ]);\n    if (fromSafetyRatings != null) {\n        setValueByPath(toObject, [\n            \"safetyRatings\"\n        ], fromSafetyRatings);\n    }\n    return toObject;\n}\nfunction generateContentResponseFromVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromCandidates = getValueByPath(fromObject, [\n        \"candidates\"\n    ]);\n    if (fromCandidates != null) {\n        if (Array.isArray(fromCandidates)) {\n            setValueByPath(toObject, [\n                \"candidates\"\n            ], fromCandidates.map((item)=>{\n                return candidateFromVertex(apiClient, item);\n            }));\n        } else {\n            setValueByPath(toObject, [\n                \"candidates\"\n            ], fromCandidates);\n        }\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromResponseId = getValueByPath(fromObject, [\n        \"responseId\"\n    ]);\n    if (fromResponseId != null) {\n        setValueByPath(toObject, [\n            \"responseId\"\n        ], fromResponseId);\n    }\n    const fromModelVersion = getValueByPath(fromObject, [\n        \"modelVersion\"\n    ]);\n    if (fromModelVersion != null) {\n        setValueByPath(toObject, [\n            \"modelVersion\"\n        ], fromModelVersion);\n    }\n    const fromPromptFeedback = getValueByPath(fromObject, [\n        \"promptFeedback\"\n    ]);\n    if (fromPromptFeedback != null) {\n        setValueByPath(toObject, [\n            \"promptFeedback\"\n        ], fromPromptFeedback);\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        \"usageMetadata\"\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, [\n            \"usageMetadata\"\n        ], fromUsageMetadata);\n    }\n    return toObject;\n}\nfunction contentEmbeddingStatisticsFromVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromTruncated = getValueByPath(fromObject, [\n        \"truncated\"\n    ]);\n    if (fromTruncated != null) {\n        setValueByPath(toObject, [\n            \"truncated\"\n        ], fromTruncated);\n    }\n    const fromTokenCount = getValueByPath(fromObject, [\n        \"token_count\"\n    ]);\n    if (fromTokenCount != null) {\n        setValueByPath(toObject, [\n            \"tokenCount\"\n        ], fromTokenCount);\n    }\n    return toObject;\n}\nfunction contentEmbeddingFromVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromValues = getValueByPath(fromObject, [\n        \"values\"\n    ]);\n    if (fromValues != null) {\n        setValueByPath(toObject, [\n            \"values\"\n        ], fromValues);\n    }\n    const fromStatistics = getValueByPath(fromObject, [\n        \"statistics\"\n    ]);\n    if (fromStatistics != null) {\n        setValueByPath(toObject, [\n            \"statistics\"\n        ], contentEmbeddingStatisticsFromVertex(apiClient, fromStatistics));\n    }\n    return toObject;\n}\nfunction embedContentMetadataFromVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromBillableCharacterCount = getValueByPath(fromObject, [\n        \"billableCharacterCount\"\n    ]);\n    if (fromBillableCharacterCount != null) {\n        setValueByPath(toObject, [\n            \"billableCharacterCount\"\n        ], fromBillableCharacterCount);\n    }\n    return toObject;\n}\nfunction embedContentResponseFromVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromEmbeddings = getValueByPath(fromObject, [\n        \"predictions[]\",\n        \"embeddings\"\n    ]);\n    if (fromEmbeddings != null) {\n        if (Array.isArray(fromEmbeddings)) {\n            setValueByPath(toObject, [\n                \"embeddings\"\n            ], fromEmbeddings.map((item)=>{\n                return contentEmbeddingFromVertex(apiClient, item);\n            }));\n        } else {\n            setValueByPath(toObject, [\n                \"embeddings\"\n            ], fromEmbeddings);\n        }\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], embedContentMetadataFromVertex(apiClient, fromMetadata));\n    }\n    return toObject;\n}\nfunction imageFromVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromGcsUri = getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, [\n            \"gcsUri\"\n        ], fromGcsUri);\n    }\n    const fromImageBytes = getValueByPath(fromObject, [\n        \"bytesBase64Encoded\"\n    ]);\n    if (fromImageBytes != null) {\n        setValueByPath(toObject, [\n            \"imageBytes\"\n        ], tBytes(apiClient, fromImageBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction safetyAttributesFromVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromCategories = getValueByPath(fromObject, [\n        \"safetyAttributes\",\n        \"categories\"\n    ]);\n    if (fromCategories != null) {\n        setValueByPath(toObject, [\n            \"categories\"\n        ], fromCategories);\n    }\n    const fromScores = getValueByPath(fromObject, [\n        \"safetyAttributes\",\n        \"scores\"\n    ]);\n    if (fromScores != null) {\n        setValueByPath(toObject, [\n            \"scores\"\n        ], fromScores);\n    }\n    const fromContentType = getValueByPath(fromObject, [\n        \"contentType\"\n    ]);\n    if (fromContentType != null) {\n        setValueByPath(toObject, [\n            \"contentType\"\n        ], fromContentType);\n    }\n    return toObject;\n}\nfunction generatedImageFromVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromImage != null) {\n        setValueByPath(toObject, [\n            \"image\"\n        ], imageFromVertex(apiClient, fromImage));\n    }\n    const fromRaiFilteredReason = getValueByPath(fromObject, [\n        \"raiFilteredReason\"\n    ]);\n    if (fromRaiFilteredReason != null) {\n        setValueByPath(toObject, [\n            \"raiFilteredReason\"\n        ], fromRaiFilteredReason);\n    }\n    const fromSafetyAttributes = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromSafetyAttributes != null) {\n        setValueByPath(toObject, [\n            \"safetyAttributes\"\n        ], safetyAttributesFromVertex(apiClient, fromSafetyAttributes));\n    }\n    const fromEnhancedPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (fromEnhancedPrompt != null) {\n        setValueByPath(toObject, [\n            \"enhancedPrompt\"\n        ], fromEnhancedPrompt);\n    }\n    return toObject;\n}\nfunction generateImagesResponseFromVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromGeneratedImages = getValueByPath(fromObject, [\n        \"predictions\"\n    ]);\n    if (fromGeneratedImages != null) {\n        if (Array.isArray(fromGeneratedImages)) {\n            setValueByPath(toObject, [\n                \"generatedImages\"\n            ], fromGeneratedImages.map((item)=>{\n                return generatedImageFromVertex(apiClient, item);\n            }));\n        } else {\n            setValueByPath(toObject, [\n                \"generatedImages\"\n            ], fromGeneratedImages);\n        }\n    }\n    const fromPositivePromptSafetyAttributes = getValueByPath(fromObject, [\n        \"positivePromptSafetyAttributes\"\n    ]);\n    if (fromPositivePromptSafetyAttributes != null) {\n        setValueByPath(toObject, [\n            \"positivePromptSafetyAttributes\"\n        ], safetyAttributesFromVertex(apiClient, fromPositivePromptSafetyAttributes));\n    }\n    return toObject;\n}\nfunction endpointFromVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"endpoint\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDeployedModelId = getValueByPath(fromObject, [\n        \"deployedModelId\"\n    ]);\n    if (fromDeployedModelId != null) {\n        setValueByPath(toObject, [\n            \"deployedModelId\"\n        ], fromDeployedModelId);\n    }\n    return toObject;\n}\nfunction tunedModelInfoFromVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromBaseModel = getValueByPath(fromObject, [\n        \"labels\",\n        \"google-vertex-llm-tuning-base-model-id\"\n    ]);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, [\n            \"baseModel\"\n        ], fromBaseModel);\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    return toObject;\n}\nfunction modelFromVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromVersion = getValueByPath(fromObject, [\n        \"versionId\"\n    ]);\n    if (fromVersion != null) {\n        setValueByPath(toObject, [\n            \"version\"\n        ], fromVersion);\n    }\n    const fromEndpoints = getValueByPath(fromObject, [\n        \"deployedModels\"\n    ]);\n    if (fromEndpoints != null) {\n        if (Array.isArray(fromEndpoints)) {\n            setValueByPath(toObject, [\n                \"endpoints\"\n            ], fromEndpoints.map((item)=>{\n                return endpointFromVertex(apiClient, item);\n            }));\n        } else {\n            setValueByPath(toObject, [\n                \"endpoints\"\n            ], fromEndpoints);\n        }\n    }\n    const fromLabels = getValueByPath(fromObject, [\n        \"labels\"\n    ]);\n    if (fromLabels != null) {\n        setValueByPath(toObject, [\n            \"labels\"\n        ], fromLabels);\n    }\n    const fromTunedModelInfo = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromTunedModelInfo != null) {\n        setValueByPath(toObject, [\n            \"tunedModelInfo\"\n        ], tunedModelInfoFromVertex(apiClient, fromTunedModelInfo));\n    }\n    return toObject;\n}\nfunction countTokensResponseFromVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromTotalTokens = getValueByPath(fromObject, [\n        \"totalTokens\"\n    ]);\n    if (fromTotalTokens != null) {\n        setValueByPath(toObject, [\n            \"totalTokens\"\n        ], fromTotalTokens);\n    }\n    return toObject;\n}\nfunction computeTokensResponseFromVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromTokensInfo = getValueByPath(fromObject, [\n        \"tokensInfo\"\n    ]);\n    if (fromTokensInfo != null) {\n        setValueByPath(toObject, [\n            \"tokensInfo\"\n        ], fromTokensInfo);\n    }\n    return toObject;\n}\nfunction videoFromVertex$1(apiClient, fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]);\n    if (fromUri != null) {\n        setValueByPath(toObject, [\n            \"uri\"\n        ], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, [\n        \"bytesBase64Encoded\"\n    ]);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, [\n            \"videoBytes\"\n        ], tBytes(apiClient, fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction generatedVideoFromVertex$1(apiClient, fromObject) {\n    const toObject = {};\n    const fromVideo = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromVideo != null) {\n        setValueByPath(toObject, [\n            \"video\"\n        ], videoFromVertex$1(apiClient, fromVideo));\n    }\n    return toObject;\n}\nfunction generateVideosResponseFromVertex$1(apiClient, fromObject) {\n    const toObject = {};\n    const fromGeneratedVideos = getValueByPath(fromObject, [\n        \"videos\"\n    ]);\n    if (fromGeneratedVideos != null) {\n        if (Array.isArray(fromGeneratedVideos)) {\n            setValueByPath(toObject, [\n                \"generatedVideos\"\n            ], fromGeneratedVideos.map((item)=>{\n                return generatedVideoFromVertex$1(apiClient, item);\n            }));\n        } else {\n            setValueByPath(toObject, [\n                \"generatedVideos\"\n            ], fromGeneratedVideos);\n        }\n    }\n    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [\n        \"raiMediaFilteredCount\"\n    ]);\n    if (fromRaiMediaFilteredCount != null) {\n        setValueByPath(toObject, [\n            \"raiMediaFilteredCount\"\n        ], fromRaiMediaFilteredCount);\n    }\n    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [\n        \"raiMediaFilteredReasons\"\n    ]);\n    if (fromRaiMediaFilteredReasons != null) {\n        setValueByPath(toObject, [\n            \"raiMediaFilteredReasons\"\n        ], fromRaiMediaFilteredReasons);\n    }\n    return toObject;\n}\nfunction generateVideosOperationFromVertex$1(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, [\n        \"done\"\n    ]);\n    if (fromDone != null) {\n        setValueByPath(toObject, [\n            \"done\"\n        ], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], generateVideosResponseFromVertex$1(apiClient, fromResponse));\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ const FUNCTION_RESPONSE_REQUIRES_ID = \"FunctionResponse request must have an `id` field from the response of a ToolCall.FunctionalCalls in Google AI.\";\n/**\n * Handles incoming messages from the WebSocket.\n *\n * @remarks\n * This function is responsible for parsing incoming messages, transforming them\n * into LiveServerMessages, and then calling the onmessage callback. Note that\n * the first message which is received from the server is a setupComplete\n * message.\n *\n * @param apiClient The ApiClient instance.\n * @param onmessage The user-provided onmessage callback (if any).\n * @param event The MessageEvent from the WebSocket.\n */ async function handleWebSocketMessage(apiClient, onmessage, event) {\n    let serverMessage;\n    let data;\n    if (event.data instanceof Blob) {\n        data = JSON.parse(await event.data.text());\n    } else {\n        data = JSON.parse(event.data);\n    }\n    if (apiClient.isVertexAI()) {\n        serverMessage = liveServerMessageFromVertex(apiClient, data);\n    } else {\n        serverMessage = liveServerMessageFromMldev(apiClient, data);\n    }\n    onmessage(serverMessage);\n}\n/**\n   Live class encapsulates the configuration for live interaction with the\n   Generative Language API. It embeds ApiClient for general API settings.\n\n   @experimental\n  */ class Live {\n    constructor(apiClient, auth, webSocketFactory){\n        this.apiClient = apiClient;\n        this.auth = auth;\n        this.webSocketFactory = webSocketFactory;\n    }\n    /**\n       Establishes a connection to the specified model with the given\n       configuration and returns a Session object representing that connection.\n  \n       @experimental\n  \n       @remarks\n  \n       @param params - The parameters for establishing a connection to the model.\n       @return A live session.\n  \n       @example\n       ```ts\n       let model: string;\n       if (GOOGLE_GENAI_USE_VERTEXAI) {\n         model = 'gemini-2.0-flash-live-preview-04-09';\n       } else {\n         model = 'gemini-2.0-flash-live-001';\n       }\n       const session = await ai.live.connect({\n         model: model,\n         config: {\n           responseModalities: [Modality.AUDIO],\n         },\n         callbacks: {\n           onopen: () => {\n             console.log('Connected to the socket.');\n           },\n           onmessage: (e: MessageEvent) => {\n             console.log('Received message from the server: %s\\n', debug(e.data));\n           },\n           onerror: (e: ErrorEvent) => {\n             console.log('Error occurred: %s\\n', debug(e.error));\n           },\n           onclose: (e: CloseEvent) => {\n             console.log('Connection closed.');\n           },\n         },\n       });\n       ```\n      */ async connect(params) {\n        var _a, _b, _c, _d;\n        const websocketBaseUrl = this.apiClient.getWebsocketBaseUrl();\n        const apiVersion = this.apiClient.getApiVersion();\n        let url;\n        const headers = mapToHeaders(this.apiClient.getDefaultHeaders());\n        if (this.apiClient.isVertexAI()) {\n            url = `${websocketBaseUrl}/ws/google.cloud.aiplatform.${apiVersion}.LlmBidiService/BidiGenerateContent`;\n            await this.auth.addAuthHeaders(headers);\n        } else {\n            const apiKey = this.apiClient.getApiKey();\n            url = `${websocketBaseUrl}/ws/google.ai.generativelanguage.${apiVersion}.GenerativeService.BidiGenerateContent?key=${apiKey}`;\n        }\n        let onopenResolve = ()=>{};\n        const onopenPromise = new Promise((resolve)=>{\n            onopenResolve = resolve;\n        });\n        const callbacks = params.callbacks;\n        const onopenAwaitedCallback = function() {\n            var _a;\n            (_a = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onopen) === null || _a === void 0 ? void 0 : _a.call(callbacks);\n            onopenResolve({});\n        };\n        const apiClient = this.apiClient;\n        const websocketCallbacks = {\n            onopen: onopenAwaitedCallback,\n            onmessage: (event)=>{\n                void handleWebSocketMessage(apiClient, callbacks.onmessage, event);\n            },\n            onerror: (_a = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onerror) !== null && _a !== void 0 ? _a : function(e) {},\n            onclose: (_b = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onclose) !== null && _b !== void 0 ? _b : function(e) {}\n        };\n        const conn = this.webSocketFactory.create(url, headersToMap(headers), websocketCallbacks);\n        conn.connect();\n        // Wait for the websocket to open before sending requests.\n        await onopenPromise;\n        let transformedModel = tModel(this.apiClient, params.model);\n        if (this.apiClient.isVertexAI() && transformedModel.startsWith(\"publishers/\")) {\n            const project = this.apiClient.getProject();\n            const location = this.apiClient.getLocation();\n            transformedModel = `projects/${project}/locations/${location}/` + transformedModel;\n        }\n        let clientMessage = {};\n        if (this.apiClient.isVertexAI() && ((_c = params.config) === null || _c === void 0 ? void 0 : _c.responseModalities) === undefined) {\n            // Set default to AUDIO to align with MLDev API.\n            if (params.config === undefined) {\n                params.config = {\n                    responseModalities: [\n                        exports.Modality.AUDIO\n                    ]\n                };\n            } else {\n                params.config.responseModalities = [\n                    exports.Modality.AUDIO\n                ];\n            }\n        }\n        if ((_d = params.config) === null || _d === void 0 ? void 0 : _d.generationConfig) {\n            // Raise deprecation warning for generationConfig.\n            console.warn(\"Setting `LiveConnectConfig.generation_config` is deprecated, please set the fields on `LiveConnectConfig` directly. This will become an error in a future version (not before Q3 2025).\");\n        }\n        const liveConnectParameters = {\n            model: transformedModel,\n            config: params.config,\n            callbacks: params.callbacks\n        };\n        if (this.apiClient.isVertexAI()) {\n            clientMessage = liveConnectParametersToVertex(this.apiClient, liveConnectParameters);\n        } else {\n            clientMessage = liveConnectParametersToMldev(this.apiClient, liveConnectParameters);\n        }\n        delete clientMessage[\"config\"];\n        conn.send(JSON.stringify(clientMessage));\n        return new Session(conn, this.apiClient);\n    }\n}\nconst defaultLiveSendClientContentParamerters = {\n    turnComplete: true\n};\n/**\n   Represents a connection to the API.\n\n   @experimental\n  */ class Session {\n    constructor(conn, apiClient){\n        this.conn = conn;\n        this.apiClient = apiClient;\n    }\n    tLiveClientContent(apiClient, params) {\n        if (params.turns !== null && params.turns !== undefined) {\n            let contents = [];\n            try {\n                contents = tContents(apiClient, params.turns);\n                if (apiClient.isVertexAI()) {\n                    contents = contents.map((item)=>contentToVertex(apiClient, item));\n                } else {\n                    contents = contents.map((item)=>contentToMldev(apiClient, item));\n                }\n            } catch (_a) {\n                throw new Error(`Failed to parse client content \"turns\", type: '${typeof params.turns}'`);\n            }\n            return {\n                clientContent: {\n                    turns: contents,\n                    turnComplete: params.turnComplete\n                }\n            };\n        }\n        return {\n            clientContent: {\n                turnComplete: params.turnComplete\n            }\n        };\n    }\n    tLiveClienttToolResponse(apiClient, params) {\n        let functionResponses = [];\n        if (params.functionResponses == null) {\n            throw new Error(\"functionResponses is required.\");\n        }\n        if (!Array.isArray(params.functionResponses)) {\n            functionResponses = [\n                params.functionResponses\n            ];\n        } else {\n            functionResponses = params.functionResponses;\n        }\n        if (functionResponses.length === 0) {\n            throw new Error(\"functionResponses is required.\");\n        }\n        for (const functionResponse of functionResponses){\n            if (typeof functionResponse !== \"object\" || functionResponse === null || !(\"name\" in functionResponse) || !(\"response\" in functionResponse)) {\n                throw new Error(`Could not parse function response, type '${typeof functionResponse}'.`);\n            }\n            if (!apiClient.isVertexAI() && !(\"id\" in functionResponse)) {\n                throw new Error(FUNCTION_RESPONSE_REQUIRES_ID);\n            }\n        }\n        const clientMessage = {\n            toolResponse: {\n                functionResponses: functionResponses\n            }\n        };\n        return clientMessage;\n    }\n    /**\n      Send a message over the established connection.\n  \n      @param params - Contains two **optional** properties, `turns` and\n          `turnComplete`.\n  \n        - `turns` will be converted to a `Content[]`\n        - `turnComplete: true` [default] indicates that you are done sending\n          content and expect a response. If `turnComplete: false`, the server\n          will wait for additional messages before starting generation.\n  \n      @experimental\n  \n      @remarks\n      There are two ways to send messages to the live API:\n      `sendClientContent` and `sendRealtimeInput`.\n  \n      `sendClientContent` messages are added to the model context **in order**.\n      Having a conversation using `sendClientContent` messages is roughly\n      equivalent to using the `Chat.sendMessageStream`, except that the state of\n      the `chat` history is stored on the API server instead of locally.\n  \n      Because of `sendClientContent`'s order guarantee, the model cannot respons\n      as quickly to `sendClientContent` messages as to `sendRealtimeInput`\n      messages. This makes the biggest difference when sending objects that have\n      significant preprocessing time (typically images).\n  \n      The `sendClientContent` message sends a `Content[]`\n      which has more options than the `Blob` sent by `sendRealtimeInput`.\n  \n      So the main use-cases for `sendClientContent` over `sendRealtimeInput` are:\n  \n      - Sending anything that can't be represented as a `Blob` (text,\n      `sendClientContent({turns=\"Hello?\"}`)).\n      - Managing turns when not using audio input and voice activity detection.\n        (`sendClientContent({turnComplete:true})` or the short form\n      `sendClientContent()`)\n      - Prefilling a conversation context\n        ```\n        sendClientContent({\n            turns: [\n              Content({role:user, parts:...}),\n              Content({role:user, parts:...}),\n              ...\n            ]\n        })\n        ```\n      @experimental\n     */ sendClientContent(params) {\n        params = Object.assign(Object.assign({}, defaultLiveSendClientContentParamerters), params);\n        const clientMessage = this.tLiveClientContent(this.apiClient, params);\n        this.conn.send(JSON.stringify(clientMessage));\n    }\n    /**\n      Send a realtime message over the established connection.\n  \n      @param params - Contains one property, `media`.\n  \n        - `media` will be converted to a `Blob`\n  \n      @experimental\n  \n      @remarks\n      Use `sendRealtimeInput` for realtime audio chunks and video frames (images).\n  \n      With `sendRealtimeInput` the api will respond to audio automatically\n      based on voice activity detection (VAD).\n  \n      `sendRealtimeInput` is optimized for responsivness at the expense of\n      deterministic ordering guarantees. Audio and video tokens are to the\n      context when they become available.\n  \n      Note: The Call signature expects a `Blob` object, but only a subset\n      of audio and image mimetypes are allowed.\n     */ sendRealtimeInput(params) {\n        let clientMessage = {};\n        if (this.apiClient.isVertexAI()) {\n            clientMessage = {\n                \"realtimeInput\": liveSendRealtimeInputParametersToVertex(this.apiClient, params)\n            };\n        } else {\n            clientMessage = {\n                \"realtimeInput\": liveSendRealtimeInputParametersToMldev(this.apiClient, params)\n            };\n        }\n        this.conn.send(JSON.stringify(clientMessage));\n    }\n    /**\n      Send a function response message over the established connection.\n  \n      @param params - Contains property `functionResponses`.\n  \n        - `functionResponses` will be converted to a `functionResponses[]`\n  \n      @remarks\n      Use `sendFunctionResponse` to reply to `LiveServerToolCall` from the server.\n  \n      Use {@link types.LiveConnectConfig#tools} to configure the callable functions.\n  \n      @experimental\n     */ sendToolResponse(params) {\n        if (params.functionResponses == null) {\n            throw new Error(\"Tool response parameters are required.\");\n        }\n        const clientMessage = this.tLiveClienttToolResponse(this.apiClient, params);\n        this.conn.send(JSON.stringify(clientMessage));\n    }\n    /**\n       Terminates the WebSocket connection.\n  \n       @experimental\n  \n       @example\n       ```ts\n       let model: string;\n       if (GOOGLE_GENAI_USE_VERTEXAI) {\n         model = 'gemini-2.0-flash-live-preview-04-09';\n       } else {\n         model = 'gemini-2.0-flash-live-001';\n       }\n       const session = await ai.live.connect({\n         model: model,\n         config: {\n           responseModalities: [Modality.AUDIO],\n         }\n       });\n  \n       session.close();\n       ```\n     */ close() {\n        this.conn.close();\n    }\n}\n// Converts an headers object to a \"map\" object as expected by the WebSocket\n// constructor. We use this as the Auth interface works with Headers objects\n// while the WebSocket constructor takes a map.\nfunction headersToMap(headers) {\n    const headerMap = {};\n    headers.forEach((value, key)=>{\n        headerMap[key] = value;\n    });\n    return headerMap;\n}\n// Converts a \"map\" object to a headers object. We use this as the Auth\n// interface works with Headers objects while the API client default headers\n// returns a map.\nfunction mapToHeaders(map) {\n    const headers = new Headers();\n    for (const [key, value] of Object.entries(map)){\n        headers.append(key, value);\n    }\n    return headers;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class Models extends BaseModule {\n    constructor(apiClient){\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Makes an API request to generate content with a given model.\n         *\n         * For the `model` parameter, supported formats for Vertex AI API include:\n         * - The Gemini model ID, for example: 'gemini-2.0-flash'\n         * - The full resource name starts with 'projects/', for example:\n         *  'projects/my-project-id/locations/us-central1/publishers/google/models/gemini-2.0-flash'\n         * - The partial resource name with 'publishers/', for example:\n         *  'publishers/google/models/gemini-2.0-flash' or\n         *  'publishers/meta/models/llama-3.1-405b-instruct-maas'\n         * - `/` separated publisher and model name, for example:\n         * 'google/gemini-2.0-flash' or 'meta/llama-3.1-405b-instruct-maas'\n         *\n         * For the `model` parameter, supported formats for Gemini API include:\n         * - The Gemini model ID, for example: 'gemini-2.0-flash'\n         * - The model name starts with 'models/', for example:\n         *  'models/gemini-2.0-flash'\n         * - For tuned models, the model name starts with 'tunedModels/',\n         * for example:\n         * 'tunedModels/1234567890123456789'\n         *\n         * Some models support multimodal input and output.\n         *\n         * @param params - The parameters for generating content.\n         * @return The response from generating content.\n         *\n         * @example\n         * ```ts\n         * const response = await ai.models.generateContent({\n         *   model: 'gemini-2.0-flash',\n         *   contents: 'why is the sky blue?',\n         *   config: {\n         *     candidateCount: 2,\n         *   }\n         * });\n         * console.log(response);\n         * ```\n         */ this.generateContent = async (params)=>{\n            return await this.generateContentInternal(params);\n        };\n        /**\n         * Makes an API request to generate content with a given model and yields the\n         * response in chunks.\n         *\n         * For the `model` parameter, supported formats for Vertex AI API include:\n         * - The Gemini model ID, for example: 'gemini-2.0-flash'\n         * - The full resource name starts with 'projects/', for example:\n         *  'projects/my-project-id/locations/us-central1/publishers/google/models/gemini-2.0-flash'\n         * - The partial resource name with 'publishers/', for example:\n         *  'publishers/google/models/gemini-2.0-flash' or\n         *  'publishers/meta/models/llama-3.1-405b-instruct-maas'\n         * - `/` separated publisher and model name, for example:\n         * 'google/gemini-2.0-flash' or 'meta/llama-3.1-405b-instruct-maas'\n         *\n         * For the `model` parameter, supported formats for Gemini API include:\n         * - The Gemini model ID, for example: 'gemini-2.0-flash'\n         * - The model name starts with 'models/', for example:\n         *  'models/gemini-2.0-flash'\n         * - For tuned models, the model name starts with 'tunedModels/',\n         * for example:\n         *  'tunedModels/1234567890123456789'\n         *\n         * Some models support multimodal input and output.\n         *\n         * @param params - The parameters for generating content with streaming response.\n         * @return The response from generating content.\n         *\n         * @example\n         * ```ts\n         * const response = await ai.models.generateContentStream({\n         *   model: 'gemini-2.0-flash',\n         *   contents: 'why is the sky blue?',\n         *   config: {\n         *     maxOutputTokens: 200,\n         *   }\n         * });\n         * for await (const chunk of response) {\n         *   console.log(chunk);\n         * }\n         * ```\n         */ this.generateContentStream = async (params)=>{\n            return await this.generateContentStreamInternal(params);\n        };\n        /**\n         * Generates an image based on a text description and configuration.\n         *\n         * @param model - The model to use.\n         * @param prompt - A text description of the image to generate.\n         * @param [config] - The config for image generation.\n         * @return The response from the API.\n         *\n         * @example\n         * ```ts\n         * const response = await client.models.generateImages({\n         *  model: 'imagen-3.0-generate-002',\n         *  prompt: 'Robot holding a red skateboard',\n         *  config: {\n         *    numberOfImages: 1,\n         *    includeRaiReason: true,\n         *  },\n         * });\n         * console.log(response?.generatedImages?.[0]?.image?.imageBytes);\n         * ```\n         */ this.generateImages = async (params)=>{\n            return await this.generateImagesInternal(params).then((apiResponse)=>{\n                var _a;\n                let positivePromptSafetyAttributes;\n                const generatedImages = [];\n                if (apiResponse === null || apiResponse === void 0 ? void 0 : apiResponse.generatedImages) {\n                    for (const generatedImage of apiResponse.generatedImages){\n                        if (generatedImage && (generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes) && ((_a = generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes) === null || _a === void 0 ? void 0 : _a.contentType) === \"Positive Prompt\") {\n                            positivePromptSafetyAttributes = generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes;\n                        } else {\n                            generatedImages.push(generatedImage);\n                        }\n                    }\n                }\n                let response;\n                if (positivePromptSafetyAttributes) {\n                    response = {\n                        generatedImages: generatedImages,\n                        positivePromptSafetyAttributes: positivePromptSafetyAttributes\n                    };\n                } else {\n                    response = {\n                        generatedImages: generatedImages\n                    };\n                }\n                return response;\n            });\n        };\n    }\n    async generateContentInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = generateContentParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:generateContent\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = generateContentResponseFromVertex(this.apiClient, apiResponse);\n                const typedResp = new GenerateContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = generateContentParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{model}:generateContent\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = generateContentResponseFromMldev(this.apiClient, apiResponse);\n                const typedResp = new GenerateContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    async generateContentStreamInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = generateContentParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:streamGenerateContent?alt=sse\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            const apiClient = this.apiClient;\n            response = apiClient.requestStream({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            });\n            return response.then(function(apiResponse) {\n                return __asyncGenerator(this, arguments, function*() {\n                    var _a, e_1, _b, _c;\n                    try {\n                        for(var _d = true, apiResponse_1 = __asyncValues(apiResponse), apiResponse_1_1; apiResponse_1_1 = yield __await(apiResponse_1.next()), _a = apiResponse_1_1.done, !_a; _d = true){\n                            _c = apiResponse_1_1.value;\n                            _d = false;\n                            const chunk = _c;\n                            const resp = generateContentResponseFromVertex(apiClient, (yield __await(chunk.json())));\n                            const typedResp = new GenerateContentResponse();\n                            Object.assign(typedResp, resp);\n                            yield yield __await(typedResp);\n                        }\n                    } catch (e_1_1) {\n                        e_1 = {\n                            error: e_1_1\n                        };\n                    } finally{\n                        try {\n                            if (!_d && !_a && (_b = apiResponse_1.return)) yield __await(_b.call(apiResponse_1));\n                        } finally{\n                            if (e_1) throw e_1.error;\n                        }\n                    }\n                });\n            });\n        } else {\n            const body = generateContentParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{model}:streamGenerateContent?alt=sse\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            const apiClient = this.apiClient;\n            response = apiClient.requestStream({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            });\n            return response.then(function(apiResponse) {\n                return __asyncGenerator(this, arguments, function*() {\n                    var _a, e_2, _b, _c;\n                    try {\n                        for(var _d = true, apiResponse_2 = __asyncValues(apiResponse), apiResponse_2_1; apiResponse_2_1 = yield __await(apiResponse_2.next()), _a = apiResponse_2_1.done, !_a; _d = true){\n                            _c = apiResponse_2_1.value;\n                            _d = false;\n                            const chunk = _c;\n                            const resp = generateContentResponseFromMldev(apiClient, (yield __await(chunk.json())));\n                            const typedResp = new GenerateContentResponse();\n                            Object.assign(typedResp, resp);\n                            yield yield __await(typedResp);\n                        }\n                    } catch (e_2_1) {\n                        e_2 = {\n                            error: e_2_1\n                        };\n                    } finally{\n                        try {\n                            if (!_d && !_a && (_b = apiResponse_2.return)) yield __await(_b.call(apiResponse_2));\n                        } finally{\n                            if (e_2) throw e_2.error;\n                        }\n                    }\n                });\n            });\n        }\n    }\n    /**\n     * Calculates embeddings for the given contents. Only text is supported.\n     *\n     * @param params - The parameters for embedding contents.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.embedContent({\n     *  model: 'text-embedding-004',\n     *  contents: [\n     *    'What is your name?',\n     *    'What is your favorite color?',\n     *  ],\n     *  config: {\n     *    outputDimensionality: 64,\n     *  },\n     * });\n     * console.log(response);\n     * ```\n     */ async embedContent(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = embedContentParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:predict\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = embedContentResponseFromVertex(this.apiClient, apiResponse);\n                const typedResp = new EmbedContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = embedContentParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{model}:batchEmbedContents\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = embedContentResponseFromMldev(this.apiClient, apiResponse);\n                const typedResp = new EmbedContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Generates an image based on a text description and configuration.\n     *\n     * @param params - The parameters for generating images.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.generateImages({\n     *  model: 'imagen-3.0-generate-002',\n     *  prompt: 'Robot holding a red skateboard',\n     *  config: {\n     *    numberOfImages: 1,\n     *    includeRaiReason: true,\n     *  },\n     * });\n     * console.log(response?.generatedImages?.[0]?.image?.imageBytes);\n     * ```\n     */ async generateImagesInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = generateImagesParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:predict\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = generateImagesResponseFromVertex(this.apiClient, apiResponse);\n                const typedResp = new GenerateImagesResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = generateImagesParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{model}:predict\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = generateImagesResponseFromMldev(this.apiClient, apiResponse);\n                const typedResp = new GenerateImagesResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Fetches information about a model by name.\n     *\n     * @example\n     * ```ts\n     * const modelInfo = await ai.models.get({model: 'gemini-2.0-flash'});\n     * ```\n     */ async get(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getModelParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = modelFromVertex(this.apiClient, apiResponse);\n                return resp;\n            });\n        } else {\n            const body = getModelParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = modelFromMldev(this.apiClient, apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Counts the number of tokens in the given contents. Multimodal input is\n     * supported for Gemini models.\n     *\n     * @param params - The parameters for counting tokens.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.countTokens({\n     *  model: 'gemini-2.0-flash',\n     *  contents: 'The quick brown fox jumps over the lazy dog.'\n     * });\n     * console.log(response);\n     * ```\n     */ async countTokens(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = countTokensParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:countTokens\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = countTokensResponseFromVertex(this.apiClient, apiResponse);\n                const typedResp = new CountTokensResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = countTokensParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{model}:countTokens\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = countTokensResponseFromMldev(this.apiClient, apiResponse);\n                const typedResp = new CountTokensResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Given a list of contents, returns a corresponding TokensInfo containing\n     * the list of tokens and list of token ids.\n     *\n     * This method is not supported by the Gemini Developer API.\n     *\n     * @param params - The parameters for computing tokens.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.computeTokens({\n     *  model: 'gemini-2.0-flash',\n     *  contents: 'What is your name?'\n     * });\n     * console.log(response);\n     * ```\n     */ async computeTokens(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = computeTokensParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:computeTokens\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = computeTokensResponseFromVertex(this.apiClient, apiResponse);\n                const typedResp = new ComputeTokensResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            throw new Error(\"This method is only supported by the Vertex AI.\");\n        }\n    }\n    /**\n     *  Generates videos based on a text description and configuration.\n     *\n     * @param params - The parameters for generating videos.\n     * @return A Promise<GenerateVideosOperation> which allows you to track the progress and eventually retrieve the generated videos using the operations.get method.\n     *\n     * @example\n     * ```ts\n     * const operation = await ai.models.generateVideos({\n     *  model: 'veo-2.0-generate-001',\n     *  prompt: 'A neon hologram of a cat driving at top speed',\n     *  config: {\n     *    numberOfVideos: 1\n     * });\n     *\n     * while (!operation.done) {\n     *   await new Promise(resolve => setTimeout(resolve, 10000));\n     *   operation = await ai.operations.getVideosOperation({operation: operation});\n     * }\n     *\n     * console.log(operation.response?.generatedVideos?.[0]?.video?.uri);\n     * ```\n     */ async generateVideos(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = generateVideosParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:predictLongRunning\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = generateVideosOperationFromVertex$1(this.apiClient, apiResponse);\n                return resp;\n            });\n        } else {\n            const body = generateVideosParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{model}:predictLongRunning\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = generateVideosOperationFromMldev$1(this.apiClient, apiResponse);\n                return resp;\n            });\n        }\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ function getOperationParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromOperationName = getValueByPath(fromObject, [\n        \"operationName\"\n    ]);\n    if (fromOperationName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"operationName\"\n        ], fromOperationName);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction getOperationParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromOperationName = getValueByPath(fromObject, [\n        \"operationName\"\n    ]);\n    if (fromOperationName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"operationName\"\n        ], fromOperationName);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction fetchPredictOperationParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromOperationName = getValueByPath(fromObject, [\n        \"operationName\"\n    ]);\n    if (fromOperationName != null) {\n        setValueByPath(toObject, [\n            \"operationName\"\n        ], fromOperationName);\n    }\n    const fromResourceName = getValueByPath(fromObject, [\n        \"resourceName\"\n    ]);\n    if (fromResourceName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"resourceName\"\n        ], fromResourceName);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction videoFromMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, [\n        \"video\",\n        \"uri\"\n    ]);\n    if (fromUri != null) {\n        setValueByPath(toObject, [\n            \"uri\"\n        ], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, [\n        \"video\",\n        \"encodedVideo\"\n    ]);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, [\n            \"videoBytes\"\n        ], tBytes(apiClient, fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"encoding\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction generatedVideoFromMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromVideo = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromVideo != null) {\n        setValueByPath(toObject, [\n            \"video\"\n        ], videoFromMldev(apiClient, fromVideo));\n    }\n    return toObject;\n}\nfunction generateVideosResponseFromMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromGeneratedVideos = getValueByPath(fromObject, [\n        \"generatedSamples\"\n    ]);\n    if (fromGeneratedVideos != null) {\n        if (Array.isArray(fromGeneratedVideos)) {\n            setValueByPath(toObject, [\n                \"generatedVideos\"\n            ], fromGeneratedVideos.map((item)=>{\n                return generatedVideoFromMldev(apiClient, item);\n            }));\n        } else {\n            setValueByPath(toObject, [\n                \"generatedVideos\"\n            ], fromGeneratedVideos);\n        }\n    }\n    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [\n        \"raiMediaFilteredCount\"\n    ]);\n    if (fromRaiMediaFilteredCount != null) {\n        setValueByPath(toObject, [\n            \"raiMediaFilteredCount\"\n        ], fromRaiMediaFilteredCount);\n    }\n    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [\n        \"raiMediaFilteredReasons\"\n    ]);\n    if (fromRaiMediaFilteredReasons != null) {\n        setValueByPath(toObject, [\n            \"raiMediaFilteredReasons\"\n        ], fromRaiMediaFilteredReasons);\n    }\n    return toObject;\n}\nfunction generateVideosOperationFromMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, [\n        \"done\"\n    ]);\n    if (fromDone != null) {\n        setValueByPath(toObject, [\n            \"done\"\n        ], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\",\n        \"generateVideoResponse\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], generateVideosResponseFromMldev(apiClient, fromResponse));\n    }\n    return toObject;\n}\nfunction videoFromVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]);\n    if (fromUri != null) {\n        setValueByPath(toObject, [\n            \"uri\"\n        ], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, [\n        \"bytesBase64Encoded\"\n    ]);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, [\n            \"videoBytes\"\n        ], tBytes(apiClient, fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction generatedVideoFromVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromVideo = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromVideo != null) {\n        setValueByPath(toObject, [\n            \"video\"\n        ], videoFromVertex(apiClient, fromVideo));\n    }\n    return toObject;\n}\nfunction generateVideosResponseFromVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromGeneratedVideos = getValueByPath(fromObject, [\n        \"videos\"\n    ]);\n    if (fromGeneratedVideos != null) {\n        if (Array.isArray(fromGeneratedVideos)) {\n            setValueByPath(toObject, [\n                \"generatedVideos\"\n            ], fromGeneratedVideos.map((item)=>{\n                return generatedVideoFromVertex(apiClient, item);\n            }));\n        } else {\n            setValueByPath(toObject, [\n                \"generatedVideos\"\n            ], fromGeneratedVideos);\n        }\n    }\n    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [\n        \"raiMediaFilteredCount\"\n    ]);\n    if (fromRaiMediaFilteredCount != null) {\n        setValueByPath(toObject, [\n            \"raiMediaFilteredCount\"\n        ], fromRaiMediaFilteredCount);\n    }\n    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [\n        \"raiMediaFilteredReasons\"\n    ]);\n    if (fromRaiMediaFilteredReasons != null) {\n        setValueByPath(toObject, [\n            \"raiMediaFilteredReasons\"\n        ], fromRaiMediaFilteredReasons);\n    }\n    return toObject;\n}\nfunction generateVideosOperationFromVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, [\n        \"done\"\n    ]);\n    if (fromDone != null) {\n        setValueByPath(toObject, [\n            \"done\"\n        ], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], generateVideosResponseFromVertex(apiClient, fromResponse));\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class Operations extends BaseModule {\n    constructor(apiClient){\n        super();\n        this.apiClient = apiClient;\n    }\n    /**\n     * Gets the status of a long-running operation.\n     *\n     * @param parameters The parameters for the get operation request.\n     * @return The updated Operation object, with the latest status or result.\n     */ async getVideosOperation(parameters) {\n        const operation = parameters.operation;\n        const config = parameters.config;\n        if (operation.name === undefined || operation.name === \"\") {\n            throw new Error(\"Operation name is required.\");\n        }\n        if (this.apiClient.isVertexAI()) {\n            const resourceName = operation.name.split(\"/operations/\")[0];\n            let httpOptions = undefined;\n            if (config && \"httpOptions\" in config) {\n                httpOptions = config.httpOptions;\n            }\n            return this.fetchPredictVideosOperationInternal({\n                operationName: operation.name,\n                resourceName: resourceName,\n                config: {\n                    httpOptions: httpOptions\n                }\n            });\n        } else {\n            return this.getVideosOperationInternal({\n                operationName: operation.name,\n                config: config\n            });\n        }\n    }\n    async getVideosOperationInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getOperationParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{operationName}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = generateVideosOperationFromVertex(this.apiClient, apiResponse);\n                return resp;\n            });\n        } else {\n            const body = getOperationParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{operationName}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = generateVideosOperationFromMldev(this.apiClient, apiResponse);\n                return resp;\n            });\n        }\n    }\n    async fetchPredictVideosOperationInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = fetchPredictOperationParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{resourceName}:fetchPredictOperation\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = generateVideosOperationFromVertex(this.apiClient, apiResponse);\n                return resp;\n            });\n        } else {\n            throw new Error(\"This method is only supported by the Vertex AI.\");\n        }\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ const CONTENT_TYPE_HEADER = \"Content-Type\";\nconst SERVER_TIMEOUT_HEADER = \"X-Server-Timeout\";\nconst USER_AGENT_HEADER = \"User-Agent\";\nconst GOOGLE_API_CLIENT_HEADER = \"x-goog-api-client\";\nconst SDK_VERSION = \"0.10.0\"; // x-release-please-version\nconst LIBRARY_LABEL = `google-genai-sdk/${SDK_VERSION}`;\nconst VERTEX_AI_API_DEFAULT_VERSION = \"v1beta1\";\nconst GOOGLE_AI_API_DEFAULT_VERSION = \"v1beta\";\nconst responseLineRE = /^data: (.*)(?:\\n\\n|\\r\\r|\\r\\n\\r\\n)/;\n/**\n * Client errors raised by the GenAI API.\n */ class ClientError extends Error {\n    constructor(message, stackTrace){\n        if (stackTrace) {\n            super(message, {\n                cause: stackTrace\n            });\n        } else {\n            super(message, {\n                cause: new Error().stack\n            });\n        }\n        this.message = message;\n        this.name = \"ClientError\";\n    }\n}\n/**\n * Server errors raised by the GenAI API.\n */ class ServerError extends Error {\n    constructor(message, stackTrace){\n        if (stackTrace) {\n            super(message, {\n                cause: stackTrace\n            });\n        } else {\n            super(message, {\n                cause: new Error().stack\n            });\n        }\n        this.message = message;\n        this.name = \"ServerError\";\n    }\n}\n/**\n * The ApiClient class is used to send requests to the Gemini API or Vertex AI\n * endpoints.\n */ class ApiClient {\n    constructor(opts){\n        var _a, _b;\n        this.clientOptions = Object.assign(Object.assign({}, opts), {\n            project: opts.project,\n            location: opts.location,\n            apiKey: opts.apiKey,\n            vertexai: opts.vertexai\n        });\n        const initHttpOptions = {};\n        if (this.clientOptions.vertexai) {\n            initHttpOptions.apiVersion = (_a = this.clientOptions.apiVersion) !== null && _a !== void 0 ? _a : VERTEX_AI_API_DEFAULT_VERSION;\n            // Assume that proj/api key validation occurs before they are passed in.\n            if (this.getProject() || this.getLocation()) {\n                initHttpOptions.baseUrl = `https://${this.clientOptions.location}-aiplatform.googleapis.com/`;\n                this.clientOptions.apiKey = undefined; // unset API key.\n            } else {\n                initHttpOptions.baseUrl = `https://aiplatform.googleapis.com/`;\n                this.clientOptions.project = undefined; // unset project.\n                this.clientOptions.location = undefined; // unset location.\n            }\n        } else {\n            initHttpOptions.apiVersion = (_b = this.clientOptions.apiVersion) !== null && _b !== void 0 ? _b : GOOGLE_AI_API_DEFAULT_VERSION;\n            initHttpOptions.baseUrl = `https://generativelanguage.googleapis.com/`;\n        }\n        initHttpOptions.headers = this.getDefaultHeaders();\n        this.clientOptions.httpOptions = initHttpOptions;\n        if (opts.httpOptions) {\n            this.clientOptions.httpOptions = this.patchHttpOptions(initHttpOptions, opts.httpOptions);\n        }\n    }\n    isVertexAI() {\n        var _a;\n        return (_a = this.clientOptions.vertexai) !== null && _a !== void 0 ? _a : false;\n    }\n    getProject() {\n        return this.clientOptions.project;\n    }\n    getLocation() {\n        return this.clientOptions.location;\n    }\n    getApiVersion() {\n        if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.apiVersion !== undefined) {\n            return this.clientOptions.httpOptions.apiVersion;\n        }\n        throw new Error(\"API version is not set.\");\n    }\n    getBaseUrl() {\n        if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.baseUrl !== undefined) {\n            return this.clientOptions.httpOptions.baseUrl;\n        }\n        throw new Error(\"Base URL is not set.\");\n    }\n    getRequestUrl() {\n        return this.getRequestUrlInternal(this.clientOptions.httpOptions);\n    }\n    getHeaders() {\n        if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.headers !== undefined) {\n            return this.clientOptions.httpOptions.headers;\n        } else {\n            throw new Error(\"Headers are not set.\");\n        }\n    }\n    getRequestUrlInternal(httpOptions) {\n        if (!httpOptions || httpOptions.baseUrl === undefined || httpOptions.apiVersion === undefined) {\n            throw new Error(\"HTTP options are not correctly set.\");\n        }\n        const baseUrl = httpOptions.baseUrl.endsWith(\"/\") ? httpOptions.baseUrl.slice(0, -1) : httpOptions.baseUrl;\n        const urlElement = [\n            baseUrl\n        ];\n        if (httpOptions.apiVersion && httpOptions.apiVersion !== \"\") {\n            urlElement.push(httpOptions.apiVersion);\n        }\n        return urlElement.join(\"/\");\n    }\n    getBaseResourcePath() {\n        return `projects/${this.clientOptions.project}/locations/${this.clientOptions.location}`;\n    }\n    getApiKey() {\n        return this.clientOptions.apiKey;\n    }\n    getWebsocketBaseUrl() {\n        const baseUrl = this.getBaseUrl();\n        const urlParts = new URL(baseUrl);\n        urlParts.protocol = urlParts.protocol == \"http:\" ? \"ws\" : \"wss\";\n        return urlParts.toString();\n    }\n    setBaseUrl(url) {\n        if (this.clientOptions.httpOptions) {\n            this.clientOptions.httpOptions.baseUrl = url;\n        } else {\n            throw new Error(\"HTTP options are not correctly set.\");\n        }\n    }\n    constructUrl(path, httpOptions, prependProjectLocation) {\n        const urlElement = [\n            this.getRequestUrlInternal(httpOptions)\n        ];\n        if (prependProjectLocation) {\n            urlElement.push(this.getBaseResourcePath());\n        }\n        if (path !== \"\") {\n            urlElement.push(path);\n        }\n        const url = new URL(`${urlElement.join(\"/\")}`);\n        return url;\n    }\n    shouldPrependVertexProjectPath(request) {\n        if (this.clientOptions.apiKey) {\n            return false;\n        }\n        if (!this.clientOptions.vertexai) {\n            return false;\n        }\n        if (request.path.startsWith(\"projects/\")) {\n            // Assume the path already starts with\n            // `projects/<project>/location/<location>`.\n            return false;\n        }\n        if (request.httpMethod === \"GET\" && request.path.startsWith(\"publishers/google/models\")) {\n            // These paths are used by Vertex's models.get and models.list\n            // calls. For base models Vertex does not accept a project/location\n            // prefix (for tuned model the prefix is required).\n            return false;\n        }\n        return true;\n    }\n    async request(request) {\n        let patchedHttpOptions = this.clientOptions.httpOptions;\n        if (request.httpOptions) {\n            patchedHttpOptions = this.patchHttpOptions(this.clientOptions.httpOptions, request.httpOptions);\n        }\n        const prependProjectLocation = this.shouldPrependVertexProjectPath(request);\n        const url = this.constructUrl(request.path, patchedHttpOptions, prependProjectLocation);\n        if (request.queryParams) {\n            for (const [key, value] of Object.entries(request.queryParams)){\n                url.searchParams.append(key, String(value));\n            }\n        }\n        let requestInit = {};\n        if (request.httpMethod === \"GET\") {\n            if (request.body && request.body !== \"{}\") {\n                throw new Error(\"Request body should be empty for GET request, but got non empty request body\");\n            }\n        } else {\n            requestInit.body = request.body;\n        }\n        requestInit = await this.includeExtraHttpOptionsToRequestInit(requestInit, patchedHttpOptions, request.abortSignal);\n        return this.unaryApiCall(url, requestInit, request.httpMethod);\n    }\n    patchHttpOptions(baseHttpOptions, requestHttpOptions) {\n        const patchedHttpOptions = JSON.parse(JSON.stringify(baseHttpOptions));\n        for (const [key, value] of Object.entries(requestHttpOptions)){\n            // Records compile to objects.\n            if (typeof value === \"object\") {\n                // @ts-expect-error TS2345TS7053: Element implicitly has an 'any' type\n                // because expression of type 'string' can't be used to index type\n                // 'HttpOptions'.\n                patchedHttpOptions[key] = Object.assign(Object.assign({}, patchedHttpOptions[key]), value);\n            } else if (value !== undefined) {\n                // @ts-expect-error TS2345TS7053: Element implicitly has an 'any' type\n                // because expression of type 'string' can't be used to index type\n                // 'HttpOptions'.\n                patchedHttpOptions[key] = value;\n            }\n        }\n        return patchedHttpOptions;\n    }\n    async requestStream(request) {\n        let patchedHttpOptions = this.clientOptions.httpOptions;\n        if (request.httpOptions) {\n            patchedHttpOptions = this.patchHttpOptions(this.clientOptions.httpOptions, request.httpOptions);\n        }\n        const prependProjectLocation = this.shouldPrependVertexProjectPath(request);\n        const url = this.constructUrl(request.path, patchedHttpOptions, prependProjectLocation);\n        if (!url.searchParams.has(\"alt\") || url.searchParams.get(\"alt\") !== \"sse\") {\n            url.searchParams.set(\"alt\", \"sse\");\n        }\n        let requestInit = {};\n        requestInit.body = request.body;\n        requestInit = await this.includeExtraHttpOptionsToRequestInit(requestInit, patchedHttpOptions, request.abortSignal);\n        return this.streamApiCall(url, requestInit, request.httpMethod);\n    }\n    async includeExtraHttpOptionsToRequestInit(requestInit, httpOptions, abortSignal) {\n        if (httpOptions && httpOptions.timeout || abortSignal) {\n            const abortController = new AbortController();\n            const signal = abortController.signal;\n            if (httpOptions.timeout && (httpOptions === null || httpOptions === void 0 ? void 0 : httpOptions.timeout) > 0) {\n                setTimeout(()=>abortController.abort(), httpOptions.timeout);\n            }\n            if (abortSignal) {\n                abortSignal.addEventListener(\"abort\", ()=>{\n                    abortController.abort();\n                });\n            }\n            requestInit.signal = signal;\n        }\n        requestInit.headers = await this.getHeadersInternal(httpOptions);\n        return requestInit;\n    }\n    async unaryApiCall(url, requestInit, httpMethod) {\n        return this.apiCall(url.toString(), Object.assign(Object.assign({}, requestInit), {\n            method: httpMethod\n        })).then(async (response)=>{\n            await throwErrorIfNotOK(response);\n            return new HttpResponse(response);\n        }).catch((e)=>{\n            if (e instanceof Error) {\n                throw e;\n            } else {\n                throw new Error(JSON.stringify(e));\n            }\n        });\n    }\n    async streamApiCall(url, requestInit, httpMethod) {\n        return this.apiCall(url.toString(), Object.assign(Object.assign({}, requestInit), {\n            method: httpMethod\n        })).then(async (response)=>{\n            await throwErrorIfNotOK(response);\n            return this.processStreamResponse(response);\n        }).catch((e)=>{\n            if (e instanceof Error) {\n                throw e;\n            } else {\n                throw new Error(JSON.stringify(e));\n            }\n        });\n    }\n    processStreamResponse(response) {\n        var _a;\n        return __asyncGenerator(this, arguments, function* processStreamResponse_1() {\n            const reader = (_a = response === null || response === void 0 ? void 0 : response.body) === null || _a === void 0 ? void 0 : _a.getReader();\n            const decoder = new TextDecoder(\"utf-8\");\n            if (!reader) {\n                throw new Error(\"Response body is empty\");\n            }\n            try {\n                let buffer = \"\";\n                while(true){\n                    const { done, value } = yield __await(reader.read());\n                    if (done) {\n                        if (buffer.trim().length > 0) {\n                            throw new Error(\"Incomplete JSON segment at the end\");\n                        }\n                        break;\n                    }\n                    const chunkString = decoder.decode(value);\n                    // Parse and throw an error if the chunk contains an error.\n                    try {\n                        const chunkJson = JSON.parse(chunkString);\n                        if (\"error\" in chunkJson) {\n                            const errorJson = JSON.parse(JSON.stringify(chunkJson[\"error\"]));\n                            const status = errorJson[\"status\"];\n                            const code = errorJson[\"code\"];\n                            const errorMessage = `got status: ${status}. ${JSON.stringify(chunkJson)}`;\n                            if (code >= 400 && code < 500) {\n                                const clientError = new ClientError(errorMessage);\n                                throw clientError;\n                            } else if (code >= 500 && code < 600) {\n                                const serverError = new ServerError(errorMessage);\n                                throw serverError;\n                            }\n                        }\n                    } catch (e) {\n                        const error = e;\n                        if (error.name === \"ClientError\" || error.name === \"ServerError\") {\n                            throw e;\n                        }\n                    }\n                    buffer += chunkString;\n                    let match = buffer.match(responseLineRE);\n                    while(match){\n                        const processedChunkString = match[1];\n                        try {\n                            const partialResponse = new Response(processedChunkString, {\n                                headers: response === null || response === void 0 ? void 0 : response.headers,\n                                status: response === null || response === void 0 ? void 0 : response.status,\n                                statusText: response === null || response === void 0 ? void 0 : response.statusText\n                            });\n                            yield yield __await(new HttpResponse(partialResponse));\n                            buffer = buffer.slice(match[0].length);\n                            match = buffer.match(responseLineRE);\n                        } catch (e) {\n                            throw new Error(`exception parsing stream chunk ${processedChunkString}. ${e}`);\n                        }\n                    }\n                }\n            } finally{\n                reader.releaseLock();\n            }\n        });\n    }\n    async apiCall(url, requestInit) {\n        return fetch(url, requestInit).catch((e)=>{\n            throw new Error(`exception ${e} sending request`);\n        });\n    }\n    getDefaultHeaders() {\n        const headers = {};\n        const versionHeaderValue = LIBRARY_LABEL + \" \" + this.clientOptions.userAgentExtra;\n        headers[USER_AGENT_HEADER] = versionHeaderValue;\n        headers[GOOGLE_API_CLIENT_HEADER] = versionHeaderValue;\n        headers[CONTENT_TYPE_HEADER] = \"application/json\";\n        return headers;\n    }\n    async getHeadersInternal(httpOptions) {\n        const headers = new Headers();\n        if (httpOptions && httpOptions.headers) {\n            for (const [key, value] of Object.entries(httpOptions.headers)){\n                headers.append(key, value);\n            }\n            // Append a timeout header if it is set, note that the timeout option is\n            // in milliseconds but the header is in seconds.\n            if (httpOptions.timeout && httpOptions.timeout > 0) {\n                headers.append(SERVER_TIMEOUT_HEADER, String(Math.ceil(httpOptions.timeout / 1000)));\n            }\n        }\n        await this.clientOptions.auth.addAuthHeaders(headers);\n        return headers;\n    }\n    /**\n     * Uploads a file asynchronously using Gemini API only, this is not supported\n     * in Vertex AI.\n     *\n     * @param file The string path to the file to be uploaded or a Blob object.\n     * @param config Optional parameters specified in the `UploadFileConfig`\n     *     interface. @see {@link UploadFileConfig}\n     * @return A promise that resolves to a `File` object.\n     * @throws An error if called on a Vertex AI client.\n     * @throws An error if the `mimeType` is not provided and can not be inferred,\n     */ async uploadFile(file, config) {\n        var _a;\n        const fileToUpload = {};\n        if (config != null) {\n            fileToUpload.mimeType = config.mimeType;\n            fileToUpload.name = config.name;\n            fileToUpload.displayName = config.displayName;\n        }\n        if (fileToUpload.name && !fileToUpload.name.startsWith(\"files/\")) {\n            fileToUpload.name = `files/${fileToUpload.name}`;\n        }\n        const uploader = this.clientOptions.uploader;\n        const fileStat = await uploader.stat(file);\n        fileToUpload.sizeBytes = String(fileStat.size);\n        const mimeType = (_a = config === null || config === void 0 ? void 0 : config.mimeType) !== null && _a !== void 0 ? _a : fileStat.type;\n        if (mimeType === undefined || mimeType === \"\") {\n            throw new Error(\"Can not determine mimeType. Please provide mimeType in the config.\");\n        }\n        fileToUpload.mimeType = mimeType;\n        const uploadUrl = await this.fetchUploadUrl(fileToUpload, config);\n        return uploader.upload(file, uploadUrl, this);\n    }\n    async fetchUploadUrl(file, config) {\n        var _a;\n        let httpOptions = {};\n        if (config === null || config === void 0 ? void 0 : config.httpOptions) {\n            httpOptions = config.httpOptions;\n        } else {\n            httpOptions = {\n                apiVersion: \"\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    \"X-Goog-Upload-Protocol\": \"resumable\",\n                    \"X-Goog-Upload-Command\": \"start\",\n                    \"X-Goog-Upload-Header-Content-Length\": `${file.sizeBytes}`,\n                    \"X-Goog-Upload-Header-Content-Type\": `${file.mimeType}`\n                }\n            };\n        }\n        const body = {\n            \"file\": file\n        };\n        const httpResponse = await this.request({\n            path: formatMap(\"upload/v1beta/files\", body[\"_url\"]),\n            body: JSON.stringify(body),\n            httpMethod: \"POST\",\n            httpOptions\n        });\n        if (!httpResponse || !(httpResponse === null || httpResponse === void 0 ? void 0 : httpResponse.headers)) {\n            throw new Error(\"Server did not return an HttpResponse or the returned HttpResponse did not have headers.\");\n        }\n        const uploadUrl = (_a = httpResponse === null || httpResponse === void 0 ? void 0 : httpResponse.headers) === null || _a === void 0 ? void 0 : _a[\"x-goog-upload-url\"];\n        if (uploadUrl === undefined) {\n            throw new Error(\"Failed to get upload url. Server did not return the x-google-upload-url in the headers\");\n        }\n        return uploadUrl;\n    }\n}\nasync function throwErrorIfNotOK(response) {\n    var _a;\n    if (response === undefined) {\n        throw new ServerError(\"response is undefined\");\n    }\n    if (!response.ok) {\n        const status = response.status;\n        const statusText = response.statusText;\n        let errorBody;\n        if ((_a = response.headers.get(\"content-type\")) === null || _a === void 0 ? void 0 : _a.includes(\"application/json\")) {\n            errorBody = await response.json();\n        } else {\n            errorBody = {\n                error: {\n                    message: await response.text(),\n                    code: response.status,\n                    status: response.statusText\n                }\n            };\n        }\n        const errorMessage = `got status: ${status} ${statusText}. ${JSON.stringify(errorBody)}`;\n        if (status >= 400 && status < 500) {\n            const clientError = new ClientError(errorMessage);\n            throw clientError;\n        } else if (status >= 500 && status < 600) {\n            const serverError = new ServerError(errorMessage);\n            throw serverError;\n        }\n        throw new Error(errorMessage);\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ const GOOGLE_API_KEY_HEADER = \"x-goog-api-key\";\nconst REQUIRED_VERTEX_AI_SCOPE = \"https://www.googleapis.com/auth/cloud-platform\";\nclass NodeAuth {\n    constructor(opts){\n        if (opts.apiKey !== undefined) {\n            this.apiKey = opts.apiKey;\n            return;\n        }\n        const vertexAuthOptions = buildGoogleAuthOptions(opts.googleAuthOptions);\n        this.googleAuth = new googleAuthLibrary.GoogleAuth(vertexAuthOptions);\n    }\n    async addAuthHeaders(headers) {\n        if (this.apiKey !== undefined) {\n            this.addKeyHeader(headers);\n            return;\n        }\n        return this.addGoogleAuthHeaders(headers);\n    }\n    addKeyHeader(headers) {\n        if (headers.get(GOOGLE_API_KEY_HEADER) !== null) {\n            return;\n        }\n        if (this.apiKey === undefined) {\n            // This should never happen, this method is only called\n            // when apiKey is set.\n            throw new Error(\"Trying to set API key header but apiKey is not set\");\n        }\n        headers.append(GOOGLE_API_KEY_HEADER, this.apiKey);\n    }\n    async addGoogleAuthHeaders(headers) {\n        if (this.googleAuth === undefined) {\n            // This should never happen, addGoogleAuthHeaders should only be\n            // called when there is no apiKey set and in these cases googleAuth\n            // is set.\n            throw new Error(\"Trying to set google-auth headers but googleAuth is unset\");\n        }\n        const authHeaders = await this.googleAuth.getRequestHeaders();\n        for(const key in authHeaders){\n            if (headers.get(key) !== null) {\n                continue;\n            }\n            headers.append(key, authHeaders[key]);\n        }\n    }\n}\nfunction buildGoogleAuthOptions(googleAuthOptions) {\n    let authOptions;\n    if (!googleAuthOptions) {\n        authOptions = {\n            scopes: [\n                REQUIRED_VERTEX_AI_SCOPE\n            ]\n        };\n        return authOptions;\n    } else {\n        authOptions = googleAuthOptions;\n        if (!authOptions.scopes) {\n            authOptions.scopes = [\n                REQUIRED_VERTEX_AI_SCOPE\n            ];\n            return authOptions;\n        } else if (typeof authOptions.scopes === \"string\" && authOptions.scopes !== REQUIRED_VERTEX_AI_SCOPE || Array.isArray(authOptions.scopes) && authOptions.scopes.indexOf(REQUIRED_VERTEX_AI_SCOPE) < 0) {\n            throw new Error(`Invalid auth scopes. Scopes must include: ${REQUIRED_VERTEX_AI_SCOPE}`);\n        }\n        return authOptions;\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class NodeWebSocketFactory {\n    create(url, headers, callbacks) {\n        return new NodeWebSocket(url, headers, callbacks);\n    }\n}\nclass NodeWebSocket {\n    constructor(url, headers, callbacks){\n        this.url = url;\n        this.headers = headers;\n        this.callbacks = callbacks;\n    }\n    connect() {\n        this.ws = new NodeWs__namespace.WebSocket(this.url, {\n            headers: this.headers\n        });\n        this.ws.onopen = this.callbacks.onopen;\n        this.ws.onerror = this.callbacks.onerror;\n        this.ws.onclose = this.callbacks.onclose;\n        this.ws.onmessage = this.callbacks.onmessage;\n    }\n    send(message) {\n        if (this.ws === undefined) {\n            throw new Error(\"WebSocket is not connected\");\n        }\n        this.ws.send(message);\n    }\n    close() {\n        if (this.ws === undefined) {\n            throw new Error(\"WebSocket is not connected\");\n        }\n        this.ws.close();\n    }\n}\nconst MAX_CHUNK_SIZE = 1024 * 1024 * 8; // bytes\nasync function uploadBlob(file, uploadUrl, apiClient) {\n    var _a, _b;\n    let fileSize = 0;\n    let offset = 0;\n    let response = new HttpResponse(new Response());\n    let uploadCommand = \"upload\";\n    fileSize = file.size;\n    while(offset < fileSize){\n        const chunkSize = Math.min(MAX_CHUNK_SIZE, fileSize - offset);\n        const chunk = file.slice(offset, offset + chunkSize);\n        if (offset + chunkSize >= fileSize) {\n            uploadCommand += \", finalize\";\n        }\n        response = await apiClient.request({\n            path: \"\",\n            body: chunk,\n            httpMethod: \"POST\",\n            httpOptions: {\n                apiVersion: \"\",\n                baseUrl: uploadUrl,\n                headers: {\n                    \"X-Goog-Upload-Command\": uploadCommand,\n                    \"X-Goog-Upload-Offset\": String(offset),\n                    \"Content-Length\": String(chunkSize)\n                }\n            }\n        });\n        offset += chunkSize;\n        // The `x-goog-upload-status` header field can be `active`, `final` and\n        //`cancelled` in resposne.\n        if (((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a[\"x-goog-upload-status\"]) !== \"active\") {\n            break;\n        }\n        // TODO(b/401391430) Investigate why the upload status is not finalized\n        // even though all content has been uploaded.\n        if (fileSize <= offset) {\n            throw new Error(\"All content has been uploaded, but the upload status is not finalized.\");\n        }\n    }\n    const responseJson = await (response === null || response === void 0 ? void 0 : response.json());\n    if (((_b = response === null || response === void 0 ? void 0 : response.headers) === null || _b === void 0 ? void 0 : _b[\"x-goog-upload-status\"]) !== \"final\") {\n        throw new Error(\"Failed to upload file: Upload status is not finalized.\");\n    }\n    return responseJson[\"file\"];\n}\nasync function getBlobStat(file) {\n    const fileStat = {\n        size: file.size,\n        type: file.type\n    };\n    return fileStat;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class NodeUploader {\n    async stat(file) {\n        const fileStat = {\n            size: 0,\n            type: undefined\n        };\n        if (typeof file === \"string\") {\n            const originalStat = await fs__namespace.stat(file);\n            fileStat.size = originalStat.size;\n            fileStat.type = this.inferMimeType(file);\n            return fileStat;\n        } else {\n            return await getBlobStat(file);\n        }\n    }\n    async upload(file, uploadUrl, apiClient) {\n        if (typeof file === \"string\") {\n            return await this.uploadFileFromPath(file, uploadUrl, apiClient);\n        } else {\n            return uploadBlob(file, uploadUrl, apiClient);\n        }\n    }\n    /**\n     * Infers the MIME type of a file based on its extension.\n     *\n     * @param filePath The path to the file.\n     * @returns The MIME type of the file, or undefined if it cannot be inferred.\n     */ inferMimeType(filePath) {\n        // Get the file extension.\n        const fileExtension = filePath.slice(filePath.lastIndexOf(\".\") + 1);\n        // Create a map of file extensions to MIME types.\n        const mimeTypes = {\n            \"aac\": \"audio/aac\",\n            \"abw\": \"application/x-abiword\",\n            \"arc\": \"application/x-freearc\",\n            \"avi\": \"video/x-msvideo\",\n            \"azw\": \"application/vnd.amazon.ebook\",\n            \"bin\": \"application/octet-stream\",\n            \"bmp\": \"image/bmp\",\n            \"bz\": \"application/x-bzip\",\n            \"bz2\": \"application/x-bzip2\",\n            \"csh\": \"application/x-csh\",\n            \"css\": \"text/css\",\n            \"csv\": \"text/csv\",\n            \"doc\": \"application/msword\",\n            \"docx\": \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\",\n            \"eot\": \"application/vnd.ms-fontobject\",\n            \"epub\": \"application/epub+zip\",\n            \"gz\": \"application/gzip\",\n            \"gif\": \"image/gif\",\n            \"htm\": \"text/html\",\n            \"html\": \"text/html\",\n            \"ico\": \"image/vnd.microsoft.icon\",\n            \"ics\": \"text/calendar\",\n            \"jar\": \"application/java-archive\",\n            \"jpeg\": \"image/jpeg\",\n            \"jpg\": \"image/jpeg\",\n            \"js\": \"text/javascript\",\n            \"json\": \"application/json\",\n            \"jsonld\": \"application/ld+json\",\n            \"kml\": \"application/vnd.google-earth.kml+xml\",\n            \"kmz\": \"application/vnd.google-earth.kmz+xml\",\n            \"mjs\": \"text/javascript\",\n            \"mp3\": \"audio/mpeg\",\n            \"mp4\": \"video/mp4\",\n            \"mpeg\": \"video/mpeg\",\n            \"mpkg\": \"application/vnd.apple.installer+xml\",\n            \"odt\": \"application/vnd.oasis.opendocument.text\",\n            \"oga\": \"audio/ogg\",\n            \"ogv\": \"video/ogg\",\n            \"ogx\": \"application/ogg\",\n            \"opus\": \"audio/opus\",\n            \"otf\": \"font/otf\",\n            \"png\": \"image/png\",\n            \"pdf\": \"application/pdf\",\n            \"php\": \"application/x-httpd-php\",\n            \"ppt\": \"application/vnd.ms-powerpoint\",\n            \"pptx\": \"application/vnd.openxmlformats-officedocument.presentationml.presentation\",\n            \"rar\": \"application/vnd.rar\",\n            \"rtf\": \"application/rtf\",\n            \"sh\": \"application/x-sh\",\n            \"svg\": \"image/svg+xml\",\n            \"swf\": \"application/x-shockwave-flash\",\n            \"tar\": \"application/x-tar\",\n            \"tif\": \"image/tiff\",\n            \"tiff\": \"image/tiff\",\n            \"ts\": \"video/mp2t\",\n            \"ttf\": \"font/ttf\",\n            \"txt\": \"text/plain\",\n            \"vsd\": \"application/vnd.visio\",\n            \"wav\": \"audio/wav\",\n            \"weba\": \"audio/webm\",\n            \"webm\": \"video/webm\",\n            \"webp\": \"image/webp\",\n            \"woff\": \"font/woff\",\n            \"woff2\": \"font/woff2\",\n            \"xhtml\": \"application/xhtml+xml\",\n            \"xls\": \"application/vnd.ms-excel\",\n            \"xlsx\": \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\",\n            \"xml\": \"application/xml\",\n            \"xul\": \"application/vnd.mozilla.xul+xml\",\n            \"zip\": \"application/zip\",\n            \"3gp\": \"video/3gpp\",\n            \"3g2\": \"video/3gpp2\",\n            \"7z\": \"application/x-7z-compressed\"\n        };\n        // Look up the MIME type based on the file extension.\n        const mimeType = mimeTypes[fileExtension.toLowerCase()];\n        // Return the MIME type.\n        return mimeType;\n    }\n    async uploadFileFromPath(file, uploadUrl, apiClient) {\n        var _a, _b;\n        let fileSize = 0;\n        let offset = 0;\n        let response = new HttpResponse(new Response());\n        let uploadCommand = \"upload\";\n        let fileHandle;\n        try {\n            fileHandle = await fs__namespace.open(file, \"r\");\n            if (!fileHandle) {\n                throw new Error(`Failed to open file`);\n            }\n            fileSize = (await fileHandle.stat()).size;\n            while(offset < fileSize){\n                const chunkSize = Math.min(MAX_CHUNK_SIZE, fileSize - offset);\n                if (offset + chunkSize >= fileSize) {\n                    uploadCommand += \", finalize\";\n                }\n                const buffer = new Uint8Array(chunkSize);\n                const { bytesRead: bytesRead } = await fileHandle.read(buffer, 0, chunkSize, offset);\n                if (bytesRead !== chunkSize) {\n                    throw new Error(`Failed to read ${chunkSize} bytes from file at offset ${offset}. bytes actually read: ${bytesRead}`);\n                }\n                const chunk = new Blob([\n                    buffer\n                ]);\n                response = await apiClient.request({\n                    path: \"\",\n                    body: chunk,\n                    httpMethod: \"POST\",\n                    httpOptions: {\n                        apiVersion: \"\",\n                        baseUrl: uploadUrl,\n                        headers: {\n                            \"X-Goog-Upload-Command\": uploadCommand,\n                            \"X-Goog-Upload-Offset\": String(offset),\n                            \"Content-Length\": String(bytesRead)\n                        }\n                    }\n                });\n                offset += bytesRead;\n                // The `x-goog-upload-status` header field can be `active`, `final` and\n                //`cancelled` in resposne.\n                if (((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a[\"x-goog-upload-status\"]) !== \"active\") {\n                    break;\n                }\n                if (fileSize <= offset) {\n                    throw new Error(\"All content has been uploaded, but the upload status is not finalized.\");\n                }\n            }\n            const responseJson = await (response === null || response === void 0 ? void 0 : response.json());\n            if (((_b = response === null || response === void 0 ? void 0 : response.headers) === null || _b === void 0 ? void 0 : _b[\"x-goog-upload-status\"]) !== \"final\") {\n                throw new Error(\"Failed to upload file: Upload status is not finalized.\");\n            }\n            return responseJson[\"file\"];\n        } finally{\n            // Ensure the file handle is always closed\n            if (fileHandle) {\n                await fileHandle.close();\n            }\n        }\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ const LANGUAGE_LABEL_PREFIX = \"gl-node/\";\n/**\n * The Google GenAI SDK.\n *\n * @remarks\n * Provides access to the GenAI features through either the {@link\n * https://cloud.google.com/vertex-ai/docs/reference/rest | Gemini API} or\n * the {@link https://cloud.google.com/vertex-ai/docs/reference/rest | Vertex AI\n * API}.\n *\n * The {@link GoogleGenAIOptions.vertexai} value determines which of the API\n * services to use.\n *\n * When using the Gemini API, a {@link GoogleGenAIOptions.apiKey} must also be\n * set. When using Vertex AI, both {@link GoogleGenAIOptions.project} and {@link\n * GoogleGenAIOptions.location} must be set, or a {@link\n * GoogleGenAIOptions.apiKey} must be set when using Express Mode.\n *\n * Explicitly passed in values in {@link GoogleGenAIOptions} will always take\n * precedence over environment variables. If both project/location and api_key\n * exist in the environment variables, the project/location will be used.\n *\n * @example\n * Initializing the SDK for using the Gemini API:\n * ```ts\n * import {GoogleGenAI} from '@google/genai';\n * const ai = new GoogleGenAI({apiKey: 'GEMINI_API_KEY'});\n * ```\n *\n * @example\n * Initializing the SDK for using the Vertex AI API:\n * ```ts\n * import {GoogleGenAI} from '@google/genai';\n * const ai = new GoogleGenAI({\n *   vertexai: true,\n *   project: 'PROJECT_ID',\n *   location: 'PROJECT_LOCATION'\n * });\n * ```\n *\n */ class GoogleGenAI {\n    constructor(options){\n        var _a, _b, _c, _d, _e;\n        // Validate explicitly set initializer values.\n        if ((options.project || options.location) && options.apiKey) {\n            throw new Error(\"Project/location and API key are mutually exclusive in the client initializer.\");\n        }\n        this.vertexai = (_b = (_a = options.vertexai) !== null && _a !== void 0 ? _a : getBooleanEnv(\"GOOGLE_GENAI_USE_VERTEXAI\")) !== null && _b !== void 0 ? _b : false;\n        const envApiKey = getEnv(\"GOOGLE_API_KEY\");\n        const envProject = getEnv(\"GOOGLE_CLOUD_PROJECT\");\n        const envLocation = getEnv(\"GOOGLE_CLOUD_LOCATION\");\n        this.apiKey = (_c = options.apiKey) !== null && _c !== void 0 ? _c : envApiKey;\n        this.project = (_d = options.project) !== null && _d !== void 0 ? _d : envProject;\n        this.location = (_e = options.location) !== null && _e !== void 0 ? _e : envLocation;\n        // Handle when to use Vertex AI in express mode (api key)\n        if (options.vertexai) {\n            // Explicit api_key and explicit project/location already handled above.\n            if ((envProject || envLocation) && options.apiKey) {\n                // Explicit api_key takes precedence over implicit project/location.\n                console.debug(\"The user provided Vertex AI API key will take precedence over\" + \" the project/location from the environment variables.\");\n                this.project = undefined;\n                this.location = undefined;\n            } else if ((options.project || options.location) && envApiKey) {\n                // Explicit project/location takes precedence over implicit api_key.\n                console.debug(\"The user provided project/location will take precedence over\" + \" the API key from the environment variables.\");\n                this.apiKey = undefined;\n            } else if ((envProject || envLocation) && envApiKey) {\n                // Implicit project/location takes precedence over implicit api_key.\n                console.debug(\"The project/location from the environment variables will take\" + \" precedence over the API key from the environment variables.\");\n                this.apiKey = undefined;\n            }\n        }\n        const baseUrl = getBaseUrl(options, getEnv(\"GOOGLE_VERTEX_BASE_URL\"), getEnv(\"GOOGLE_GEMINI_BASE_URL\"));\n        if (baseUrl) {\n            if (options.httpOptions) {\n                options.httpOptions.baseUrl = baseUrl;\n            } else {\n                options.httpOptions = {\n                    baseUrl: baseUrl\n                };\n            }\n        }\n        this.apiVersion = options.apiVersion;\n        const auth = new NodeAuth({\n            apiKey: this.apiKey,\n            googleAuthOptions: options.googleAuthOptions\n        });\n        this.apiClient = new ApiClient({\n            auth: auth,\n            project: this.project,\n            location: this.location,\n            apiVersion: this.apiVersion,\n            apiKey: this.apiKey,\n            vertexai: this.vertexai,\n            httpOptions: options.httpOptions,\n            userAgentExtra: LANGUAGE_LABEL_PREFIX + process.version,\n            uploader: new NodeUploader()\n        });\n        this.models = new Models(this.apiClient);\n        this.live = new Live(this.apiClient, auth, new NodeWebSocketFactory());\n        this.chats = new Chats(this.models, this.apiClient);\n        this.caches = new Caches(this.apiClient);\n        this.files = new Files(this.apiClient);\n        this.operations = new Operations(this.apiClient);\n    }\n}\nfunction getEnv(env) {\n    var _a, _b, _c;\n    return (_c = (_b = (_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a[env]) === null || _b === void 0 ? void 0 : _b.trim()) !== null && _c !== void 0 ? _c : undefined;\n}\nfunction getBooleanEnv(env) {\n    return stringToBoolean(getEnv(env));\n}\nfunction stringToBoolean(str) {\n    if (str === undefined) {\n        return false;\n    }\n    return str.toLowerCase() === \"true\";\n}\nexports.Caches = Caches;\nexports.Chat = Chat;\nexports.Chats = Chats;\nexports.ComputeTokensResponse = ComputeTokensResponse;\nexports.CountTokensResponse = CountTokensResponse;\nexports.CreateFileResponse = CreateFileResponse;\nexports.DeleteCachedContentResponse = DeleteCachedContentResponse;\nexports.DeleteFileResponse = DeleteFileResponse;\nexports.EmbedContentResponse = EmbedContentResponse;\nexports.Files = Files;\nexports.FunctionResponse = FunctionResponse;\nexports.GenerateContentResponse = GenerateContentResponse;\nexports.GenerateContentResponsePromptFeedback = GenerateContentResponsePromptFeedback;\nexports.GenerateContentResponseUsageMetadata = GenerateContentResponseUsageMetadata;\nexports.GenerateImagesResponse = GenerateImagesResponse;\nexports.GenerateVideosResponse = GenerateVideosResponse;\nexports.GoogleGenAI = GoogleGenAI;\nexports.HttpResponse = HttpResponse;\nexports.ListCachedContentsResponse = ListCachedContentsResponse;\nexports.ListFilesResponse = ListFilesResponse;\nexports.Live = Live;\nexports.LiveClientToolResponse = LiveClientToolResponse;\nexports.LiveSendToolResponseParameters = LiveSendToolResponseParameters;\nexports.Models = Models;\nexports.Operations = Operations;\nexports.Pager = Pager;\nexports.ReplayResponse = ReplayResponse;\nexports.Session = Session;\nexports.createModelContent = createModelContent;\nexports.createPartFromBase64 = createPartFromBase64;\nexports.createPartFromCodeExecutionResult = createPartFromCodeExecutionResult;\nexports.createPartFromExecutableCode = createPartFromExecutableCode;\nexports.createPartFromFunctionCall = createPartFromFunctionCall;\nexports.createPartFromFunctionResponse = createPartFromFunctionResponse;\nexports.createPartFromText = createPartFromText;\nexports.createPartFromUri = createPartFromUri;\nexports.createUserContent = createUserContent;\nexports.setDefaultBaseUrls = setDefaultBaseUrls; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9nZW5haS9kaXN0L25vZGUvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxvQkFBb0JDLG1CQUFPQSxDQUFDO0FBQ2hDLElBQUlDLFNBQVNELG1CQUFPQSxDQUFDO0FBQ3JCLElBQUlFLEtBQUtGLG1CQUFPQSxDQUFDO0FBRWpCLFNBQVNHLHlCQUF5QkMsQ0FBQztJQUNqQyxJQUFJQyxJQUFJQyxPQUFPQyxNQUFNLENBQUM7SUFDdEIsSUFBSUgsR0FBRztRQUNMRSxPQUFPRSxJQUFJLENBQUNKLEdBQUdLLE9BQU8sQ0FBQyxTQUFVQyxDQUFDO1lBQ2hDLElBQUlBLE1BQU0sV0FBVztnQkFDbkIsSUFBSUMsSUFBSUwsT0FBT00sd0JBQXdCLENBQUNSLEdBQUdNO2dCQUMzQ0osT0FBT08sY0FBYyxDQUFDUixHQUFHSyxHQUFHQyxFQUFFRyxHQUFHLEdBQUdILElBQUk7b0JBQ3RDSSxZQUFZO29CQUNaRCxLQUFLO3dCQUFjLE9BQU9WLENBQUMsQ0FBQ00sRUFBRTtvQkFBRTtnQkFDbEM7WUFDRjtRQUNGO0lBQ0Y7SUFDQUwsRUFBRVcsT0FBTyxHQUFHWjtJQUNaLE9BQU9FLE9BQU9XLE1BQU0sQ0FBQ1o7QUFDdkI7QUFFQSxJQUFJYSxvQkFBb0IsV0FBVyxHQUFFZix5QkFBeUJGO0FBQzlELElBQUlrQixnQkFBZ0IsV0FBVyxHQUFFaEIseUJBQXlCRDtBQUUxRDs7OztDQUlDLEdBQ0QsSUFBSWtCLHdCQUF3QkM7QUFDNUIsSUFBSUMsd0JBQXdCRDtBQUM1Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW1CQyxHQUNELFNBQVNFLG1CQUFtQkMsYUFBYTtJQUNyQ0osd0JBQXdCSSxjQUFjQyxTQUFTO0lBQy9DSCx3QkFBd0JFLGNBQWNFLFNBQVM7QUFDbkQ7QUFDQTs7Q0FFQyxHQUNELFNBQVNDO0lBQ0wsT0FBTztRQUNIRixXQUFXTDtRQUNYTSxXQUFXSjtJQUNmO0FBQ0o7QUFDQTs7Ozs7Q0FLQyxHQUNE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QUFHcUg7QUFDckNySCx5QkFBeUIsR0FBR3NIO0FBQzVCdEgsWUFBWSxHQUFHbWtCO0FBQ2Zua0IsOEJBQThCLEdBQUcrSDtBQUNqQy9ILHNDQUFzQyxHQUFHZ0k7QUFDekNoSSxjQUFjLEdBQUdrbkI7QUFDakJsbkIsa0JBQWtCLEdBQUdvcEI7QUFDckJwcEIsYUFBYSxHQUFHRTtBQUNoQkYsc0JBQXNCLEdBQUc4SDtBQUN6QjlILGVBQWUsR0FBR21tQjtBQUNsQm5tQiwwQkFBMEIsR0FBR3VGO0FBQzdCdkYsNEJBQTRCLEdBQUd1RTtBQUMvQnZFLHlDQUF5QyxHQUFHeUU7QUFDNUN6RSxvQ0FBb0MsR0FBRzZFO0FBQ3ZDN0Usa0NBQWtDLEdBQUdpRTtBQUNyQ2pFLHNDQUFzQyxHQUFHb0U7QUFDekNwRSwwQkFBMEIsR0FBR2dFO0FBQzdCaEUseUJBQXlCLEdBQUc0RDtBQUM1QjVELHlCQUF5QixHQUFHc0Y7QUFDNUJ0RiwwQkFBMEIsR0FBR3ZOLG9CQUM3QixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hbmltYS1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvZ2VuYWkvZGlzdC9ub2RlL2luZGV4LmpzPzNhZjMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ29vZ2xlQXV0aExpYnJhcnkgPSByZXF1aXJlKCdnb29nbGUtYXV0aC1saWJyYXJ5Jyk7XG52YXIgTm9kZVdzID0gcmVxdWlyZSgnd3MnKTtcbnZhciBmcyA9IHJlcXVpcmUoJ2ZzL3Byb21pc2VzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wTmFtZXNwYWNlRGVmYXVsdChlKSB7XG4gIHZhciBuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKGUpIHtcbiAgICBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICBpZiAoayAhPT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgIHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBrKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIGssIGQuZ2V0ID8gZCA6IHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZVtrXTsgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBuLmRlZmF1bHQgPSBlO1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShuKTtcbn1cblxudmFyIE5vZGVXc19fbmFtZXNwYWNlID0gLyojX19QVVJFX18qL19pbnRlcm9wTmFtZXNwYWNlRGVmYXVsdChOb2RlV3MpO1xudmFyIGZzX19uYW1lc3BhY2UgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BOYW1lc3BhY2VEZWZhdWx0KGZzKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xubGV0IF9kZWZhdWx0QmFzZUdlbWluaVVybCA9IHVuZGVmaW5lZDtcbmxldCBfZGVmYXVsdEJhc2VWZXJ0ZXhVcmwgPSB1bmRlZmluZWQ7XG4vKipcbiAqIE92ZXJyaWRlcyB0aGUgYmFzZSBVUkxzIGZvciB0aGUgR2VtaW5pIEFQSSBhbmQgVmVydGV4IEFJIEFQSS5cbiAqXG4gKiBAcmVtYXJrcyBUaGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBjYWxsZWQgYmVmb3JlIGluaXRpYWxpemluZyB0aGUgU0RLLiBJZiB0aGVcbiAqIGJhc2UgVVJMcyBhcmUgc2V0IGFmdGVyIGluaXRpYWxpemluZyB0aGUgU0RLLCB0aGUgYmFzZSBVUkxzIHdpbGwgbm90IGJlXG4gKiB1cGRhdGVkLiBCYXNlIFVSTHMgcHJvdmlkZWQgaW4gdGhlIEh0dHBPcHRpb25zIHdpbGwgYWxzbyB0YWtlIHByZWNlZGVuY2Ugb3ZlclxuICogVVJMcyBzZXQgaGVyZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7R29vZ2xlR2VuQUksIHNldERlZmF1bHRCYXNlVXJsc30gZnJvbSAnQGdvb2dsZS9nZW5haSc7XG4gKiAvLyBPdmVycmlkZSB0aGUgYmFzZSBVUkwgZm9yIHRoZSBHZW1pbmkgQVBJLlxuICogc2V0RGVmYXVsdEJhc2VVcmxzKHtnZW1pbmlVcmw6J2h0dHBzOi8vZ2VtaW5pLmdvb2dsZS5jb20nfSk7XG4gKlxuICogLy8gT3ZlcnJpZGUgdGhlIGJhc2UgVVJMIGZvciB0aGUgVmVydGV4IEFJIEFQSS5cbiAqIHNldERlZmF1bHRCYXNlVXJscyh7dmVydGV4VXJsOiAnaHR0cHM6Ly92ZXJ0ZXhhaS5nb29nbGVhcGlzLmNvbSd9KTtcbiAqXG4gKiBjb25zdCBhaSA9IG5ldyBHb29nbGVHZW5BSSh7YXBpS2V5OiAnR0VNSU5JX0FQSV9LRVknfSk7XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gc2V0RGVmYXVsdEJhc2VVcmxzKGJhc2VVcmxQYXJhbXMpIHtcbiAgICBfZGVmYXVsdEJhc2VHZW1pbmlVcmwgPSBiYXNlVXJsUGFyYW1zLmdlbWluaVVybDtcbiAgICBfZGVmYXVsdEJhc2VWZXJ0ZXhVcmwgPSBiYXNlVXJsUGFyYW1zLnZlcnRleFVybDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgZGVmYXVsdCBiYXNlIFVSTHMgZm9yIHRoZSBHZW1pbmkgQVBJIGFuZCBWZXJ0ZXggQUkgQVBJLlxuICovXG5mdW5jdGlvbiBnZXREZWZhdWx0QmFzZVVybHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2VtaW5pVXJsOiBfZGVmYXVsdEJhc2VHZW1pbmlVcmwsXG4gICAgICAgIHZlcnRleFVybDogX2RlZmF1bHRCYXNlVmVydGV4VXJsLFxuICAgIH07XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGRlZmF1bHQgYmFzZSBVUkwgYmFzZWQgb24gdGhlIGZvbGxvd2luZyBwcmlvcml0eTpcbiAqICAgMS4gQmFzZSBVUkxzIHNldCB2aWEgSHR0cE9wdGlvbnMuXG4gKiAgIDIuIEJhc2UgVVJMcyBzZXQgdmlhIHRoZSBsYXRlc3QgY2FsbCB0byBzZXREZWZhdWx0QmFzZVVybHMuXG4gKiAgIDMuIEJhc2UgVVJMcyBzZXQgdmlhIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0QmFzZVVybChvcHRpb25zLCB2ZXJ0ZXhCYXNlVXJsRnJvbUVudiwgZ2VtaW5pQmFzZVVybEZyb21FbnYpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBpZiAoISgoX2EgPSBvcHRpb25zLmh0dHBPcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYmFzZVVybCkpIHtcbiAgICAgICAgY29uc3QgZGVmYXVsdEJhc2VVcmxzID0gZ2V0RGVmYXVsdEJhc2VVcmxzKCk7XG4gICAgICAgIGlmIChvcHRpb25zLnZlcnRleGFpKSB7XG4gICAgICAgICAgICByZXR1cm4gKF9iID0gZGVmYXVsdEJhc2VVcmxzLnZlcnRleFVybCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdmVydGV4QmFzZVVybEZyb21FbnY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKF9jID0gZGVmYXVsdEJhc2VVcmxzLmdlbWluaVVybCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogZ2VtaW5pQmFzZVVybEZyb21FbnY7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnMuaHR0cE9wdGlvbnMuYmFzZVVybDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY2xhc3MgQmFzZU1vZHVsZSB7XG59XG5mdW5jdGlvbiBmb3JtYXRNYXAodGVtcGxhdGVTdHJpbmcsIHZhbHVlTWFwKSB7XG4gICAgLy8gVXNlIGEgcmVndWxhciBleHByZXNzaW9uIHRvIGZpbmQgYWxsIHBsYWNlaG9sZGVycyBpbiB0aGUgdGVtcGxhdGUgc3RyaW5nXG4gICAgY29uc3QgcmVnZXggPSAvXFx7KFtefV0rKVxcfS9nO1xuICAgIC8vIFJlcGxhY2UgZWFjaCBwbGFjZWhvbGRlciB3aXRoIGl0cyBjb3JyZXNwb25kaW5nIHZhbHVlIGZyb20gdGhlIHZhbHVlTWFwXG4gICAgcmV0dXJuIHRlbXBsYXRlU3RyaW5nLnJlcGxhY2UocmVnZXgsIChtYXRjaCwga2V5KSA9PiB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWVNYXAsIGtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVNYXBba2V5XTtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIHZhbHVlIHRvIGEgc3RyaW5nIGlmIGl0J3Mgbm90IGEgc3RyaW5nIGFscmVhZHlcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsID8gU3RyaW5nKHZhbHVlKSA6ICcnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSGFuZGxlIG1pc3Npbmcga2V5c1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXkgJyR7a2V5fScgbm90IGZvdW5kIGluIHZhbHVlTWFwLmApO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBzZXRWYWx1ZUJ5UGF0aChkYXRhLCBrZXlzLCB2YWx1ZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgaWYgKGtleS5lbmRzV2l0aCgnW10nKSkge1xuICAgICAgICAgICAgY29uc3Qga2V5TmFtZSA9IGtleS5zbGljZSgwLCAtMik7XG4gICAgICAgICAgICBpZiAoIShrZXlOYW1lIGluIGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFba2V5TmFtZV0gPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiB2YWx1ZS5sZW5ndGggfSwgKCkgPT4gKHt9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFZhbHVlIG11c3QgYmUgYSBsaXN0IGdpdmVuIGFuIGFycmF5IHBhdGggJHtrZXl9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YVtrZXlOYW1lXSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcnJheURhdGEgPSBkYXRhW2tleU5hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGFycmF5RGF0YS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZW50cnkgPSBhcnJheURhdGFbal07XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChlbnRyeSwga2V5cy5zbGljZShpICsgMSksIHZhbHVlW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBkIG9mIGFycmF5RGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgoZCwga2V5cy5zbGljZShpICsgMSksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkuZW5kc1dpdGgoJ1swXScpKSB7XG4gICAgICAgICAgICBjb25zdCBrZXlOYW1lID0ga2V5LnNsaWNlKDAsIC0zKTtcbiAgICAgICAgICAgIGlmICghKGtleU5hbWUgaW4gZGF0YSkpIHtcbiAgICAgICAgICAgICAgICBkYXRhW2tleU5hbWVdID0gW3t9XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFycmF5RGF0YSA9IGRhdGFba2V5TmFtZV07XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChhcnJheURhdGFbMF0sIGtleXMuc2xpY2UoaSArIDEpLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXRhW2tleV0gfHwgdHlwZW9mIGRhdGFba2V5XSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGRhdGFba2V5XSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGRhdGEgPSBkYXRhW2tleV07XG4gICAgfVxuICAgIGNvbnN0IGtleVRvU2V0ID0ga2V5c1trZXlzLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IGV4aXN0aW5nRGF0YSA9IGRhdGFba2V5VG9TZXRdO1xuICAgIGlmIChleGlzdGluZ0RhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIXZhbHVlIHx8XG4gICAgICAgICAgICAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID09PSAwKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gZXhpc3RpbmdEYXRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBleGlzdGluZ0RhdGEgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBleGlzdGluZ0RhdGEgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGV4aXN0aW5nRGF0YSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3Qgc2V0IHZhbHVlIGZvciBhbiBleGlzdGluZyBrZXkuIEtleTogJHtrZXlUb1NldH1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZGF0YVtrZXlUb1NldF0gPSB2YWx1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRWYWx1ZUJ5UGF0aChkYXRhLCBrZXlzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAxICYmIGtleXNbMF0gPT09ICdfc2VsZicpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhICE9PSAnb2JqZWN0JyB8fCBkYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBpZiAoa2V5LmVuZHNXaXRoKCdbXScpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5TmFtZSA9IGtleS5zbGljZSgwLCAtMik7XG4gICAgICAgICAgICAgICAgaWYgKGtleU5hbWUgaW4gZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcnJheURhdGEgPSBkYXRhW2tleU5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXlEYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXlEYXRhLm1hcCgoZCkgPT4gZ2V0VmFsdWVCeVBhdGgoZCwga2V5cy5zbGljZShpICsgMSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGRhdGFba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFR5cGVFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmZ1bmN0aW9uIHRNb2RlbChhcGlDbGllbnQsIG1vZGVsKSB7XG4gICAgaWYgKCFtb2RlbCB8fCB0eXBlb2YgbW9kZWwgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbW9kZWwgaXMgcmVxdWlyZWQgYW5kIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICB9XG4gICAgaWYgKGFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgaWYgKG1vZGVsLnN0YXJ0c1dpdGgoJ3B1Ymxpc2hlcnMvJykgfHxcbiAgICAgICAgICAgIG1vZGVsLnN0YXJ0c1dpdGgoJ3Byb2plY3RzLycpIHx8XG4gICAgICAgICAgICBtb2RlbC5zdGFydHNXaXRoKCdtb2RlbHMvJykpIHtcbiAgICAgICAgICAgIHJldHVybiBtb2RlbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtb2RlbC5pbmRleE9mKCcvJykgPj0gMCkge1xuICAgICAgICAgICAgY29uc3QgcGFydHMgPSBtb2RlbC5zcGxpdCgnLycsIDIpO1xuICAgICAgICAgICAgcmV0dXJuIGBwdWJsaXNoZXJzLyR7cGFydHNbMF19L21vZGVscy8ke3BhcnRzWzFdfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYHB1Ymxpc2hlcnMvZ29vZ2xlL21vZGVscy8ke21vZGVsfWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChtb2RlbC5zdGFydHNXaXRoKCdtb2RlbHMvJykgfHwgbW9kZWwuc3RhcnRzV2l0aCgndHVuZWRNb2RlbHMvJykpIHtcbiAgICAgICAgICAgIHJldHVybiBtb2RlbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBgbW9kZWxzLyR7bW9kZWx9YDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHRDYWNoZXNNb2RlbChhcGlDbGllbnQsIG1vZGVsKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtZWRNb2RlbCA9IHRNb2RlbChhcGlDbGllbnQsIG1vZGVsKTtcbiAgICBpZiAoIXRyYW5zZm9ybWVkTW9kZWwpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBpZiAodHJhbnNmb3JtZWRNb2RlbC5zdGFydHNXaXRoKCdwdWJsaXNoZXJzLycpICYmIGFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgLy8gdmVydGV4IGNhY2hlcyBvbmx5IHN1cHBvcnQgbW9kZWwgbmFtZSBzdGFydCB3aXRoIHByb2plY3RzLlxuICAgICAgICByZXR1cm4gYHByb2plY3RzLyR7YXBpQ2xpZW50LmdldFByb2plY3QoKX0vbG9jYXRpb25zLyR7YXBpQ2xpZW50LmdldExvY2F0aW9uKCl9LyR7dHJhbnNmb3JtZWRNb2RlbH1gO1xuICAgIH1cbiAgICBlbHNlIGlmICh0cmFuc2Zvcm1lZE1vZGVsLnN0YXJ0c1dpdGgoJ21vZGVscy8nKSAmJiBhcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgIHJldHVybiBgcHJvamVjdHMvJHthcGlDbGllbnQuZ2V0UHJvamVjdCgpfS9sb2NhdGlvbnMvJHthcGlDbGllbnQuZ2V0TG9jYXRpb24oKX0vcHVibGlzaGVycy9nb29nbGUvJHt0cmFuc2Zvcm1lZE1vZGVsfWA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWRNb2RlbDtcbiAgICB9XG59XG5mdW5jdGlvbiB0QmxvYnMoYXBpQ2xpZW50LCBibG9icykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGJsb2JzKSkge1xuICAgICAgICByZXR1cm4gYmxvYnMubWFwKChibG9iKSA9PiB0QmxvYihhcGlDbGllbnQsIGJsb2IpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBbdEJsb2IoYXBpQ2xpZW50LCBibG9icyldO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRCbG9iKGFwaUNsaWVudCwgYmxvYikge1xuICAgIGlmICh0eXBlb2YgYmxvYiA9PT0gJ29iamVjdCcgJiYgYmxvYiAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYmxvYjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgcGFyc2UgaW5wdXQgYXMgQmxvYi4gVW5zdXBwb3J0ZWQgYmxvYiB0eXBlOiAke3R5cGVvZiBibG9ifWApO1xufVxuZnVuY3Rpb24gdEltYWdlQmxvYihhcGlDbGllbnQsIGJsb2IpIHtcbiAgICBjb25zdCB0cmFuc2Zvcm1lZEJsb2IgPSB0QmxvYihhcGlDbGllbnQsIGJsb2IpO1xuICAgIGlmICh0cmFuc2Zvcm1lZEJsb2IubWltZVR5cGUgJiZcbiAgICAgICAgdHJhbnNmb3JtZWRCbG9iLm1pbWVUeXBlLnN0YXJ0c1dpdGgoJ2ltYWdlLycpKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZEJsb2I7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgbWltZSB0eXBlOiAke3RyYW5zZm9ybWVkQmxvYi5taW1lVHlwZX1gKTtcbn1cbmZ1bmN0aW9uIHRBdWRpb0Jsb2IoYXBpQ2xpZW50LCBibG9iKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtZWRCbG9iID0gdEJsb2IoYXBpQ2xpZW50LCBibG9iKTtcbiAgICBpZiAodHJhbnNmb3JtZWRCbG9iLm1pbWVUeXBlICYmXG4gICAgICAgIHRyYW5zZm9ybWVkQmxvYi5taW1lVHlwZS5zdGFydHNXaXRoKCdhdWRpby8nKSkge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWRCbG9iO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIG1pbWUgdHlwZTogJHt0cmFuc2Zvcm1lZEJsb2IubWltZVR5cGV9YCk7XG59XG5mdW5jdGlvbiB0UGFydChhcGlDbGllbnQsIG9yaWdpbikge1xuICAgIGlmIChvcmlnaW4gPT09IG51bGwgfHwgb3JpZ2luID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJ0VW5pb24gaXMgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcmlnaW4gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBvcmlnaW47XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3JpZ2luID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4geyB0ZXh0OiBvcmlnaW4gfTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBwYXJ0IHR5cGU6ICR7dHlwZW9mIG9yaWdpbn1gKTtcbn1cbmZ1bmN0aW9uIHRQYXJ0cyhhcGlDbGllbnQsIG9yaWdpbikge1xuICAgIGlmIChvcmlnaW4gPT09IG51bGwgfHxcbiAgICAgICAgb3JpZ2luID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgKEFycmF5LmlzQXJyYXkob3JpZ2luKSAmJiBvcmlnaW4ubGVuZ3RoID09PSAwKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcnRMaXN0VW5pb24gaXMgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3JpZ2luKSkge1xuICAgICAgICByZXR1cm4gb3JpZ2luLm1hcCgoaXRlbSkgPT4gdFBhcnQoYXBpQ2xpZW50LCBpdGVtKSk7XG4gICAgfVxuICAgIHJldHVybiBbdFBhcnQoYXBpQ2xpZW50LCBvcmlnaW4pXTtcbn1cbmZ1bmN0aW9uIF9pc0NvbnRlbnQob3JpZ2luKSB7XG4gICAgcmV0dXJuIChvcmlnaW4gIT09IG51bGwgJiZcbiAgICAgICAgb3JpZ2luICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgdHlwZW9mIG9yaWdpbiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ3BhcnRzJyBpbiBvcmlnaW4gJiZcbiAgICAgICAgQXJyYXkuaXNBcnJheShvcmlnaW4ucGFydHMpKTtcbn1cbmZ1bmN0aW9uIF9pc0Z1bmN0aW9uQ2FsbFBhcnQob3JpZ2luKSB7XG4gICAgcmV0dXJuIChvcmlnaW4gIT09IG51bGwgJiZcbiAgICAgICAgb3JpZ2luICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgdHlwZW9mIG9yaWdpbiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ2Z1bmN0aW9uQ2FsbCcgaW4gb3JpZ2luKTtcbn1cbmZ1bmN0aW9uIF9pc0Z1bmN0aW9uUmVzcG9uc2VQYXJ0KG9yaWdpbikge1xuICAgIHJldHVybiAob3JpZ2luICE9PSBudWxsICYmXG4gICAgICAgIG9yaWdpbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHR5cGVvZiBvcmlnaW4gPT09ICdvYmplY3QnICYmXG4gICAgICAgICdmdW5jdGlvblJlc3BvbnNlJyBpbiBvcmlnaW4pO1xufVxuZnVuY3Rpb24gdENvbnRlbnQoYXBpQ2xpZW50LCBvcmlnaW4pIHtcbiAgICBpZiAob3JpZ2luID09PSBudWxsIHx8IG9yaWdpbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ29udGVudFVuaW9uIGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGlmIChfaXNDb250ZW50KG9yaWdpbikpIHtcbiAgICAgICAgLy8gX2lzQ29udGVudCBpcyBhIHV0aWxpdHkgZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgdGhlXG4gICAgICAgIC8vIG9yaWdpbiBpcyBhIENvbnRlbnQuXG4gICAgICAgIHJldHVybiBvcmlnaW47XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHJvbGU6ICd1c2VyJyxcbiAgICAgICAgcGFydHM6IHRQYXJ0cyhhcGlDbGllbnQsIG9yaWdpbiksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRDb250ZW50c0ZvckVtYmVkKGFwaUNsaWVudCwgb3JpZ2luKSB7XG4gICAgaWYgKCFvcmlnaW4pIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZiAoYXBpQ2xpZW50LmlzVmVydGV4QUkoKSAmJiBBcnJheS5pc0FycmF5KG9yaWdpbikpIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbi5mbGF0TWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gdENvbnRlbnQoYXBpQ2xpZW50LCBpdGVtKTtcbiAgICAgICAgICAgIGlmIChjb250ZW50LnBhcnRzICYmXG4gICAgICAgICAgICAgICAgY29udGVudC5wYXJ0cy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgICAgY29udGVudC5wYXJ0c1swXS50ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2NvbnRlbnQucGFydHNbMF0udGV4dF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChhcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSB0Q29udGVudChhcGlDbGllbnQsIG9yaWdpbik7XG4gICAgICAgIGlmIChjb250ZW50LnBhcnRzICYmXG4gICAgICAgICAgICBjb250ZW50LnBhcnRzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgIGNvbnRlbnQucGFydHNbMF0udGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gW2NvbnRlbnQucGFydHNbMF0udGV4dF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcmlnaW4pKSB7XG4gICAgICAgIHJldHVybiBvcmlnaW4ubWFwKChpdGVtKSA9PiB0Q29udGVudChhcGlDbGllbnQsIGl0ZW0pKTtcbiAgICB9XG4gICAgcmV0dXJuIFt0Q29udGVudChhcGlDbGllbnQsIG9yaWdpbildO1xufVxuZnVuY3Rpb24gdENvbnRlbnRzKGFwaUNsaWVudCwgb3JpZ2luKSB7XG4gICAgaWYgKG9yaWdpbiA9PT0gbnVsbCB8fFxuICAgICAgICBvcmlnaW4gPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAoQXJyYXkuaXNBcnJheShvcmlnaW4pICYmIG9yaWdpbi5sZW5ndGggPT09IDApKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY29udGVudHMgYXJlIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheShvcmlnaW4pKSB7XG4gICAgICAgIC8vIElmIGl0J3Mgbm90IGFuIGFycmF5LCBpdCdzIGEgc2luZ2xlIGNvbnRlbnQgb3IgYSBzaW5nbGUgUGFydFVuaW9uLlxuICAgICAgICBpZiAoX2lzRnVuY3Rpb25DYWxsUGFydChvcmlnaW4pIHx8IF9pc0Z1bmN0aW9uUmVzcG9uc2VQYXJ0KG9yaWdpbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG8gc3BlY2lmeSBmdW5jdGlvbkNhbGwgb3IgZnVuY3Rpb25SZXNwb25zZSBwYXJ0cywgcGxlYXNlIHdyYXAgdGhlbSBpbiBhIENvbnRlbnQgb2JqZWN0LCBzcGVjaWZ5aW5nIHRoZSByb2xlIGZvciB0aGVtJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt0Q29udGVudChhcGlDbGllbnQsIG9yaWdpbildO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBjb25zdCBhY2N1bXVsYXRlZFBhcnRzID0gW107XG4gICAgY29uc3QgaXNDb250ZW50QXJyYXkgPSBfaXNDb250ZW50KG9yaWdpblswXSk7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIG9yaWdpbikge1xuICAgICAgICBjb25zdCBpc0NvbnRlbnQgPSBfaXNDb250ZW50KGl0ZW0pO1xuICAgICAgICBpZiAoaXNDb250ZW50ICE9IGlzQ29udGVudEFycmF5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01peGluZyBDb250ZW50IGFuZCBQYXJ0cyBpcyBub3Qgc3VwcG9ydGVkLCBwbGVhc2UgZ3JvdXAgdGhlIHBhcnRzIGludG8gYSB0aGUgYXBwcm9wcmlhdGUgQ29udGVudCBvYmplY3RzIGFuZCBzcGVjaWZ5IHRoZSByb2xlcyBmb3IgdGhlbScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0NvbnRlbnQpIHtcbiAgICAgICAgICAgIC8vIGBpc0NvbnRlbnRgIGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgX2lzQ29udGVudCwgd2hpY2ggaXMgYSB1dGlsaXR5XG4gICAgICAgICAgICAvLyBmdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiB0aGUgaXRlbSBpcyBhIENvbnRlbnQuXG4gICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChfaXNGdW5jdGlvbkNhbGxQYXJ0KGl0ZW0pIHx8IF9pc0Z1bmN0aW9uUmVzcG9uc2VQYXJ0KGl0ZW0pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvIHNwZWNpZnkgZnVuY3Rpb25DYWxsIG9yIGZ1bmN0aW9uUmVzcG9uc2UgcGFydHMsIHBsZWFzZSB3cmFwIHRoZW0sIGFuZCBhbnkgb3RoZXIgcGFydHMsIGluIENvbnRlbnQgb2JqZWN0cyBhcyBhcHByb3ByaWF0ZSwgc3BlY2lmeWluZyB0aGUgcm9sZSBmb3IgdGhlbScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWNjdW11bGF0ZWRQYXJ0cy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghaXNDb250ZW50QXJyYXkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goeyByb2xlOiAndXNlcicsIHBhcnRzOiB0UGFydHMoYXBpQ2xpZW50LCBhY2N1bXVsYXRlZFBhcnRzKSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHRTY2hlbWEoYXBpQ2xpZW50LCBzY2hlbWEpIHtcbiAgICByZXR1cm4gc2NoZW1hO1xufVxuZnVuY3Rpb24gdFNwZWVjaENvbmZpZyhhcGlDbGllbnQsIHNwZWVjaENvbmZpZykge1xuICAgIGlmICh0eXBlb2Ygc3BlZWNoQ29uZmlnID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gc3BlZWNoQ29uZmlnO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygc3BlZWNoQ29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdm9pY2VDb25maWc6IHtcbiAgICAgICAgICAgICAgICBwcmVidWlsdFZvaWNlQ29uZmlnOiB7XG4gICAgICAgICAgICAgICAgICAgIHZvaWNlTmFtZTogc3BlZWNoQ29uZmlnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBzcGVlY2hDb25maWcgdHlwZTogJHt0eXBlb2Ygc3BlZWNoQ29uZmlnfWApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRUb29sKGFwaUNsaWVudCwgdG9vbCkge1xuICAgIHJldHVybiB0b29sO1xufVxuZnVuY3Rpb24gdFRvb2xzKGFwaUNsaWVudCwgdG9vbCkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0b29sKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Rvb2wgaXMgcmVxdWlyZWQgYW5kIG11c3QgYmUgYW4gYXJyYXkgb2YgVG9vbHMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvb2w7XG59XG4vKipcbiAqIFByZXBlbmRzIHJlc291cmNlIG5hbWUgd2l0aCBwcm9qZWN0LCBsb2NhdGlvbiwgcmVzb3VyY2VfcHJlZml4IGlmIG5lZWRlZC5cbiAqXG4gKiBAcGFyYW0gY2xpZW50IFRoZSBBUEkgY2xpZW50LlxuICogQHBhcmFtIHJlc291cmNlTmFtZSBUaGUgcmVzb3VyY2UgbmFtZS5cbiAqIEBwYXJhbSByZXNvdXJjZVByZWZpeCBUaGUgcmVzb3VyY2UgcHJlZml4LlxuICogQHBhcmFtIHNwbGl0c0FmdGVyUHJlZml4IFRoZSBudW1iZXIgb2Ygc3BsaXRzIGFmdGVyIHRoZSBwcmVmaXguXG4gKiBAcmV0dXJucyBUaGUgY29tcGxldGVkIHJlc291cmNlIG5hbWUuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogYGBgXG4gKiByZXNvdXJjZV9uYW1lID0gJzEyMydcbiAqIHJlc291cmNlX3ByZWZpeCA9ICdjYWNoZWRDb250ZW50cydcbiAqIHNwbGl0c19hZnRlcl9wcmVmaXggPSAxXG4gKiBjbGllbnQudmVydGV4YWkgPSBUcnVlXG4gKiBjbGllbnQucHJvamVjdCA9ICdiYXInXG4gKiBjbGllbnQubG9jYXRpb24gPSAndXMtd2VzdDEnXG4gKiBfcmVzb3VyY2VfbmFtZShjbGllbnQsIHJlc291cmNlX25hbWUsIHJlc291cmNlX3ByZWZpeCwgc3BsaXRzX2FmdGVyX3ByZWZpeClcbiAqIHJldHVybnM6ICdwcm9qZWN0cy9iYXIvbG9jYXRpb25zL3VzLXdlc3QxL2NhY2hlZENvbnRlbnRzLzEyMydcbiAqIGBgYFxuICpcbiAqIGBgYFxuICogcmVzb3VyY2VfbmFtZSA9ICdwcm9qZWN0cy9mb28vbG9jYXRpb25zL3VzLWNlbnRyYWwxL2NhY2hlZENvbnRlbnRzLzEyMydcbiAqIHJlc291cmNlX3ByZWZpeCA9ICdjYWNoZWRDb250ZW50cydcbiAqIHNwbGl0c19hZnRlcl9wcmVmaXggPSAxXG4gKiBjbGllbnQudmVydGV4YWkgPSBUcnVlXG4gKiBjbGllbnQucHJvamVjdCA9ICdiYXInXG4gKiBjbGllbnQubG9jYXRpb24gPSAndXMtd2VzdDEnXG4gKiBfcmVzb3VyY2VfbmFtZShjbGllbnQsIHJlc291cmNlX25hbWUsIHJlc291cmNlX3ByZWZpeCwgc3BsaXRzX2FmdGVyX3ByZWZpeClcbiAqIHJldHVybnM6ICdwcm9qZWN0cy9mb28vbG9jYXRpb25zL3VzLWNlbnRyYWwxL2NhY2hlZENvbnRlbnRzLzEyMydcbiAqIGBgYFxuICpcbiAqIGBgYFxuICogcmVzb3VyY2VfbmFtZSA9ICcxMjMnXG4gKiByZXNvdXJjZV9wcmVmaXggPSAnY2FjaGVkQ29udGVudHMnXG4gKiBzcGxpdHNfYWZ0ZXJfcHJlZml4ID0gMVxuICogY2xpZW50LnZlcnRleGFpID0gRmFsc2VcbiAqIF9yZXNvdXJjZV9uYW1lKGNsaWVudCwgcmVzb3VyY2VfbmFtZSwgcmVzb3VyY2VfcHJlZml4LCBzcGxpdHNfYWZ0ZXJfcHJlZml4KVxuICogcmV0dXJucyAnY2FjaGVkQ29udGVudHMvMTIzJ1xuICogYGBgXG4gKlxuICogYGBgXG4gKiByZXNvdXJjZV9uYW1lID0gJ3NvbWUvd3JvbmcvY2FjaGVkQ29udGVudHMvcmVzb3VyY2UvbmFtZS8xMjMnXG4gKiByZXNvdXJjZV9wcmVmaXggPSAnY2FjaGVkQ29udGVudHMnXG4gKiBzcGxpdHNfYWZ0ZXJfcHJlZml4ID0gMVxuICogY2xpZW50LnZlcnRleGFpID0gRmFsc2VcbiAqICMgY2xpZW50LnZlcnRleGFpID0gVHJ1ZVxuICogX3Jlc291cmNlX25hbWUoY2xpZW50LCByZXNvdXJjZV9uYW1lLCByZXNvdXJjZV9wcmVmaXgsIHNwbGl0c19hZnRlcl9wcmVmaXgpXG4gKiAtPiAnc29tZS93cm9uZy9yZXNvdXJjZS9uYW1lLzEyMydcbiAqIGBgYFxuICovXG5mdW5jdGlvbiByZXNvdXJjZU5hbWUoY2xpZW50LCByZXNvdXJjZU5hbWUsIHJlc291cmNlUHJlZml4LCBzcGxpdHNBZnRlclByZWZpeCA9IDEpIHtcbiAgICBjb25zdCBzaG91bGRBcHBlbmRQcmVmaXggPSAhcmVzb3VyY2VOYW1lLnN0YXJ0c1dpdGgoYCR7cmVzb3VyY2VQcmVmaXh9L2ApICYmXG4gICAgICAgIHJlc291cmNlTmFtZS5zcGxpdCgnLycpLmxlbmd0aCA9PT0gc3BsaXRzQWZ0ZXJQcmVmaXg7XG4gICAgaWYgKGNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgaWYgKHJlc291cmNlTmFtZS5zdGFydHNXaXRoKCdwcm9qZWN0cy8nKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc291cmNlTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXNvdXJjZU5hbWUuc3RhcnRzV2l0aCgnbG9jYXRpb25zLycpKSB7XG4gICAgICAgICAgICByZXR1cm4gYHByb2plY3RzLyR7Y2xpZW50LmdldFByb2plY3QoKX0vJHtyZXNvdXJjZU5hbWV9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXNvdXJjZU5hbWUuc3RhcnRzV2l0aChgJHtyZXNvdXJjZVByZWZpeH0vYCkpIHtcbiAgICAgICAgICAgIHJldHVybiBgcHJvamVjdHMvJHtjbGllbnQuZ2V0UHJvamVjdCgpfS9sb2NhdGlvbnMvJHtjbGllbnQuZ2V0TG9jYXRpb24oKX0vJHtyZXNvdXJjZU5hbWV9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzaG91bGRBcHBlbmRQcmVmaXgpIHtcbiAgICAgICAgICAgIHJldHVybiBgcHJvamVjdHMvJHtjbGllbnQuZ2V0UHJvamVjdCgpfS9sb2NhdGlvbnMvJHtjbGllbnQuZ2V0TG9jYXRpb24oKX0vJHtyZXNvdXJjZVByZWZpeH0vJHtyZXNvdXJjZU5hbWV9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvdXJjZU5hbWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNob3VsZEFwcGVuZFByZWZpeCkge1xuICAgICAgICByZXR1cm4gYCR7cmVzb3VyY2VQcmVmaXh9LyR7cmVzb3VyY2VOYW1lfWA7XG4gICAgfVxuICAgIHJldHVybiByZXNvdXJjZU5hbWU7XG59XG5mdW5jdGlvbiB0Q2FjaGVkQ29udGVudE5hbWUoYXBpQ2xpZW50LCBuYW1lKSB7XG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25hbWUgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzb3VyY2VOYW1lKGFwaUNsaWVudCwgbmFtZSwgJ2NhY2hlZENvbnRlbnRzJyk7XG59XG5mdW5jdGlvbiB0Qnl0ZXMoYXBpQ2xpZW50LCBmcm9tSW1hZ2VCeXRlcykge1xuICAgIGlmICh0eXBlb2YgZnJvbUltYWdlQnl0ZXMgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZnJvbUltYWdlQnl0ZXMgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH1cbiAgICAvLyBUT0RPKGIvMzg5MTMzOTE0KTogUmVtb3ZlIGR1bW15IGJ5dGVzIGNvbnZlcnRlci5cbiAgICByZXR1cm4gZnJvbUltYWdlQnl0ZXM7XG59XG5mdW5jdGlvbiB0RmlsZU5hbWUoYXBpQ2xpZW50LCBmcm9tTmFtZSkge1xuICAgIGlmICh0eXBlb2YgZnJvbU5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZnJvbU5hbWUgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH1cbiAgICAvLyBSZW1vdmUgdGhlIGZpbGVzLyBwcmVmeCBmb3IgTUxkZXYgdXJscyB0byBnZXQgdGhlIGFjdHVhbCBuYW1lIG9mIHRoZSBmaWxlLlxuICAgIGlmIChmcm9tTmFtZS5zdGFydHNXaXRoKCdmaWxlcy8nKSkge1xuICAgICAgICByZXR1cm4gZnJvbU5hbWUuc3BsaXQoJ2ZpbGVzLycpWzFdO1xuICAgIH1cbiAgICByZXR1cm4gZnJvbU5hbWU7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmZ1bmN0aW9uIHBhcnRUb01sZGV2JDIoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2aWRlb01ldGFkYXRhJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd2aWRlb01ldGFkYXRhIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aG91Z2h0J10pO1xuICAgIGlmIChmcm9tVGhvdWdodCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHQnXSwgZnJvbVRob3VnaHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb25SZXN1bHQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb25SZXN1bHQnXSwgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhlY3V0YWJsZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdleGVjdXRhYmxlQ29kZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FeGVjdXRhYmxlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4ZWN1dGFibGVDb2RlJ10sIGZyb21FeGVjdXRhYmxlQ29kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZURhdGEnXSk7XG4gICAgaWYgKGZyb21GaWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVEYXRhJ10sIGZyb21GaWxlRGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvbkNhbGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uQ2FsbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddLCBmcm9tRnVuY3Rpb25DYWxsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvblJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvblJlc3BvbnNlJ10sIGZyb21GdW5jdGlvblJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlubGluZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lubGluZURhdGEnXSk7XG4gICAgaWYgKGZyb21JbmxpbmVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5saW5lRGF0YSddLCBmcm9tSW5saW5lRGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZXh0J10pO1xuICAgIGlmIChmcm9tVGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RleHQnXSwgZnJvbVRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb250ZW50VG9NbGRldiQyKGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhcnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJ0cyddKTtcbiAgICBpZiAoZnJvbVBhcnRzICE9IG51bGwpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZnJvbVBhcnRzKSkge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFydHMnXSwgZnJvbVBhcnRzLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0VG9NbGRldiQyKGFwaUNsaWVudCwgaXRlbSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJ0cyddLCBmcm9tUGFydHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGZyb21Sb2xlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyb2xlJ10pO1xuICAgIGlmIChmcm9tUm9sZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JvbGUnXSwgZnJvbVJvbGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkRlY2xhcmF0aW9uVG9NbGRldiQyKGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzcG9uc2UnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Jlc3BvbnNlIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSk7XG4gICAgaWYgKGZyb21EZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10sIGZyb21EZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFyYW1ldGVycyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFyYW1ldGVycyddKTtcbiAgICBpZiAoZnJvbVBhcmFtZXRlcnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJhbWV0ZXJzJ10sIGZyb21QYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ29vZ2xlU2VhcmNoVG9NbGRldiQyKCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZHluYW1pY1JldHJpZXZhbENvbmZpZ1RvTWxkZXYkMihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlJ10pO1xuICAgIGlmIChmcm9tTW9kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGUnXSwgZnJvbU1vZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRHluYW1pY1RocmVzaG9sZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2R5bmFtaWNUaHJlc2hvbGQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRHluYW1pY1RocmVzaG9sZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2R5bmFtaWNUaHJlc2hvbGQnXSwgZnJvbUR5bmFtaWNUaHJlc2hvbGQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnb29nbGVTZWFyY2hSZXRyaWV2YWxUb01sZGV2JDIoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRHluYW1pY1JldHJpZXZhbENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2R5bmFtaWNSZXRyaWV2YWxDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRHluYW1pY1JldHJpZXZhbENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2R5bmFtaWNSZXRyaWV2YWxDb25maWcnXSwgZHluYW1pY1JldHJpZXZhbENvbmZpZ1RvTWxkZXYkMihhcGlDbGllbnQsIGZyb21EeW5hbWljUmV0cmlldmFsQ29uZmlnKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRvb2xUb01sZGV2JDIoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvbkRlY2xhcmF0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucykpIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJ10sIGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucy5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb25EZWNsYXJhdGlvblRvTWxkZXYkMihhcGlDbGllbnQsIGl0ZW0pO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25EZWNsYXJhdGlvbnMnXSwgZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXRyaWV2YWwnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JldHJpZXZhbCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVTZWFyY2gnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2gnXSwgZ29vZ2xlU2VhcmNoVG9NbGRldiQyKCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ29vZ2xlU2VhcmNoUmV0cmlldmFsJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCddLCBnb29nbGVTZWFyY2hSZXRyaWV2YWxUb01sZGV2JDIoYXBpQ2xpZW50LCBmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvbiddLCBmcm9tQ29kZUV4ZWN1dGlvbik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ1RvTWxkZXYkMShhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlJ10pO1xuICAgIGlmIChmcm9tTW9kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGUnXSwgZnJvbU1vZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQWxsb3dlZEZ1bmN0aW9uTmFtZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdhbGxvd2VkRnVuY3Rpb25OYW1lcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21BbGxvd2VkRnVuY3Rpb25OYW1lcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FsbG93ZWRGdW5jdGlvbk5hbWVzJ10sIGZyb21BbGxvd2VkRnVuY3Rpb25OYW1lcyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRvb2xDb25maWdUb01sZGV2JDEoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnVuY3Rpb25DYWxsaW5nQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25DYWxsaW5nQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uQ2FsbGluZ0NvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbGluZ0NvbmZpZyddLCBmdW5jdGlvbkNhbGxpbmdDb25maWdUb01sZGV2JDEoYXBpQ2xpZW50LCBmcm9tRnVuY3Rpb25DYWxsaW5nQ29uZmlnKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlZENvbnRlbnRDb25maWdUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVHRsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0dGwnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UdGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndHRsJ10sIGZyb21UdGwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhwaXJlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhwaXJlVGltZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUV4cGlyZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZXhwaXJlVGltZSddLCBmcm9tRXhwaXJlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnRzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQ29udGVudHMgIT0gbnVsbCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmcm9tQ29udGVudHMpKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnY29udGVudHMnXSwgdENvbnRlbnRzKGFwaUNsaWVudCwgdENvbnRlbnRzKGFwaUNsaWVudCwgZnJvbUNvbnRlbnRzKS5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudFRvTWxkZXYkMihhcGlDbGllbnQsIGl0ZW0pO1xuICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydjb250ZW50cyddLCB0Q29udGVudHMoYXBpQ2xpZW50LCBmcm9tQ29udGVudHMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzeXN0ZW1JbnN0cnVjdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TeXN0ZW1JbnN0cnVjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzeXN0ZW1JbnN0cnVjdGlvbiddLCBjb250ZW50VG9NbGRldiQyKGFwaUNsaWVudCwgdENvbnRlbnQoYXBpQ2xpZW50LCBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24pKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29scyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub29scyAhPSBudWxsKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZyb21Ub29scykpIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0b29scyddLCBmcm9tVG9vbHMubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvb2xUb01sZGV2JDIoYXBpQ2xpZW50LCBpdGVtKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0b29scyddLCBmcm9tVG9vbHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29sQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29sQ29uZmlnJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9vbENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0b29sQ29uZmlnJ10sIHRvb2xDb25maWdUb01sZGV2JDEoYXBpQ2xpZW50LCBmcm9tVG9vbENvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbCddLCB0Q2FjaGVzTW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGNyZWF0ZUNhY2hlZENvbnRlbnRDb25maWdUb01sZGV2KGFwaUNsaWVudCwgZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2V0Q2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIHRDYWNoZWRDb250ZW50TmFtZShhcGlDbGllbnQsIGZyb21OYW1lKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCBmcm9tQ29uZmlnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIHRDYWNoZWRDb250ZW50TmFtZShhcGlDbGllbnQsIGZyb21OYW1lKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCBmcm9tQ29uZmlnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXBkYXRlQ2FjaGVkQ29udGVudENvbmZpZ1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UdGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3R0bCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVR0bCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0dGwnXSwgZnJvbVR0bCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeHBpcmVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleHBpcmVUaW1lJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRXhwaXJlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydleHBpcmVUaW1lJ10sIGZyb21FeHBpcmVUaW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXBkYXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIHRDYWNoZWRDb250ZW50TmFtZShhcGlDbGllbnQsIGZyb21OYW1lKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCB1cGRhdGVDYWNoZWRDb250ZW50Q29uZmlnVG9NbGRldihhcGlDbGllbnQsIGZyb21Db25maWcsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RDYWNoZWRDb250ZW50c0NvbmZpZ1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYWdlU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVNpemUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVNpemUnXSwgZnJvbVBhZ2VTaXplKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVRva2VuJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlVG9rZW4nXSwgZnJvbVBhZ2VUb2tlbik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RDYWNoZWRDb250ZW50c1BhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGxpc3RDYWNoZWRDb250ZW50c0NvbmZpZ1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tQ29uZmlnLCB0b09iamVjdCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBwYXJ0VG9WZXJ0ZXgkMihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21WaWRlb01ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndmlkZW9NZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21WaWRlb01ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW9NZXRhZGF0YSddLCBmcm9tVmlkZW9NZXRhZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aG91Z2h0J10pO1xuICAgIGlmIChmcm9tVGhvdWdodCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHQnXSwgZnJvbVRob3VnaHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb25SZXN1bHQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb25SZXN1bHQnXSwgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhlY3V0YWJsZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdleGVjdXRhYmxlQ29kZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FeGVjdXRhYmxlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4ZWN1dGFibGVDb2RlJ10sIGZyb21FeGVjdXRhYmxlQ29kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZURhdGEnXSk7XG4gICAgaWYgKGZyb21GaWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVEYXRhJ10sIGZyb21GaWxlRGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvbkNhbGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uQ2FsbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddLCBmcm9tRnVuY3Rpb25DYWxsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvblJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvblJlc3BvbnNlJ10sIGZyb21GdW5jdGlvblJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlubGluZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lubGluZURhdGEnXSk7XG4gICAgaWYgKGZyb21JbmxpbmVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5saW5lRGF0YSddLCBmcm9tSW5saW5lRGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZXh0J10pO1xuICAgIGlmIChmcm9tVGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RleHQnXSwgZnJvbVRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb250ZW50VG9WZXJ0ZXgkMihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYXJ0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFydHMnXSk7XG4gICAgaWYgKGZyb21QYXJ0cyAhPSBudWxsKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZyb21QYXJ0cykpIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcnRzJ10sIGZyb21QYXJ0cy5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydFRvVmVydGV4JDIoYXBpQ2xpZW50LCBpdGVtKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcnRzJ10sIGZyb21QYXJ0cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZnJvbVJvbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JvbGUnXSk7XG4gICAgaWYgKGZyb21Sb2xlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncm9sZSddLCBmcm9tUm9sZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNjaGVtYVRvVmVydGV4JDIoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRXhhbXBsZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhhbXBsZSddKTtcbiAgICBpZiAoZnJvbUV4YW1wbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleGFtcGxlJ10sIGZyb21FeGFtcGxlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhdHRlcm4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhdHRlcm4nXSk7XG4gICAgaWYgKGZyb21QYXR0ZXJuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGF0dGVybiddLCBmcm9tUGF0dGVybik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZWZhdWx0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZWZhdWx0J10pO1xuICAgIGlmIChmcm9tRGVmYXVsdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RlZmF1bHQnXSwgZnJvbURlZmF1bHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWF4TGVuZ3RoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtYXhMZW5ndGgnXSk7XG4gICAgaWYgKGZyb21NYXhMZW5ndGggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtYXhMZW5ndGgnXSwgZnJvbU1heExlbmd0aCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW5MZW5ndGggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbkxlbmd0aCddKTtcbiAgICBpZiAoZnJvbU1pbkxlbmd0aCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbkxlbmd0aCddLCBmcm9tTWluTGVuZ3RoKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pblByb3BlcnRpZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtaW5Qcm9wZXJ0aWVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1pblByb3BlcnRpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW5Qcm9wZXJ0aWVzJ10sIGZyb21NaW5Qcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heFByb3BlcnRpZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtYXhQcm9wZXJ0aWVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1heFByb3BlcnRpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtYXhQcm9wZXJ0aWVzJ10sIGZyb21NYXhQcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFueU9mID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhbnlPZiddKTtcbiAgICBpZiAoZnJvbUFueU9mICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYW55T2YnXSwgZnJvbUFueU9mKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXNjcmlwdGlvbiddKTtcbiAgICBpZiAoZnJvbURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVzY3JpcHRpb24nXSwgZnJvbURlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVudW0gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VudW0nXSk7XG4gICAgaWYgKGZyb21FbnVtICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW51bSddLCBmcm9tRW51bSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Gb3JtYXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Zvcm1hdCddKTtcbiAgICBpZiAoZnJvbUZvcm1hdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Zvcm1hdCddLCBmcm9tRm9ybWF0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUl0ZW1zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpdGVtcyddKTtcbiAgICBpZiAoZnJvbUl0ZW1zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaXRlbXMnXSwgZnJvbUl0ZW1zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heEl0ZW1zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtYXhJdGVtcyddKTtcbiAgICBpZiAoZnJvbU1heEl0ZW1zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWF4SXRlbXMnXSwgZnJvbU1heEl0ZW1zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heGltdW0gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21heGltdW0nXSk7XG4gICAgaWYgKGZyb21NYXhpbXVtICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWF4aW11bSddLCBmcm9tTWF4aW11bSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW5JdGVtcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWluSXRlbXMnXSk7XG4gICAgaWYgKGZyb21NaW5JdGVtcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbkl0ZW1zJ10sIGZyb21NaW5JdGVtcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW5pbXVtID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW5pbXVtJ10pO1xuICAgIGlmIChmcm9tTWluaW11bSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbmltdW0nXSwgZnJvbU1pbmltdW0pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTnVsbGFibGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ251bGxhYmxlJ10pO1xuICAgIGlmIChmcm9tTnVsbGFibGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydudWxsYWJsZSddLCBmcm9tTnVsbGFibGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvcGVydGllcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJvcGVydGllcyddKTtcbiAgICBpZiAoZnJvbVByb3BlcnRpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcm9wZXJ0aWVzJ10sIGZyb21Qcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb3BlcnR5T3JkZXJpbmcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcm9wZXJ0eU9yZGVyaW5nJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByb3BlcnR5T3JkZXJpbmcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcm9wZXJ0eU9yZGVyaW5nJ10sIGZyb21Qcm9wZXJ0eU9yZGVyaW5nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlcXVpcmVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXF1aXJlZCddKTtcbiAgICBpZiAoZnJvbVJlcXVpcmVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVxdWlyZWQnXSwgZnJvbVJlcXVpcmVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRpdGxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aXRsZSddKTtcbiAgICBpZiAoZnJvbVRpdGxlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGl0bGUnXSwgZnJvbVRpdGxlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3R5cGUnXSk7XG4gICAgaWYgKGZyb21UeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHlwZSddLCBmcm9tVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uRGVjbGFyYXRpb25Ub1ZlcnRleCQyKGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNwb25zZSddKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2UnXSwgc2NoZW1hVG9WZXJ0ZXgkMihhcGlDbGllbnQsIGZyb21SZXNwb25zZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10pO1xuICAgIGlmIChmcm9tRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXNjcmlwdGlvbiddLCBmcm9tRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhcmFtZXRlcnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcmFtZXRlcnMnXSk7XG4gICAgaWYgKGZyb21QYXJhbWV0ZXJzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFyYW1ldGVycyddLCBmcm9tUGFyYW1ldGVycyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZVNlYXJjaFRvVmVydGV4JDIoKSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkeW5hbWljUmV0cmlldmFsQ29uZmlnVG9WZXJ0ZXgkMihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlJ10pO1xuICAgIGlmIChmcm9tTW9kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGUnXSwgZnJvbU1vZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRHluYW1pY1RocmVzaG9sZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2R5bmFtaWNUaHJlc2hvbGQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRHluYW1pY1RocmVzaG9sZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2R5bmFtaWNUaHJlc2hvbGQnXSwgZnJvbUR5bmFtaWNUaHJlc2hvbGQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnb29nbGVTZWFyY2hSZXRyaWV2YWxUb1ZlcnRleCQyKGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUR5bmFtaWNSZXRyaWV2YWxDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdkeW5hbWljUmV0cmlldmFsQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUR5bmFtaWNSZXRyaWV2YWxDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkeW5hbWljUmV0cmlldmFsQ29uZmlnJ10sIGR5bmFtaWNSZXRyaWV2YWxDb25maWdUb1ZlcnRleCQyKGFwaUNsaWVudCwgZnJvbUR5bmFtaWNSZXRyaWV2YWxDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdG9vbFRvVmVydGV4JDIoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvbkRlY2xhcmF0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucykpIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJ10sIGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucy5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb25EZWNsYXJhdGlvblRvVmVydGV4JDIoYXBpQ2xpZW50LCBpdGVtKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJ10sIGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZnJvbVJldHJpZXZhbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmV0cmlldmFsJ10pO1xuICAgIGlmIChmcm9tUmV0cmlldmFsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmV0cmlldmFsJ10sIGZyb21SZXRyaWV2YWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVTZWFyY2gnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2gnXSwgZ29vZ2xlU2VhcmNoVG9WZXJ0ZXgkMigpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2hSZXRyaWV2YWwnXSwgZ29vZ2xlU2VhcmNoUmV0cmlldmFsVG9WZXJ0ZXgkMihhcGlDbGllbnQsIGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uJ10sIGZyb21Db2RlRXhlY3V0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25DYWxsaW5nQ29uZmlnVG9WZXJ0ZXgkMShhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlJ10pO1xuICAgIGlmIChmcm9tTW9kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGUnXSwgZnJvbU1vZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQWxsb3dlZEZ1bmN0aW9uTmFtZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdhbGxvd2VkRnVuY3Rpb25OYW1lcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21BbGxvd2VkRnVuY3Rpb25OYW1lcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FsbG93ZWRGdW5jdGlvbk5hbWVzJ10sIGZyb21BbGxvd2VkRnVuY3Rpb25OYW1lcyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRvb2xDb25maWdUb1ZlcnRleCQxKGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uQ2FsbGluZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uQ2FsbGluZ0NvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkNhbGxpbmdDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkNhbGxpbmdDb25maWcnXSwgZnVuY3Rpb25DYWxsaW5nQ29uZmlnVG9WZXJ0ZXgkMShhcGlDbGllbnQsIGZyb21GdW5jdGlvbkNhbGxpbmdDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlQ2FjaGVkQ29udGVudENvbmZpZ1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVHRsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0dGwnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UdGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndHRsJ10sIGZyb21UdGwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhwaXJlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhwaXJlVGltZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUV4cGlyZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZXhwaXJlVGltZSddLCBmcm9tRXhwaXJlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnRzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQ29udGVudHMgIT0gbnVsbCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmcm9tQ29udGVudHMpKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnY29udGVudHMnXSwgdENvbnRlbnRzKGFwaUNsaWVudCwgdENvbnRlbnRzKGFwaUNsaWVudCwgZnJvbUNvbnRlbnRzKS5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudFRvVmVydGV4JDIoYXBpQ2xpZW50LCBpdGVtKTtcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnY29udGVudHMnXSwgdENvbnRlbnRzKGFwaUNsaWVudCwgZnJvbUNvbnRlbnRzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZnJvbVN5c3RlbUluc3RydWN0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3lzdGVtSW5zdHJ1Y3Rpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc3lzdGVtSW5zdHJ1Y3Rpb24nXSwgY29udGVudFRvVmVydGV4JDIoYXBpQ2xpZW50LCB0Q29udGVudChhcGlDbGllbnQsIGZyb21TeXN0ZW1JbnN0cnVjdGlvbikpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29scyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xzICE9IG51bGwpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZnJvbVRvb2xzKSkge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3Rvb2xzJ10sIGZyb21Ub29scy5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9vbFRvVmVydGV4JDIoYXBpQ2xpZW50LCBpdGVtKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0b29scyddLCBmcm9tVG9vbHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29sQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29sQ29uZmlnJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9vbENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0b29sQ29uZmlnJ10sIHRvb2xDb25maWdUb1ZlcnRleCQxKGFwaUNsaWVudCwgZnJvbVRvb2xDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGVsJ10sIHRDYWNoZXNNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgY3JlYXRlQ2FjaGVkQ29udGVudENvbmZpZ1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2V0Q2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0Q2FjaGVkQ29udGVudE5hbWUoYXBpQ2xpZW50LCBmcm9tTmFtZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgZnJvbUNvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdENhY2hlZENvbnRlbnROYW1lKGFwaUNsaWVudCwgZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGZyb21Db25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cGRhdGVDYWNoZWRDb250ZW50Q29uZmlnVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UdGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3R0bCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVR0bCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0dGwnXSwgZnJvbVR0bCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeHBpcmVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleHBpcmVUaW1lJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRXhwaXJlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydleHBpcmVUaW1lJ10sIGZyb21FeHBpcmVUaW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXBkYXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0Q2FjaGVkQ29udGVudE5hbWUoYXBpQ2xpZW50LCBmcm9tTmFtZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgdXBkYXRlQ2FjaGVkQ29udGVudENvbmZpZ1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdENhY2hlZENvbnRlbnRzQ29uZmlnVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYWdlU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVNpemUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVNpemUnXSwgZnJvbVBhZ2VTaXplKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVRva2VuJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlVG9rZW4nXSwgZnJvbVBhZ2VUb2tlbik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RDYWNoZWRDb250ZW50c1BhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCBsaXN0Q2FjaGVkQ29udGVudHNDb25maWdUb1ZlcnRleChhcGlDbGllbnQsIGZyb21Db25maWcsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNhY2hlZENvbnRlbnRGcm9tTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAoZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWwnXSwgZnJvbU1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNyZWF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21DcmVhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY3JlYXRlVGltZSddLCBmcm9tQ3JlYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcGRhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cGRhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tVXBkYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSwgZnJvbVVwZGF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhwaXJlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhwaXJlVGltZSddKTtcbiAgICBpZiAoZnJvbUV4cGlyZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleHBpcmVUaW1lJ10sIGZyb21FeHBpcmVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVzYWdlTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd1c2FnZU1ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVVzYWdlTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1c2FnZU1ldGFkYXRhJ10sIGZyb21Vc2FnZU1ldGFkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlQ2FjaGVkQ29udGVudFJlc3BvbnNlRnJvbU1sZGV2KCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdENhY2hlZENvbnRlbnRzUmVzcG9uc2VGcm9tTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmV4dFBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ25leHRQYWdlVG9rZW4nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTmV4dFBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25leHRQYWdlVG9rZW4nXSwgZnJvbU5leHRQYWdlVG9rZW4pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FjaGVkQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYWNoZWRDb250ZW50cycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DYWNoZWRDb250ZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZyb21DYWNoZWRDb250ZW50cykpIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhY2hlZENvbnRlbnRzJ10sIGZyb21DYWNoZWRDb250ZW50cy5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkQ29udGVudEZyb21NbGRldihhcGlDbGllbnQsIGl0ZW0pO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2FjaGVkQ29udGVudHMnXSwgZnJvbUNhY2hlZENvbnRlbnRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjYWNoZWRDb250ZW50RnJvbVZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbCddLCBmcm9tTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ3JlYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY3JlYXRlVGltZSddKTtcbiAgICBpZiAoZnJvbUNyZWF0ZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjcmVhdGVUaW1lJ10sIGZyb21DcmVhdGVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVwZGF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21VcGRhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXBkYXRlVGltZSddLCBmcm9tVXBkYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeHBpcmVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleHBpcmVUaW1lJ10pO1xuICAgIGlmIChmcm9tRXhwaXJlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4cGlyZVRpbWUnXSwgZnJvbUV4cGlyZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXNhZ2VNZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3VzYWdlTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVXNhZ2VNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VzYWdlTWV0YWRhdGEnXSwgZnJvbVVzYWdlTWV0YWRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkZWxldGVDYWNoZWRDb250ZW50UmVzcG9uc2VGcm9tVmVydGV4KCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdENhY2hlZENvbnRlbnRzUmVzcG9uc2VGcm9tVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5leHRQYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZXh0UGFnZVRva2VuJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU5leHRQYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduZXh0UGFnZVRva2VuJ10sIGZyb21OZXh0UGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhY2hlZENvbnRlbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2FjaGVkQ29udGVudHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2FjaGVkQ29udGVudHMgIT0gbnVsbCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmcm9tQ2FjaGVkQ29udGVudHMpKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYWNoZWRDb250ZW50cyddLCBmcm9tQ2FjaGVkQ29udGVudHMubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENvbnRlbnRGcm9tVmVydGV4KGFwaUNsaWVudCwgaXRlbSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYWNoZWRDb250ZW50cyddLCBmcm9tQ2FjaGVkQ29udGVudHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuLyoqXG4gKiBQYWdlcnMgZm9yIHRoZSBHZW5BSSBMaXN0IEFQSXMuXG4gKi9cbmV4cG9ydHMuUGFnZWRJdGVtID0gdm9pZCAwO1xuKGZ1bmN0aW9uIChQYWdlZEl0ZW0pIHtcbiAgICBQYWdlZEl0ZW1bXCJQQUdFRF9JVEVNX0JBVENIX0pPQlNcIl0gPSBcImJhdGNoSm9ic1wiO1xuICAgIFBhZ2VkSXRlbVtcIlBBR0VEX0lURU1fTU9ERUxTXCJdID0gXCJtb2RlbHNcIjtcbiAgICBQYWdlZEl0ZW1bXCJQQUdFRF9JVEVNX1RVTklOR19KT0JTXCJdID0gXCJ0dW5pbmdKb2JzXCI7XG4gICAgUGFnZWRJdGVtW1wiUEFHRURfSVRFTV9GSUxFU1wiXSA9IFwiZmlsZXNcIjtcbiAgICBQYWdlZEl0ZW1bXCJQQUdFRF9JVEVNX0NBQ0hFRF9DT05URU5UU1wiXSA9IFwiY2FjaGVkQ29udGVudHNcIjtcbn0pKGV4cG9ydHMuUGFnZWRJdGVtIHx8IChleHBvcnRzLlBhZ2VkSXRlbSA9IHt9KSk7XG4vKipcbiAqIFBhZ2VyIGNsYXNzIGZvciBpdGVyYXRpbmcgdGhyb3VnaCBwYWdpbmF0ZWQgcmVzdWx0cy5cbiAqL1xuY2xhc3MgUGFnZXIge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHJlcXVlc3QsIHJlc3BvbnNlLCBwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5wYWdlSW50ZXJuYWwgPSBbXTtcbiAgICAgICAgdGhpcy5wYXJhbXNJbnRlcm5hbCA9IHt9O1xuICAgICAgICB0aGlzLnJlcXVlc3RJbnRlcm5hbCA9IHJlcXVlc3Q7XG4gICAgICAgIHRoaXMuaW5pdChuYW1lLCByZXNwb25zZSwgcGFyYW1zKTtcbiAgICB9XG4gICAgaW5pdChuYW1lLCByZXNwb25zZSwgcGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHRoaXMubmFtZUludGVybmFsID0gbmFtZTtcbiAgICAgICAgdGhpcy5wYWdlSW50ZXJuYWwgPSByZXNwb25zZVt0aGlzLm5hbWVJbnRlcm5hbF0gfHwgW107XG4gICAgICAgIHRoaXMuaWR4SW50ZXJuYWwgPSAwO1xuICAgICAgICBsZXQgcmVxdWVzdFBhcmFtcyA9IHsgY29uZmlnOiB7fSB9O1xuICAgICAgICBpZiAoIXBhcmFtcykge1xuICAgICAgICAgICAgcmVxdWVzdFBhcmFtcyA9IHsgY29uZmlnOiB7fSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBwYXJhbXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXF1ZXN0UGFyYW1zID0gT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcXVlc3RQYXJhbXMgPSBwYXJhbXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcXVlc3RQYXJhbXNbJ2NvbmZpZyddKSB7XG4gICAgICAgICAgICByZXF1ZXN0UGFyYW1zWydjb25maWcnXVsncGFnZVRva2VuJ10gPSByZXNwb25zZVsnbmV4dFBhZ2VUb2tlbiddO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFyYW1zSW50ZXJuYWwgPSByZXF1ZXN0UGFyYW1zO1xuICAgICAgICB0aGlzLnBhZ2VJbnRlcm5hbFNpemUgPVxuICAgICAgICAgICAgKF9iID0gKF9hID0gcmVxdWVzdFBhcmFtc1snY29uZmlnJ10pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVsncGFnZVNpemUnXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdGhpcy5wYWdlSW50ZXJuYWwubGVuZ3RoO1xuICAgIH1cbiAgICBpbml0TmV4dFBhZ2UocmVzcG9uc2UpIHtcbiAgICAgICAgdGhpcy5pbml0KHRoaXMubmFtZUludGVybmFsLCByZXNwb25zZSwgdGhpcy5wYXJhbXNJbnRlcm5hbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgcGFnZSwgd2hpY2ggaXMgYSBsaXN0IG9mIGl0ZW1zLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGUgZmlyc3QgcGFnZSBpcyByZXRyaWV2ZWQgd2hlbiB0aGUgcGFnZXIgaXMgY3JlYXRlZC4gVGhlIHJldHVybmVkIGxpc3Qgb2ZcbiAgICAgKiBpdGVtcyBjb3VsZCBiZSBhIHN1YnNldCBvZiB0aGUgZW50aXJlIGxpc3QuXG4gICAgICovXG4gICAgZ2V0IHBhZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhZ2VJbnRlcm5hbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdHlwZSBvZiBwYWdlZCBpdGVtIChmb3IgZXhhbXBsZSwgYGBiYXRjaF9qb2JzYGApLlxuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lSW50ZXJuYWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgcGFnZSBmZXRjaGVkIGVhY2ggdGltZSBieSB0aGlzIHBhZ2VyLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBwYWdlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgcGFnZSBsZW5ndGguXG4gICAgICovXG4gICAgZ2V0IHBhZ2VTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYWdlSW50ZXJuYWxTaXplO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwYXJhbWV0ZXJzIHdoZW4gbWFraW5nIHRoZSBBUEkgcmVxdWVzdCBmb3IgdGhlIG5leHQgcGFnZS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogUGFyYW1ldGVycyBjb250YWluIGEgc2V0IG9mIG9wdGlvbmFsIGNvbmZpZ3MgdGhhdCBjYW4gYmVcbiAgICAgKiB1c2VkIHRvIGN1c3RvbWl6ZSB0aGUgQVBJIHJlcXVlc3QuIEZvciBleGFtcGxlLCB0aGUgYHBhZ2VUb2tlbmAgcGFyYW1ldGVyXG4gICAgICogY29udGFpbnMgdGhlIHRva2VuIHRvIHJlcXVlc3QgdGhlIG5leHQgcGFnZS5cbiAgICAgKi9cbiAgICBnZXQgcGFyYW1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJhbXNJbnRlcm5hbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdG90YWwgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBjdXJyZW50IHBhZ2UuXG4gICAgICovXG4gICAgZ2V0IHBhZ2VMZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhZ2VJbnRlcm5hbC5sZW5ndGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGl0ZW0gYXQgdGhlIGdpdmVuIGluZGV4LlxuICAgICAqL1xuICAgIGdldEl0ZW0oaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFnZUludGVybmFsW2luZGV4XTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhc3luYyBpdGVyYXRvciB0aGF0IHN1cHBvcnQgaXRlcmF0aW5nIHRocm91Z2ggYWxsIGl0ZW1zXG4gICAgICogcmV0cmlldmVkIGZyb20gdGhlIEFQSS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhlIGl0ZXJhdG9yIHdpbGwgYXV0b21hdGljYWxseSBmZXRjaCB0aGUgbmV4dCBwYWdlIGlmIHRoZXJlIGFyZSBtb3JlIGl0ZW1zXG4gICAgICogdG8gZmV0Y2ggZnJvbSB0aGUgQVBJLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgcGFnZXIgPSBhd2FpdCBhaS5maWxlcy5saXN0KHtjb25maWc6IHtwYWdlU2l6ZTogMTB9fSk7XG4gICAgICogZm9yIGF3YWl0IChjb25zdCBmaWxlIG9mIHBhZ2VyKSB7XG4gICAgICogICBjb25zb2xlLmxvZyhmaWxlLm5hbWUpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmV4dDogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkeEludGVybmFsID49IHRoaXMucGFnZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNOZXh0UGFnZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLm5leHRQYWdlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuZ2V0SXRlbSh0aGlzLmlkeEludGVybmFsKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkeEludGVybmFsICs9IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGl0ZW0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmV0dXJuOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyB0aGUgbmV4dCBwYWdlIG9mIGl0ZW1zLiBUaGlzIG1ha2VzIGEgbmV3IEFQSSByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZXJlIGFyZSBubyBtb3JlIHBhZ2VzIHRvIGZldGNoLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgcGFnZXIgPSBhd2FpdCBhaS5maWxlcy5saXN0KHtjb25maWc6IHtwYWdlU2l6ZTogMTB9fSk7XG4gICAgICogbGV0IHBhZ2UgPSBwYWdlci5wYWdlO1xuICAgICAqIHdoaWxlICh0cnVlKSB7XG4gICAgICogICBmb3IgKGNvbnN0IGZpbGUgb2YgcGFnZSkge1xuICAgICAqICAgICBjb25zb2xlLmxvZyhmaWxlLm5hbWUpO1xuICAgICAqICAgfVxuICAgICAqICAgaWYgKCFwYWdlci5oYXNOZXh0UGFnZSgpKSB7XG4gICAgICogICAgIGJyZWFrO1xuICAgICAqICAgfVxuICAgICAqICAgcGFnZSA9IGF3YWl0IHBhZ2VyLm5leHRQYWdlKCk7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIG5leHRQYWdlKCkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzTmV4dFBhZ2UoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBtb3JlIHBhZ2VzIHRvIGZldGNoLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5yZXF1ZXN0SW50ZXJuYWwodGhpcy5wYXJhbXMpO1xuICAgICAgICB0aGlzLmluaXROZXh0UGFnZShyZXNwb25zZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhZ2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGVyZSBhcmUgbW9yZSBwYWdlcyB0byBmZXRjaCBmcm9tIHRoZSBBUEkuXG4gICAgICovXG4gICAgaGFzTmV4dFBhZ2UoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCgoX2EgPSB0aGlzLnBhcmFtc1snY29uZmlnJ10pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVsncGFnZVRva2VuJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbi8vIENvZGUgZ2VuZXJhdGVkIGJ5IHRoZSBHb29nbGUgR2VuIEFJIFNESyBnZW5lcmF0b3IgRE8gTk9UIEVESVQuXG4vKiogUmVxdWlyZWQuIE91dGNvbWUgb2YgdGhlIGNvZGUgZXhlY3V0aW9uLiAqL1xuZXhwb3J0cy5PdXRjb21lID0gdm9pZCAwO1xuKGZ1bmN0aW9uIChPdXRjb21lKSB7XG4gICAgT3V0Y29tZVtcIk9VVENPTUVfVU5TUEVDSUZJRURcIl0gPSBcIk9VVENPTUVfVU5TUEVDSUZJRURcIjtcbiAgICBPdXRjb21lW1wiT1VUQ09NRV9PS1wiXSA9IFwiT1VUQ09NRV9PS1wiO1xuICAgIE91dGNvbWVbXCJPVVRDT01FX0ZBSUxFRFwiXSA9IFwiT1VUQ09NRV9GQUlMRURcIjtcbiAgICBPdXRjb21lW1wiT1VUQ09NRV9ERUFETElORV9FWENFRURFRFwiXSA9IFwiT1VUQ09NRV9ERUFETElORV9FWENFRURFRFwiO1xufSkoZXhwb3J0cy5PdXRjb21lIHx8IChleHBvcnRzLk91dGNvbWUgPSB7fSkpO1xuLyoqIFJlcXVpcmVkLiBQcm9ncmFtbWluZyBsYW5ndWFnZSBvZiB0aGUgYGNvZGVgLiAqL1xuZXhwb3J0cy5MYW5ndWFnZSA9IHZvaWQgMDtcbihmdW5jdGlvbiAoTGFuZ3VhZ2UpIHtcbiAgICBMYW5ndWFnZVtcIkxBTkdVQUdFX1VOU1BFQ0lGSUVEXCJdID0gXCJMQU5HVUFHRV9VTlNQRUNJRklFRFwiO1xuICAgIExhbmd1YWdlW1wiUFlUSE9OXCJdID0gXCJQWVRIT05cIjtcbn0pKGV4cG9ydHMuTGFuZ3VhZ2UgfHwgKGV4cG9ydHMuTGFuZ3VhZ2UgPSB7fSkpO1xuLyoqIE9wdGlvbmFsLiBUaGUgdHlwZSBvZiB0aGUgZGF0YS4gKi9cbmV4cG9ydHMuVHlwZSA9IHZvaWQgMDtcbihmdW5jdGlvbiAoVHlwZSkge1xuICAgIFR5cGVbXCJUWVBFX1VOU1BFQ0lGSUVEXCJdID0gXCJUWVBFX1VOU1BFQ0lGSUVEXCI7XG4gICAgVHlwZVtcIlNUUklOR1wiXSA9IFwiU1RSSU5HXCI7XG4gICAgVHlwZVtcIk5VTUJFUlwiXSA9IFwiTlVNQkVSXCI7XG4gICAgVHlwZVtcIklOVEVHRVJcIl0gPSBcIklOVEVHRVJcIjtcbiAgICBUeXBlW1wiQk9PTEVBTlwiXSA9IFwiQk9PTEVBTlwiO1xuICAgIFR5cGVbXCJBUlJBWVwiXSA9IFwiQVJSQVlcIjtcbiAgICBUeXBlW1wiT0JKRUNUXCJdID0gXCJPQkpFQ1RcIjtcbn0pKGV4cG9ydHMuVHlwZSB8fCAoZXhwb3J0cy5UeXBlID0ge30pKTtcbi8qKiBSZXF1aXJlZC4gSGFybSBjYXRlZ29yeS4gKi9cbmV4cG9ydHMuSGFybUNhdGVnb3J5ID0gdm9pZCAwO1xuKGZ1bmN0aW9uIChIYXJtQ2F0ZWdvcnkpIHtcbiAgICBIYXJtQ2F0ZWdvcnlbXCJIQVJNX0NBVEVHT1JZX1VOU1BFQ0lGSUVEXCJdID0gXCJIQVJNX0NBVEVHT1JZX1VOU1BFQ0lGSUVEXCI7XG4gICAgSGFybUNhdGVnb3J5W1wiSEFSTV9DQVRFR09SWV9IQVRFX1NQRUVDSFwiXSA9IFwiSEFSTV9DQVRFR09SWV9IQVRFX1NQRUVDSFwiO1xuICAgIEhhcm1DYXRlZ29yeVtcIkhBUk1fQ0FURUdPUllfREFOR0VST1VTX0NPTlRFTlRcIl0gPSBcIkhBUk1fQ0FURUdPUllfREFOR0VST1VTX0NPTlRFTlRcIjtcbiAgICBIYXJtQ2F0ZWdvcnlbXCJIQVJNX0NBVEVHT1JZX0hBUkFTU01FTlRcIl0gPSBcIkhBUk1fQ0FURUdPUllfSEFSQVNTTUVOVFwiO1xuICAgIEhhcm1DYXRlZ29yeVtcIkhBUk1fQ0FURUdPUllfU0VYVUFMTFlfRVhQTElDSVRcIl0gPSBcIkhBUk1fQ0FURUdPUllfU0VYVUFMTFlfRVhQTElDSVRcIjtcbiAgICBIYXJtQ2F0ZWdvcnlbXCJIQVJNX0NBVEVHT1JZX0NJVklDX0lOVEVHUklUWVwiXSA9IFwiSEFSTV9DQVRFR09SWV9DSVZJQ19JTlRFR1JJVFlcIjtcbn0pKGV4cG9ydHMuSGFybUNhdGVnb3J5IHx8IChleHBvcnRzLkhhcm1DYXRlZ29yeSA9IHt9KSk7XG4vKiogT3B0aW9uYWwuIFNwZWNpZnkgaWYgdGhlIHRocmVzaG9sZCBpcyB1c2VkIGZvciBwcm9iYWJpbGl0eSBvciBzZXZlcml0eSBzY29yZS4gSWYgbm90IHNwZWNpZmllZCwgdGhlIHRocmVzaG9sZCBpcyB1c2VkIGZvciBwcm9iYWJpbGl0eSBzY29yZS4gKi9cbmV4cG9ydHMuSGFybUJsb2NrTWV0aG9kID0gdm9pZCAwO1xuKGZ1bmN0aW9uIChIYXJtQmxvY2tNZXRob2QpIHtcbiAgICBIYXJtQmxvY2tNZXRob2RbXCJIQVJNX0JMT0NLX01FVEhPRF9VTlNQRUNJRklFRFwiXSA9IFwiSEFSTV9CTE9DS19NRVRIT0RfVU5TUEVDSUZJRURcIjtcbiAgICBIYXJtQmxvY2tNZXRob2RbXCJTRVZFUklUWVwiXSA9IFwiU0VWRVJJVFlcIjtcbiAgICBIYXJtQmxvY2tNZXRob2RbXCJQUk9CQUJJTElUWVwiXSA9IFwiUFJPQkFCSUxJVFlcIjtcbn0pKGV4cG9ydHMuSGFybUJsb2NrTWV0aG9kIHx8IChleHBvcnRzLkhhcm1CbG9ja01ldGhvZCA9IHt9KSk7XG4vKiogUmVxdWlyZWQuIFRoZSBoYXJtIGJsb2NrIHRocmVzaG9sZC4gKi9cbmV4cG9ydHMuSGFybUJsb2NrVGhyZXNob2xkID0gdm9pZCAwO1xuKGZ1bmN0aW9uIChIYXJtQmxvY2tUaHJlc2hvbGQpIHtcbiAgICBIYXJtQmxvY2tUaHJlc2hvbGRbXCJIQVJNX0JMT0NLX1RIUkVTSE9MRF9VTlNQRUNJRklFRFwiXSA9IFwiSEFSTV9CTE9DS19USFJFU0hPTERfVU5TUEVDSUZJRURcIjtcbiAgICBIYXJtQmxvY2tUaHJlc2hvbGRbXCJCTE9DS19MT1dfQU5EX0FCT1ZFXCJdID0gXCJCTE9DS19MT1dfQU5EX0FCT1ZFXCI7XG4gICAgSGFybUJsb2NrVGhyZXNob2xkW1wiQkxPQ0tfTUVESVVNX0FORF9BQk9WRVwiXSA9IFwiQkxPQ0tfTUVESVVNX0FORF9BQk9WRVwiO1xuICAgIEhhcm1CbG9ja1RocmVzaG9sZFtcIkJMT0NLX09OTFlfSElHSFwiXSA9IFwiQkxPQ0tfT05MWV9ISUdIXCI7XG4gICAgSGFybUJsb2NrVGhyZXNob2xkW1wiQkxPQ0tfTk9ORVwiXSA9IFwiQkxPQ0tfTk9ORVwiO1xuICAgIEhhcm1CbG9ja1RocmVzaG9sZFtcIk9GRlwiXSA9IFwiT0ZGXCI7XG59KShleHBvcnRzLkhhcm1CbG9ja1RocmVzaG9sZCB8fCAoZXhwb3J0cy5IYXJtQmxvY2tUaHJlc2hvbGQgPSB7fSkpO1xuLyoqIFRoZSBtb2RlIG9mIHRoZSBwcmVkaWN0b3IgdG8gYmUgdXNlZCBpbiBkeW5hbWljIHJldHJpZXZhbC4gKi9cbmV4cG9ydHMuTW9kZSA9IHZvaWQgMDtcbihmdW5jdGlvbiAoTW9kZSkge1xuICAgIE1vZGVbXCJNT0RFX1VOU1BFQ0lGSUVEXCJdID0gXCJNT0RFX1VOU1BFQ0lGSUVEXCI7XG4gICAgTW9kZVtcIk1PREVfRFlOQU1JQ1wiXSA9IFwiTU9ERV9EWU5BTUlDXCI7XG59KShleHBvcnRzLk1vZGUgfHwgKGV4cG9ydHMuTW9kZSA9IHt9KSk7XG4vKiogT3V0cHV0IG9ubHkuIFRoZSByZWFzb24gd2h5IHRoZSBtb2RlbCBzdG9wcGVkIGdlbmVyYXRpbmcgdG9rZW5zLlxuXG4gIElmIGVtcHR5LCB0aGUgbW9kZWwgaGFzIG5vdCBzdG9wcGVkIGdlbmVyYXRpbmcgdGhlIHRva2Vucy5cbiAgICovXG5leHBvcnRzLkZpbmlzaFJlYXNvbiA9IHZvaWQgMDtcbihmdW5jdGlvbiAoRmluaXNoUmVhc29uKSB7XG4gICAgRmluaXNoUmVhc29uW1wiRklOSVNIX1JFQVNPTl9VTlNQRUNJRklFRFwiXSA9IFwiRklOSVNIX1JFQVNPTl9VTlNQRUNJRklFRFwiO1xuICAgIEZpbmlzaFJlYXNvbltcIlNUT1BcIl0gPSBcIlNUT1BcIjtcbiAgICBGaW5pc2hSZWFzb25bXCJNQVhfVE9LRU5TXCJdID0gXCJNQVhfVE9LRU5TXCI7XG4gICAgRmluaXNoUmVhc29uW1wiU0FGRVRZXCJdID0gXCJTQUZFVFlcIjtcbiAgICBGaW5pc2hSZWFzb25bXCJSRUNJVEFUSU9OXCJdID0gXCJSRUNJVEFUSU9OXCI7XG4gICAgRmluaXNoUmVhc29uW1wiTEFOR1VBR0VcIl0gPSBcIkxBTkdVQUdFXCI7XG4gICAgRmluaXNoUmVhc29uW1wiT1RIRVJcIl0gPSBcIk9USEVSXCI7XG4gICAgRmluaXNoUmVhc29uW1wiQkxPQ0tMSVNUXCJdID0gXCJCTE9DS0xJU1RcIjtcbiAgICBGaW5pc2hSZWFzb25bXCJQUk9ISUJJVEVEX0NPTlRFTlRcIl0gPSBcIlBST0hJQklURURfQ09OVEVOVFwiO1xuICAgIEZpbmlzaFJlYXNvbltcIlNQSUlcIl0gPSBcIlNQSUlcIjtcbiAgICBGaW5pc2hSZWFzb25bXCJNQUxGT1JNRURfRlVOQ1RJT05fQ0FMTFwiXSA9IFwiTUFMRk9STUVEX0ZVTkNUSU9OX0NBTExcIjtcbiAgICBGaW5pc2hSZWFzb25bXCJJTUFHRV9TQUZFVFlcIl0gPSBcIklNQUdFX1NBRkVUWVwiO1xufSkoZXhwb3J0cy5GaW5pc2hSZWFzb24gfHwgKGV4cG9ydHMuRmluaXNoUmVhc29uID0ge30pKTtcbi8qKiBPdXRwdXQgb25seS4gSGFybSBwcm9iYWJpbGl0eSBsZXZlbHMgaW4gdGhlIGNvbnRlbnQuICovXG5leHBvcnRzLkhhcm1Qcm9iYWJpbGl0eSA9IHZvaWQgMDtcbihmdW5jdGlvbiAoSGFybVByb2JhYmlsaXR5KSB7XG4gICAgSGFybVByb2JhYmlsaXR5W1wiSEFSTV9QUk9CQUJJTElUWV9VTlNQRUNJRklFRFwiXSA9IFwiSEFSTV9QUk9CQUJJTElUWV9VTlNQRUNJRklFRFwiO1xuICAgIEhhcm1Qcm9iYWJpbGl0eVtcIk5FR0xJR0lCTEVcIl0gPSBcIk5FR0xJR0lCTEVcIjtcbiAgICBIYXJtUHJvYmFiaWxpdHlbXCJMT1dcIl0gPSBcIkxPV1wiO1xuICAgIEhhcm1Qcm9iYWJpbGl0eVtcIk1FRElVTVwiXSA9IFwiTUVESVVNXCI7XG4gICAgSGFybVByb2JhYmlsaXR5W1wiSElHSFwiXSA9IFwiSElHSFwiO1xufSkoZXhwb3J0cy5IYXJtUHJvYmFiaWxpdHkgfHwgKGV4cG9ydHMuSGFybVByb2JhYmlsaXR5ID0ge30pKTtcbi8qKiBPdXRwdXQgb25seS4gSGFybSBzZXZlcml0eSBsZXZlbHMgaW4gdGhlIGNvbnRlbnQuICovXG5leHBvcnRzLkhhcm1TZXZlcml0eSA9IHZvaWQgMDtcbihmdW5jdGlvbiAoSGFybVNldmVyaXR5KSB7XG4gICAgSGFybVNldmVyaXR5W1wiSEFSTV9TRVZFUklUWV9VTlNQRUNJRklFRFwiXSA9IFwiSEFSTV9TRVZFUklUWV9VTlNQRUNJRklFRFwiO1xuICAgIEhhcm1TZXZlcml0eVtcIkhBUk1fU0VWRVJJVFlfTkVHTElHSUJMRVwiXSA9IFwiSEFSTV9TRVZFUklUWV9ORUdMSUdJQkxFXCI7XG4gICAgSGFybVNldmVyaXR5W1wiSEFSTV9TRVZFUklUWV9MT1dcIl0gPSBcIkhBUk1fU0VWRVJJVFlfTE9XXCI7XG4gICAgSGFybVNldmVyaXR5W1wiSEFSTV9TRVZFUklUWV9NRURJVU1cIl0gPSBcIkhBUk1fU0VWRVJJVFlfTUVESVVNXCI7XG4gICAgSGFybVNldmVyaXR5W1wiSEFSTV9TRVZFUklUWV9ISUdIXCJdID0gXCJIQVJNX1NFVkVSSVRZX0hJR0hcIjtcbn0pKGV4cG9ydHMuSGFybVNldmVyaXR5IHx8IChleHBvcnRzLkhhcm1TZXZlcml0eSA9IHt9KSk7XG4vKiogT3V0cHV0IG9ubHkuIEJsb2NrZWQgcmVhc29uLiAqL1xuZXhwb3J0cy5CbG9ja2VkUmVhc29uID0gdm9pZCAwO1xuKGZ1bmN0aW9uIChCbG9ja2VkUmVhc29uKSB7XG4gICAgQmxvY2tlZFJlYXNvbltcIkJMT0NLRURfUkVBU09OX1VOU1BFQ0lGSUVEXCJdID0gXCJCTE9DS0VEX1JFQVNPTl9VTlNQRUNJRklFRFwiO1xuICAgIEJsb2NrZWRSZWFzb25bXCJTQUZFVFlcIl0gPSBcIlNBRkVUWVwiO1xuICAgIEJsb2NrZWRSZWFzb25bXCJPVEhFUlwiXSA9IFwiT1RIRVJcIjtcbiAgICBCbG9ja2VkUmVhc29uW1wiQkxPQ0tMSVNUXCJdID0gXCJCTE9DS0xJU1RcIjtcbiAgICBCbG9ja2VkUmVhc29uW1wiUFJPSElCSVRFRF9DT05URU5UXCJdID0gXCJQUk9ISUJJVEVEX0NPTlRFTlRcIjtcbn0pKGV4cG9ydHMuQmxvY2tlZFJlYXNvbiB8fCAoZXhwb3J0cy5CbG9ja2VkUmVhc29uID0ge30pKTtcbi8qKiBPdXRwdXQgb25seS4gVHJhZmZpYyB0eXBlLiBUaGlzIHNob3dzIHdoZXRoZXIgYSByZXF1ZXN0IGNvbnN1bWVzIFBheS1Bcy1Zb3UtR28gb3IgUHJvdmlzaW9uZWQgVGhyb3VnaHB1dCBxdW90YS4gKi9cbmV4cG9ydHMuVHJhZmZpY1R5cGUgPSB2b2lkIDA7XG4oZnVuY3Rpb24gKFRyYWZmaWNUeXBlKSB7XG4gICAgVHJhZmZpY1R5cGVbXCJUUkFGRklDX1RZUEVfVU5TUEVDSUZJRURcIl0gPSBcIlRSQUZGSUNfVFlQRV9VTlNQRUNJRklFRFwiO1xuICAgIFRyYWZmaWNUeXBlW1wiT05fREVNQU5EXCJdID0gXCJPTl9ERU1BTkRcIjtcbiAgICBUcmFmZmljVHlwZVtcIlBST1ZJU0lPTkVEX1RIUk9VR0hQVVRcIl0gPSBcIlBST1ZJU0lPTkVEX1RIUk9VR0hQVVRcIjtcbn0pKGV4cG9ydHMuVHJhZmZpY1R5cGUgfHwgKGV4cG9ydHMuVHJhZmZpY1R5cGUgPSB7fSkpO1xuLyoqIFNlcnZlciBjb250ZW50IG1vZGFsaXRpZXMuICovXG5leHBvcnRzLk1vZGFsaXR5ID0gdm9pZCAwO1xuKGZ1bmN0aW9uIChNb2RhbGl0eSkge1xuICAgIE1vZGFsaXR5W1wiTU9EQUxJVFlfVU5TUEVDSUZJRURcIl0gPSBcIk1PREFMSVRZX1VOU1BFQ0lGSUVEXCI7XG4gICAgTW9kYWxpdHlbXCJURVhUXCJdID0gXCJURVhUXCI7XG4gICAgTW9kYWxpdHlbXCJJTUFHRVwiXSA9IFwiSU1BR0VcIjtcbiAgICBNb2RhbGl0eVtcIkFVRElPXCJdID0gXCJBVURJT1wiO1xufSkoZXhwb3J0cy5Nb2RhbGl0eSB8fCAoZXhwb3J0cy5Nb2RhbGl0eSA9IHt9KSk7XG4vKiogVGhlIG1lZGlhIHJlc29sdXRpb24gdG8gdXNlLiAqL1xuZXhwb3J0cy5NZWRpYVJlc29sdXRpb24gPSB2b2lkIDA7XG4oZnVuY3Rpb24gKE1lZGlhUmVzb2x1dGlvbikge1xuICAgIE1lZGlhUmVzb2x1dGlvbltcIk1FRElBX1JFU09MVVRJT05fVU5TUEVDSUZJRURcIl0gPSBcIk1FRElBX1JFU09MVVRJT05fVU5TUEVDSUZJRURcIjtcbiAgICBNZWRpYVJlc29sdXRpb25bXCJNRURJQV9SRVNPTFVUSU9OX0xPV1wiXSA9IFwiTUVESUFfUkVTT0xVVElPTl9MT1dcIjtcbiAgICBNZWRpYVJlc29sdXRpb25bXCJNRURJQV9SRVNPTFVUSU9OX01FRElVTVwiXSA9IFwiTUVESUFfUkVTT0xVVElPTl9NRURJVU1cIjtcbiAgICBNZWRpYVJlc29sdXRpb25bXCJNRURJQV9SRVNPTFVUSU9OX0hJR0hcIl0gPSBcIk1FRElBX1JFU09MVVRJT05fSElHSFwiO1xufSkoZXhwb3J0cy5NZWRpYVJlc29sdXRpb24gfHwgKGV4cG9ydHMuTWVkaWFSZXNvbHV0aW9uID0ge30pKTtcbi8qKiBPcHRpb25zIGZvciBmZWF0dXJlIHNlbGVjdGlvbiBwcmVmZXJlbmNlLiAqL1xuZXhwb3J0cy5GZWF0dXJlU2VsZWN0aW9uUHJlZmVyZW5jZSA9IHZvaWQgMDtcbihmdW5jdGlvbiAoRmVhdHVyZVNlbGVjdGlvblByZWZlcmVuY2UpIHtcbiAgICBGZWF0dXJlU2VsZWN0aW9uUHJlZmVyZW5jZVtcIkZFQVRVUkVfU0VMRUNUSU9OX1BSRUZFUkVOQ0VfVU5TUEVDSUZJRURcIl0gPSBcIkZFQVRVUkVfU0VMRUNUSU9OX1BSRUZFUkVOQ0VfVU5TUEVDSUZJRURcIjtcbiAgICBGZWF0dXJlU2VsZWN0aW9uUHJlZmVyZW5jZVtcIlBSSU9SSVRJWkVfUVVBTElUWVwiXSA9IFwiUFJJT1JJVElaRV9RVUFMSVRZXCI7XG4gICAgRmVhdHVyZVNlbGVjdGlvblByZWZlcmVuY2VbXCJCQUxBTkNFRFwiXSA9IFwiQkFMQU5DRURcIjtcbiAgICBGZWF0dXJlU2VsZWN0aW9uUHJlZmVyZW5jZVtcIlBSSU9SSVRJWkVfQ09TVFwiXSA9IFwiUFJJT1JJVElaRV9DT1NUXCI7XG59KShleHBvcnRzLkZlYXR1cmVTZWxlY3Rpb25QcmVmZXJlbmNlIHx8IChleHBvcnRzLkZlYXR1cmVTZWxlY3Rpb25QcmVmZXJlbmNlID0ge30pKTtcbi8qKiBDb25maWcgZm9yIHRoZSBkeW5hbWljIHJldHJpZXZhbCBjb25maWcgbW9kZS4gKi9cbmV4cG9ydHMuRHluYW1pY1JldHJpZXZhbENvbmZpZ01vZGUgPSB2b2lkIDA7XG4oZnVuY3Rpb24gKER5bmFtaWNSZXRyaWV2YWxDb25maWdNb2RlKSB7XG4gICAgRHluYW1pY1JldHJpZXZhbENvbmZpZ01vZGVbXCJNT0RFX1VOU1BFQ0lGSUVEXCJdID0gXCJNT0RFX1VOU1BFQ0lGSUVEXCI7XG4gICAgRHluYW1pY1JldHJpZXZhbENvbmZpZ01vZGVbXCJNT0RFX0RZTkFNSUNcIl0gPSBcIk1PREVfRFlOQU1JQ1wiO1xufSkoZXhwb3J0cy5EeW5hbWljUmV0cmlldmFsQ29uZmlnTW9kZSB8fCAoZXhwb3J0cy5EeW5hbWljUmV0cmlldmFsQ29uZmlnTW9kZSA9IHt9KSk7XG4vKiogQ29uZmlnIGZvciB0aGUgZnVuY3Rpb24gY2FsbGluZyBjb25maWcgbW9kZS4gKi9cbmV4cG9ydHMuRnVuY3Rpb25DYWxsaW5nQ29uZmlnTW9kZSA9IHZvaWQgMDtcbihmdW5jdGlvbiAoRnVuY3Rpb25DYWxsaW5nQ29uZmlnTW9kZSkge1xuICAgIEZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ01vZGVbXCJNT0RFX1VOU1BFQ0lGSUVEXCJdID0gXCJNT0RFX1VOU1BFQ0lGSUVEXCI7XG4gICAgRnVuY3Rpb25DYWxsaW5nQ29uZmlnTW9kZVtcIkFVVE9cIl0gPSBcIkFVVE9cIjtcbiAgICBGdW5jdGlvbkNhbGxpbmdDb25maWdNb2RlW1wiQU5ZXCJdID0gXCJBTllcIjtcbiAgICBGdW5jdGlvbkNhbGxpbmdDb25maWdNb2RlW1wiTk9ORVwiXSA9IFwiTk9ORVwiO1xufSkoZXhwb3J0cy5GdW5jdGlvbkNhbGxpbmdDb25maWdNb2RlIHx8IChleHBvcnRzLkZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ01vZGUgPSB7fSkpO1xuLyoqIEVudW0gdGhhdCBjb250cm9scyB0aGUgc2FmZXR5IGZpbHRlciBsZXZlbCBmb3Igb2JqZWN0aW9uYWJsZSBjb250ZW50LiAqL1xuZXhwb3J0cy5TYWZldHlGaWx0ZXJMZXZlbCA9IHZvaWQgMDtcbihmdW5jdGlvbiAoU2FmZXR5RmlsdGVyTGV2ZWwpIHtcbiAgICBTYWZldHlGaWx0ZXJMZXZlbFtcIkJMT0NLX0xPV19BTkRfQUJPVkVcIl0gPSBcIkJMT0NLX0xPV19BTkRfQUJPVkVcIjtcbiAgICBTYWZldHlGaWx0ZXJMZXZlbFtcIkJMT0NLX01FRElVTV9BTkRfQUJPVkVcIl0gPSBcIkJMT0NLX01FRElVTV9BTkRfQUJPVkVcIjtcbiAgICBTYWZldHlGaWx0ZXJMZXZlbFtcIkJMT0NLX09OTFlfSElHSFwiXSA9IFwiQkxPQ0tfT05MWV9ISUdIXCI7XG4gICAgU2FmZXR5RmlsdGVyTGV2ZWxbXCJCTE9DS19OT05FXCJdID0gXCJCTE9DS19OT05FXCI7XG59KShleHBvcnRzLlNhZmV0eUZpbHRlckxldmVsIHx8IChleHBvcnRzLlNhZmV0eUZpbHRlckxldmVsID0ge30pKTtcbi8qKiBFbnVtIHRoYXQgY29udHJvbHMgdGhlIGdlbmVyYXRpb24gb2YgcGVvcGxlLiAqL1xuZXhwb3J0cy5QZXJzb25HZW5lcmF0aW9uID0gdm9pZCAwO1xuKGZ1bmN0aW9uIChQZXJzb25HZW5lcmF0aW9uKSB7XG4gICAgUGVyc29uR2VuZXJhdGlvbltcIkRPTlRfQUxMT1dcIl0gPSBcIkRPTlRfQUxMT1dcIjtcbiAgICBQZXJzb25HZW5lcmF0aW9uW1wiQUxMT1dfQURVTFRcIl0gPSBcIkFMTE9XX0FEVUxUXCI7XG4gICAgUGVyc29uR2VuZXJhdGlvbltcIkFMTE9XX0FMTFwiXSA9IFwiQUxMT1dfQUxMXCI7XG59KShleHBvcnRzLlBlcnNvbkdlbmVyYXRpb24gfHwgKGV4cG9ydHMuUGVyc29uR2VuZXJhdGlvbiA9IHt9KSk7XG4vKiogRW51bSB0aGF0IHNwZWNpZmllcyB0aGUgbGFuZ3VhZ2Ugb2YgdGhlIHRleHQgaW4gdGhlIHByb21wdC4gKi9cbmV4cG9ydHMuSW1hZ2VQcm9tcHRMYW5ndWFnZSA9IHZvaWQgMDtcbihmdW5jdGlvbiAoSW1hZ2VQcm9tcHRMYW5ndWFnZSkge1xuICAgIEltYWdlUHJvbXB0TGFuZ3VhZ2VbXCJhdXRvXCJdID0gXCJhdXRvXCI7XG4gICAgSW1hZ2VQcm9tcHRMYW5ndWFnZVtcImVuXCJdID0gXCJlblwiO1xuICAgIEltYWdlUHJvbXB0TGFuZ3VhZ2VbXCJqYVwiXSA9IFwiamFcIjtcbiAgICBJbWFnZVByb21wdExhbmd1YWdlW1wia29cIl0gPSBcImtvXCI7XG4gICAgSW1hZ2VQcm9tcHRMYW5ndWFnZVtcImhpXCJdID0gXCJoaVwiO1xufSkoZXhwb3J0cy5JbWFnZVByb21wdExhbmd1YWdlIHx8IChleHBvcnRzLkltYWdlUHJvbXB0TGFuZ3VhZ2UgPSB7fSkpO1xuLyoqIFN0YXRlIGZvciB0aGUgbGlmZWN5Y2xlIG9mIGEgRmlsZS4gKi9cbmV4cG9ydHMuRmlsZVN0YXRlID0gdm9pZCAwO1xuKGZ1bmN0aW9uIChGaWxlU3RhdGUpIHtcbiAgICBGaWxlU3RhdGVbXCJTVEFURV9VTlNQRUNJRklFRFwiXSA9IFwiU1RBVEVfVU5TUEVDSUZJRURcIjtcbiAgICBGaWxlU3RhdGVbXCJQUk9DRVNTSU5HXCJdID0gXCJQUk9DRVNTSU5HXCI7XG4gICAgRmlsZVN0YXRlW1wiQUNUSVZFXCJdID0gXCJBQ1RJVkVcIjtcbiAgICBGaWxlU3RhdGVbXCJGQUlMRURcIl0gPSBcIkZBSUxFRFwiO1xufSkoZXhwb3J0cy5GaWxlU3RhdGUgfHwgKGV4cG9ydHMuRmlsZVN0YXRlID0ge30pKTtcbi8qKiBTb3VyY2Ugb2YgdGhlIEZpbGUuICovXG5leHBvcnRzLkZpbGVTb3VyY2UgPSB2b2lkIDA7XG4oZnVuY3Rpb24gKEZpbGVTb3VyY2UpIHtcbiAgICBGaWxlU291cmNlW1wiU09VUkNFX1VOU1BFQ0lGSUVEXCJdID0gXCJTT1VSQ0VfVU5TUEVDSUZJRURcIjtcbiAgICBGaWxlU291cmNlW1wiVVBMT0FERURcIl0gPSBcIlVQTE9BREVEXCI7XG4gICAgRmlsZVNvdXJjZVtcIkdFTkVSQVRFRFwiXSA9IFwiR0VORVJBVEVEXCI7XG59KShleHBvcnRzLkZpbGVTb3VyY2UgfHwgKGV4cG9ydHMuRmlsZVNvdXJjZSA9IHt9KSk7XG4vKiogRW51bSByZXByZXNlbnRpbmcgdGhlIG1hc2sgbW9kZSBvZiBhIG1hc2sgcmVmZXJlbmNlIGltYWdlLiAqL1xuZXhwb3J0cy5NYXNrUmVmZXJlbmNlTW9kZSA9IHZvaWQgMDtcbihmdW5jdGlvbiAoTWFza1JlZmVyZW5jZU1vZGUpIHtcbiAgICBNYXNrUmVmZXJlbmNlTW9kZVtcIk1BU0tfTU9ERV9ERUZBVUxUXCJdID0gXCJNQVNLX01PREVfREVGQVVMVFwiO1xuICAgIE1hc2tSZWZlcmVuY2VNb2RlW1wiTUFTS19NT0RFX1VTRVJfUFJPVklERURcIl0gPSBcIk1BU0tfTU9ERV9VU0VSX1BST1ZJREVEXCI7XG4gICAgTWFza1JlZmVyZW5jZU1vZGVbXCJNQVNLX01PREVfQkFDS0dST1VORFwiXSA9IFwiTUFTS19NT0RFX0JBQ0tHUk9VTkRcIjtcbiAgICBNYXNrUmVmZXJlbmNlTW9kZVtcIk1BU0tfTU9ERV9GT1JFR1JPVU5EXCJdID0gXCJNQVNLX01PREVfRk9SRUdST1VORFwiO1xuICAgIE1hc2tSZWZlcmVuY2VNb2RlW1wiTUFTS19NT0RFX1NFTUFOVElDXCJdID0gXCJNQVNLX01PREVfU0VNQU5USUNcIjtcbn0pKGV4cG9ydHMuTWFza1JlZmVyZW5jZU1vZGUgfHwgKGV4cG9ydHMuTWFza1JlZmVyZW5jZU1vZGUgPSB7fSkpO1xuLyoqIEVudW0gcmVwcmVzZW50aW5nIHRoZSBjb250cm9sIHR5cGUgb2YgYSBjb250cm9sIHJlZmVyZW5jZSBpbWFnZS4gKi9cbmV4cG9ydHMuQ29udHJvbFJlZmVyZW5jZVR5cGUgPSB2b2lkIDA7XG4oZnVuY3Rpb24gKENvbnRyb2xSZWZlcmVuY2VUeXBlKSB7XG4gICAgQ29udHJvbFJlZmVyZW5jZVR5cGVbXCJDT05UUk9MX1RZUEVfREVGQVVMVFwiXSA9IFwiQ09OVFJPTF9UWVBFX0RFRkFVTFRcIjtcbiAgICBDb250cm9sUmVmZXJlbmNlVHlwZVtcIkNPTlRST0xfVFlQRV9DQU5OWVwiXSA9IFwiQ09OVFJPTF9UWVBFX0NBTk5ZXCI7XG4gICAgQ29udHJvbFJlZmVyZW5jZVR5cGVbXCJDT05UUk9MX1RZUEVfU0NSSUJCTEVcIl0gPSBcIkNPTlRST0xfVFlQRV9TQ1JJQkJMRVwiO1xuICAgIENvbnRyb2xSZWZlcmVuY2VUeXBlW1wiQ09OVFJPTF9UWVBFX0ZBQ0VfTUVTSFwiXSA9IFwiQ09OVFJPTF9UWVBFX0ZBQ0VfTUVTSFwiO1xufSkoZXhwb3J0cy5Db250cm9sUmVmZXJlbmNlVHlwZSB8fCAoZXhwb3J0cy5Db250cm9sUmVmZXJlbmNlVHlwZSA9IHt9KSk7XG4vKiogRW51bSByZXByZXNlbnRpbmcgdGhlIHN1YmplY3QgdHlwZSBvZiBhIHN1YmplY3QgcmVmZXJlbmNlIGltYWdlLiAqL1xuZXhwb3J0cy5TdWJqZWN0UmVmZXJlbmNlVHlwZSA9IHZvaWQgMDtcbihmdW5jdGlvbiAoU3ViamVjdFJlZmVyZW5jZVR5cGUpIHtcbiAgICBTdWJqZWN0UmVmZXJlbmNlVHlwZVtcIlNVQkpFQ1RfVFlQRV9ERUZBVUxUXCJdID0gXCJTVUJKRUNUX1RZUEVfREVGQVVMVFwiO1xuICAgIFN1YmplY3RSZWZlcmVuY2VUeXBlW1wiU1VCSkVDVF9UWVBFX1BFUlNPTlwiXSA9IFwiU1VCSkVDVF9UWVBFX1BFUlNPTlwiO1xuICAgIFN1YmplY3RSZWZlcmVuY2VUeXBlW1wiU1VCSkVDVF9UWVBFX0FOSU1BTFwiXSA9IFwiU1VCSkVDVF9UWVBFX0FOSU1BTFwiO1xuICAgIFN1YmplY3RSZWZlcmVuY2VUeXBlW1wiU1VCSkVDVF9UWVBFX1BST0RVQ1RcIl0gPSBcIlNVQkpFQ1RfVFlQRV9QUk9EVUNUXCI7XG59KShleHBvcnRzLlN1YmplY3RSZWZlcmVuY2VUeXBlIHx8IChleHBvcnRzLlN1YmplY3RSZWZlcmVuY2VUeXBlID0ge30pKTtcbi8qKiBTZXJ2ZXIgY29udGVudCBtb2RhbGl0aWVzLiAqL1xuZXhwb3J0cy5NZWRpYU1vZGFsaXR5ID0gdm9pZCAwO1xuKGZ1bmN0aW9uIChNZWRpYU1vZGFsaXR5KSB7XG4gICAgTWVkaWFNb2RhbGl0eVtcIk1PREFMSVRZX1VOU1BFQ0lGSUVEXCJdID0gXCJNT0RBTElUWV9VTlNQRUNJRklFRFwiO1xuICAgIE1lZGlhTW9kYWxpdHlbXCJURVhUXCJdID0gXCJURVhUXCI7XG4gICAgTWVkaWFNb2RhbGl0eVtcIklNQUdFXCJdID0gXCJJTUFHRVwiO1xuICAgIE1lZGlhTW9kYWxpdHlbXCJWSURFT1wiXSA9IFwiVklERU9cIjtcbiAgICBNZWRpYU1vZGFsaXR5W1wiQVVESU9cIl0gPSBcIkFVRElPXCI7XG4gICAgTWVkaWFNb2RhbGl0eVtcIkRPQ1VNRU5UXCJdID0gXCJET0NVTUVOVFwiO1xufSkoZXhwb3J0cy5NZWRpYU1vZGFsaXR5IHx8IChleHBvcnRzLk1lZGlhTW9kYWxpdHkgPSB7fSkpO1xuLyoqIFN0YXJ0IG9mIHNwZWVjaCBzZW5zaXRpdml0eS4gKi9cbmV4cG9ydHMuU3RhcnRTZW5zaXRpdml0eSA9IHZvaWQgMDtcbihmdW5jdGlvbiAoU3RhcnRTZW5zaXRpdml0eSkge1xuICAgIFN0YXJ0U2Vuc2l0aXZpdHlbXCJTVEFSVF9TRU5TSVRJVklUWV9VTlNQRUNJRklFRFwiXSA9IFwiU1RBUlRfU0VOU0lUSVZJVFlfVU5TUEVDSUZJRURcIjtcbiAgICBTdGFydFNlbnNpdGl2aXR5W1wiU1RBUlRfU0VOU0lUSVZJVFlfSElHSFwiXSA9IFwiU1RBUlRfU0VOU0lUSVZJVFlfSElHSFwiO1xuICAgIFN0YXJ0U2Vuc2l0aXZpdHlbXCJTVEFSVF9TRU5TSVRJVklUWV9MT1dcIl0gPSBcIlNUQVJUX1NFTlNJVElWSVRZX0xPV1wiO1xufSkoZXhwb3J0cy5TdGFydFNlbnNpdGl2aXR5IHx8IChleHBvcnRzLlN0YXJ0U2Vuc2l0aXZpdHkgPSB7fSkpO1xuLyoqIEVuZCBvZiBzcGVlY2ggc2Vuc2l0aXZpdHkuICovXG5leHBvcnRzLkVuZFNlbnNpdGl2aXR5ID0gdm9pZCAwO1xuKGZ1bmN0aW9uIChFbmRTZW5zaXRpdml0eSkge1xuICAgIEVuZFNlbnNpdGl2aXR5W1wiRU5EX1NFTlNJVElWSVRZX1VOU1BFQ0lGSUVEXCJdID0gXCJFTkRfU0VOU0lUSVZJVFlfVU5TUEVDSUZJRURcIjtcbiAgICBFbmRTZW5zaXRpdml0eVtcIkVORF9TRU5TSVRJVklUWV9ISUdIXCJdID0gXCJFTkRfU0VOU0lUSVZJVFlfSElHSFwiO1xuICAgIEVuZFNlbnNpdGl2aXR5W1wiRU5EX1NFTlNJVElWSVRZX0xPV1wiXSA9IFwiRU5EX1NFTlNJVElWSVRZX0xPV1wiO1xufSkoZXhwb3J0cy5FbmRTZW5zaXRpdml0eSB8fCAoZXhwb3J0cy5FbmRTZW5zaXRpdml0eSA9IHt9KSk7XG4vKiogVGhlIGRpZmZlcmVudCB3YXlzIG9mIGhhbmRsaW5nIHVzZXIgYWN0aXZpdHkuICovXG5leHBvcnRzLkFjdGl2aXR5SGFuZGxpbmcgPSB2b2lkIDA7XG4oZnVuY3Rpb24gKEFjdGl2aXR5SGFuZGxpbmcpIHtcbiAgICBBY3Rpdml0eUhhbmRsaW5nW1wiQUNUSVZJVFlfSEFORExJTkdfVU5TUEVDSUZJRURcIl0gPSBcIkFDVElWSVRZX0hBTkRMSU5HX1VOU1BFQ0lGSUVEXCI7XG4gICAgQWN0aXZpdHlIYW5kbGluZ1tcIlNUQVJUX09GX0FDVElWSVRZX0lOVEVSUlVQVFNcIl0gPSBcIlNUQVJUX09GX0FDVElWSVRZX0lOVEVSUlVQVFNcIjtcbiAgICBBY3Rpdml0eUhhbmRsaW5nW1wiTk9fSU5URVJSVVBUSU9OXCJdID0gXCJOT19JTlRFUlJVUFRJT05cIjtcbn0pKGV4cG9ydHMuQWN0aXZpdHlIYW5kbGluZyB8fCAoZXhwb3J0cy5BY3Rpdml0eUhhbmRsaW5nID0ge30pKTtcbi8qKiBPcHRpb25zIGFib3V0IHdoaWNoIGlucHV0IGlzIGluY2x1ZGVkIGluIHRoZSB1c2VyJ3MgdHVybi4gKi9cbmV4cG9ydHMuVHVybkNvdmVyYWdlID0gdm9pZCAwO1xuKGZ1bmN0aW9uIChUdXJuQ292ZXJhZ2UpIHtcbiAgICBUdXJuQ292ZXJhZ2VbXCJUVVJOX0NPVkVSQUdFX1VOU1BFQ0lGSUVEXCJdID0gXCJUVVJOX0NPVkVSQUdFX1VOU1BFQ0lGSUVEXCI7XG4gICAgVHVybkNvdmVyYWdlW1wiVFVSTl9JTkNMVURFU19PTkxZX0FDVElWSVRZXCJdID0gXCJUVVJOX0lOQ0xVREVTX09OTFlfQUNUSVZJVFlcIjtcbiAgICBUdXJuQ292ZXJhZ2VbXCJUVVJOX0lOQ0xVREVTX0FMTF9JTlBVVFwiXSA9IFwiVFVSTl9JTkNMVURFU19BTExfSU5QVVRcIjtcbn0pKGV4cG9ydHMuVHVybkNvdmVyYWdlIHx8IChleHBvcnRzLlR1cm5Db3ZlcmFnZSA9IHt9KSk7XG4vKiogQSBmdW5jdGlvbiByZXNwb25zZS4gKi9cbmNsYXNzIEZ1bmN0aW9uUmVzcG9uc2Uge1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgYFBhcnRgIG9iamVjdCBmcm9tIGEgYFVSSWAgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBjcmVhdGVQYXJ0RnJvbVVyaSh1cmksIG1pbWVUeXBlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmlsZURhdGE6IHtcbiAgICAgICAgICAgIGZpbGVVcmk6IHVyaSxcbiAgICAgICAgICAgIG1pbWVUeXBlOiBtaW1lVHlwZSxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgYFBhcnRgIG9iamVjdCBmcm9tIGEgYHRleHRgIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGFydEZyb21UZXh0KHRleHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYSBgUGFydGAgb2JqZWN0IGZyb20gYSBgRnVuY3Rpb25DYWxsYCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBhcnRGcm9tRnVuY3Rpb25DYWxsKG5hbWUsIGFyZ3MpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBmdW5jdGlvbkNhbGw6IHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICBhcmdzOiBhcmdzLFxuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYSBgUGFydGAgb2JqZWN0IGZyb20gYSBgRnVuY3Rpb25SZXNwb25zZWAgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBjcmVhdGVQYXJ0RnJvbUZ1bmN0aW9uUmVzcG9uc2UoaWQsIG5hbWUsIHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZnVuY3Rpb25SZXNwb25zZToge1xuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIHJlc3BvbnNlOiByZXNwb25zZSxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgYFBhcnRgIG9iamVjdCBmcm9tIGEgYGJhc2U2NGAgZW5jb2RlZCBgc3RyaW5nYC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGFydEZyb21CYXNlNjQoZGF0YSwgbWltZVR5cGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpbmxpbmVEYXRhOiB7XG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgbWltZVR5cGU6IG1pbWVUeXBlLFxuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYSBgUGFydGAgb2JqZWN0IGZyb20gdGhlIGBvdXRjb21lYCBhbmQgYG91dHB1dGAgb2YgYSBgQ29kZUV4ZWN1dGlvblJlc3VsdGAgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBjcmVhdGVQYXJ0RnJvbUNvZGVFeGVjdXRpb25SZXN1bHQob3V0Y29tZSwgb3V0cHV0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29kZUV4ZWN1dGlvblJlc3VsdDoge1xuICAgICAgICAgICAgb3V0Y29tZTogb3V0Y29tZSxcbiAgICAgICAgICAgIG91dHB1dDogb3V0cHV0LFxuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYSBgUGFydGAgb2JqZWN0IGZyb20gdGhlIGBjb2RlYCBhbmQgYGxhbmd1YWdlYCBvZiBhbiBgRXhlY3V0YWJsZUNvZGVgIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGFydEZyb21FeGVjdXRhYmxlQ29kZShjb2RlLCBsYW5ndWFnZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGV4ZWN1dGFibGVDb2RlOiB7XG4gICAgICAgICAgICBjb2RlOiBjb2RlLFxuICAgICAgICAgICAgbGFuZ3VhZ2U6IGxhbmd1YWdlLFxuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiBfaXNQYXJ0KG9iaikge1xuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmogIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICgnZmlsZURhdGEnIGluIG9iaiB8fFxuICAgICAgICAgICAgJ3RleHQnIGluIG9iaiB8fFxuICAgICAgICAgICAgJ2Z1bmN0aW9uQ2FsbCcgaW4gb2JqIHx8XG4gICAgICAgICAgICAnZnVuY3Rpb25SZXNwb25zZScgaW4gb2JqIHx8XG4gICAgICAgICAgICAnaW5saW5lRGF0YScgaW4gb2JqIHx8XG4gICAgICAgICAgICAndmlkZW9NZXRhZGF0YScgaW4gb2JqIHx8XG4gICAgICAgICAgICAnY29kZUV4ZWN1dGlvblJlc3VsdCcgaW4gb2JqIHx8XG4gICAgICAgICAgICAnZXhlY3V0YWJsZUNvZGUnIGluIG9iaik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIF90b1BhcnRzKHBhcnRPclN0cmluZykge1xuICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgaWYgKHR5cGVvZiBwYXJ0T3JTdHJpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBhcnRzLnB1c2goY3JlYXRlUGFydEZyb21UZXh0KHBhcnRPclN0cmluZykpO1xuICAgIH1cbiAgICBlbHNlIGlmIChfaXNQYXJ0KHBhcnRPclN0cmluZykpIHtcbiAgICAgICAgcGFydHMucHVzaChwYXJ0T3JTdHJpbmcpO1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHBhcnRPclN0cmluZykpIHtcbiAgICAgICAgaWYgKHBhcnRPclN0cmluZy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGFydE9yU3RyaW5nIGNhbm5vdCBiZSBhbiBlbXB0eSBhcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0T3JTdHJpbmcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKGNyZWF0ZVBhcnRGcm9tVGV4dChwYXJ0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChfaXNQYXJ0KHBhcnQpKSB7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChwYXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZWxlbWVudCBpbiBQYXJ0VW5pb24gbXVzdCBiZSBhIFBhcnQgb2JqZWN0IG9yIHN0cmluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhcnRPclN0cmluZyBtdXN0IGJlIGEgUGFydCBvYmplY3QsIHN0cmluZywgb3IgYXJyYXknKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnRzO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgYENvbnRlbnRgIG9iamVjdCB3aXRoIGEgdXNlciByb2xlIGZyb20gYSBgUGFydExpc3RVbmlvbmAgb2JqZWN0IG9yIGBzdHJpbmdgLlxuICovXG5mdW5jdGlvbiBjcmVhdGVVc2VyQ29udGVudChwYXJ0T3JTdHJpbmcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICByb2xlOiAndXNlcicsXG4gICAgICAgIHBhcnRzOiBfdG9QYXJ0cyhwYXJ0T3JTdHJpbmcpLFxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYSBgQ29udGVudGAgb2JqZWN0IHdpdGggYSBtb2RlbCByb2xlIGZyb20gYSBgUGFydExpc3RVbmlvbmAgb2JqZWN0IG9yIGBzdHJpbmdgLlxuICovXG5mdW5jdGlvbiBjcmVhdGVNb2RlbENvbnRlbnQocGFydE9yU3RyaW5nKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcm9sZTogJ21vZGVsJyxcbiAgICAgICAgcGFydHM6IF90b1BhcnRzKHBhcnRPclN0cmluZyksXG4gICAgfTtcbn1cbi8qKiBDb250ZW50IGZpbHRlciByZXN1bHRzIGZvciBhIHByb21wdCBzZW50IGluIHRoZSByZXF1ZXN0LiAqL1xuY2xhc3MgR2VuZXJhdGVDb250ZW50UmVzcG9uc2VQcm9tcHRGZWVkYmFjayB7XG59XG4vKiogVXNhZ2UgbWV0YWRhdGEgYWJvdXQgcmVzcG9uc2UocykuICovXG5jbGFzcyBHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZVVzYWdlTWV0YWRhdGEge1xufVxuLyoqIFJlc3BvbnNlIG1lc3NhZ2UgZm9yIFByZWRpY3Rpb25TZXJ2aWNlLkdlbmVyYXRlQ29udGVudC4gKi9cbmNsYXNzIEdlbmVyYXRlQ29udGVudFJlc3BvbnNlIHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb25jYXRlbmF0aW9uIG9mIGFsbCB0ZXh0IHBhcnRzIGZyb20gdGhlIGZpcnN0IGNhbmRpZGF0ZSBpbiB0aGUgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIElmIHRoZXJlIGFyZSBtdWx0aXBsZSBjYW5kaWRhdGVzIGluIHRoZSByZXNwb25zZSwgdGhlIHRleHQgZnJvbSB0aGUgZmlyc3RcbiAgICAgKiBvbmUgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKiBJZiB0aGVyZSBhcmUgbm9uLXRleHQgcGFydHMgaW4gdGhlIHJlc3BvbnNlLCB0aGUgY29uY2F0ZW5hdGlvbiBvZiBhbGwgdGV4dFxuICAgICAqIHBhcnRzIHdpbGwgYmUgcmV0dXJuZWQsIGFuZCBhIHdhcm5pbmcgd2lsbCBiZSBsb2dnZWQuXG4gICAgICogSWYgdGhlcmUgYXJlIHRob3VnaHQgcGFydHMgaW4gdGhlIHJlc3BvbnNlLCB0aGUgY29uY2F0ZW5hdGlvbiBvZiBhbGwgdGV4dFxuICAgICAqIHBhcnRzIGV4Y2x1ZGluZyB0aGUgdGhvdWdodCBwYXJ0cyB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkubW9kZWxzLmdlbmVyYXRlQ29udGVudCh7XG4gICAgICogICBtb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gnLFxuICAgICAqICAgY29udGVudHM6XG4gICAgICogICAgICdXaHkgaXMgdGhlIHNreSBibHVlPycsXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmRlYnVnKHJlc3BvbnNlLnRleHQpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCB0ZXh0KCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oO1xuICAgICAgICBpZiAoKChfZCA9IChfYyA9IChfYiA9IChfYSA9IHRoaXMuY2FuZGlkYXRlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY29udGVudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnBhcnRzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jYW5kaWRhdGVzICYmIHRoaXMuY2FuZGlkYXRlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ3RoZXJlIGFyZSBtdWx0aXBsZSBjYW5kaWRhdGVzIGluIHRoZSByZXNwb25zZSwgcmV0dXJuaW5nIHRleHQgZnJvbSB0aGUgZmlyc3Qgb25lLicpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0ZXh0ID0gJyc7XG4gICAgICAgIGxldCBhbnlUZXh0UGFydFRleHQgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgbm9uVGV4dFBhcnRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiAoX2ggPSAoX2cgPSAoX2YgPSAoX2UgPSB0aGlzLmNhbmRpZGF0ZXMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZVswXSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmNvbnRlbnQpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5wYXJ0cykgIT09IG51bGwgJiYgX2ggIT09IHZvaWQgMCA/IF9oIDogW10pIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgZmllbGRWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocGFydCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGROYW1lICE9PSAndGV4dCcgJiZcbiAgICAgICAgICAgICAgICAgICAgZmllbGROYW1lICE9PSAndGhvdWdodCcgJiZcbiAgICAgICAgICAgICAgICAgICAgKGZpZWxkVmFsdWUgIT09IG51bGwgfHwgZmllbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICAgICAgICBub25UZXh0UGFydHMucHVzaChmaWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydC50ZXh0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydC50aG91Z2h0ID09PSAnYm9vbGVhbicgJiYgcGFydC50aG91Z2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhbnlUZXh0UGFydFRleHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRleHQgKz0gcGFydC50ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub25UZXh0UGFydHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGB0aGVyZSBhcmUgbm9uLXRleHQgcGFydHMgJHtub25UZXh0UGFydHN9IGluIHRoZSByZXNwb25zZSwgcmV0dXJuaW5nIGNvbmNhdGVuYXRpb24gb2YgYWxsIHRleHQgcGFydHMuIFBsZWFzZSByZWZlciB0byB0aGUgbm9uIHRleHQgcGFydHMgZm9yIGEgZnVsbCByZXNwb25zZSBmcm9tIG1vZGVsLmApO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhcnQudGV4dCA9PT0gJycgaXMgZGlmZmVyZW50IGZyb20gcGFydC50ZXh0IGlzIG51bGxcbiAgICAgICAgcmV0dXJuIGFueVRleHRQYXJ0VGV4dCA/IHRleHQgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbmNhdGVuYXRpb24gb2YgYWxsIGlubGluZSBkYXRhIHBhcnRzIGZyb20gdGhlIGZpcnN0IGNhbmRpZGF0ZVxuICAgICAqIGluIHRoZSByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogSWYgdGhlcmUgYXJlIG11bHRpcGxlIGNhbmRpZGF0ZXMgaW4gdGhlIHJlc3BvbnNlLCB0aGUgaW5saW5lIGRhdGEgZnJvbSB0aGVcbiAgICAgKiBmaXJzdCBvbmUgd2lsbCBiZSByZXR1cm5lZC4gSWYgdGhlcmUgYXJlIG5vbi1pbmxpbmUgZGF0YSBwYXJ0cyBpbiB0aGVcbiAgICAgKiByZXNwb25zZSwgdGhlIGNvbmNhdGVuYXRpb24gb2YgYWxsIGlubGluZSBkYXRhIHBhcnRzIHdpbGwgYmUgcmV0dXJuZWQsIGFuZFxuICAgICAqIGEgd2FybmluZyB3aWxsIGJlIGxvZ2dlZC5cbiAgICAgKi9cbiAgICBnZXQgZGF0YSgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcbiAgICAgICAgaWYgKCgoX2QgPSAoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLmNhbmRpZGF0ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNvbnRlbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5wYXJ0cykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmxlbmd0aCkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2FuZGlkYXRlcyAmJiB0aGlzLmNhbmRpZGF0ZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCd0aGVyZSBhcmUgbXVsdGlwbGUgY2FuZGlkYXRlcyBpbiB0aGUgcmVzcG9uc2UsIHJldHVybmluZyBkYXRhIGZyb20gdGhlIGZpcnN0IG9uZS4nKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGF0YSA9ICcnO1xuICAgICAgICBjb25zdCBub25EYXRhUGFydHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIChfaCA9IChfZyA9IChfZiA9IChfZSA9IHRoaXMuY2FuZGlkYXRlcykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lWzBdKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuY29udGVudCkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLnBhcnRzKSAhPT0gbnVsbCAmJiBfaCAhPT0gdm9pZCAwID8gX2ggOiBbXSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbZmllbGROYW1lLCBmaWVsZFZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwYXJ0KSkge1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZE5hbWUgIT09ICdpbmxpbmVEYXRhJyAmJlxuICAgICAgICAgICAgICAgICAgICAoZmllbGRWYWx1ZSAhPT0gbnVsbCB8fCBmaWVsZFZhbHVlICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vbkRhdGFQYXJ0cy5wdXNoKGZpZWxkTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcnQuaW5saW5lRGF0YSAmJiB0eXBlb2YgcGFydC5pbmxpbmVEYXRhLmRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgZGF0YSArPSBhdG9iKHBhcnQuaW5saW5lRGF0YS5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9uRGF0YVBhcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgdGhlcmUgYXJlIG5vbi1kYXRhIHBhcnRzICR7bm9uRGF0YVBhcnRzfSBpbiB0aGUgcmVzcG9uc2UsIHJldHVybmluZyBjb25jYXRlbmF0aW9uIG9mIGFsbCBkYXRhIHBhcnRzLiBQbGVhc2UgcmVmZXIgdG8gdGhlIG5vbiBkYXRhIHBhcnRzIGZvciBhIGZ1bGwgcmVzcG9uc2UgZnJvbSBtb2RlbC5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YS5sZW5ndGggPiAwID8gYnRvYShkYXRhKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZnVuY3Rpb24gY2FsbHMgZnJvbSB0aGUgZmlyc3QgY2FuZGlkYXRlIGluIHRoZSByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogSWYgdGhlcmUgYXJlIG11bHRpcGxlIGNhbmRpZGF0ZXMgaW4gdGhlIHJlc3BvbnNlLCB0aGUgZnVuY3Rpb24gY2FsbHMgZnJvbVxuICAgICAqIHRoZSBmaXJzdCBvbmUgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKiBJZiB0aGVyZSBhcmUgbm8gZnVuY3Rpb24gY2FsbHMgaW4gdGhlIHJlc3BvbnNlLCB1bmRlZmluZWQgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBjb250cm9sTGlnaHRGdW5jdGlvbkRlY2xhcmF0aW9uOiBGdW5jdGlvbkRlY2xhcmF0aW9uID0ge1xuICAgICAqICAgbmFtZTogJ2NvbnRyb2xMaWdodCcsXG4gICAgICogICBwYXJhbWV0ZXJzOiB7XG4gICAgICogICB0eXBlOiBUeXBlLk9CSkVDVCxcbiAgICAgKiAgIGRlc2NyaXB0aW9uOiAnU2V0IHRoZSBicmlnaHRuZXNzIGFuZCBjb2xvciB0ZW1wZXJhdHVyZSBvZiBhIHJvb20gbGlnaHQuJyxcbiAgICAgKiAgIHByb3BlcnRpZXM6IHtcbiAgICAgKiAgICAgYnJpZ2h0bmVzczoge1xuICAgICAqICAgICAgIHR5cGU6IFR5cGUuTlVNQkVSLFxuICAgICAqICAgICAgIGRlc2NyaXB0aW9uOlxuICAgICAqICAgICAgICAgJ0xpZ2h0IGxldmVsIGZyb20gMCB0byAxMDAuIFplcm8gaXMgb2ZmIGFuZCAxMDAgaXMgZnVsbCBicmlnaHRuZXNzLicsXG4gICAgICogICAgIH0sXG4gICAgICogICAgIGNvbG9yVGVtcGVyYXR1cmU6IHtcbiAgICAgKiAgICAgICB0eXBlOiBUeXBlLlNUUklORyxcbiAgICAgKiAgICAgICBkZXNjcmlwdGlvbjpcbiAgICAgKiAgICAgICAgICdDb2xvciB0ZW1wZXJhdHVyZSBvZiB0aGUgbGlnaHQgZml4dHVyZSB3aGljaCBjYW4gYmUgYGRheWxpZ2h0YCwgYGNvb2xgIG9yIGB3YXJtYC4nLFxuICAgICAqICAgICB9LFxuICAgICAqICAgfSxcbiAgICAgKiAgIHJlcXVpcmVkOiBbJ2JyaWdodG5lc3MnLCAnY29sb3JUZW1wZXJhdHVyZSddLFxuICAgICAqICB9O1xuICAgICAqICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLm1vZGVscy5nZW5lcmF0ZUNvbnRlbnQoe1xuICAgICAqICAgICBtb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gnLFxuICAgICAqICAgICBjb250ZW50czogJ0RpbSB0aGUgbGlnaHRzIHNvIHRoZSByb29tIGZlZWxzIGNvenkgYW5kIHdhcm0uJyxcbiAgICAgKiAgICAgY29uZmlnOiB7XG4gICAgICogICAgICAgdG9vbHM6IFt7ZnVuY3Rpb25EZWNsYXJhdGlvbnM6IFtjb250cm9sTGlnaHRGdW5jdGlvbkRlY2xhcmF0aW9uXX1dLFxuICAgICAqICAgICAgIHRvb2xDb25maWc6IHtcbiAgICAgKiAgICAgICAgIGZ1bmN0aW9uQ2FsbGluZ0NvbmZpZzoge1xuICAgICAqICAgICAgICAgICBtb2RlOiBGdW5jdGlvbkNhbGxpbmdDb25maWdNb2RlLkFOWSxcbiAgICAgKiAgICAgICAgICAgYWxsb3dlZEZ1bmN0aW9uTmFtZXM6IFsnY29udHJvbExpZ2h0J10sXG4gICAgICogICAgICAgICB9LFxuICAgICAqICAgICAgIH0sXG4gICAgICogICAgIH0sXG4gICAgICogICB9KTtcbiAgICAgKiAgY29uc29sZS5kZWJ1ZyhKU09OLnN0cmluZ2lmeShyZXNwb25zZS5mdW5jdGlvbkNhbGxzKSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IGZ1bmN0aW9uQ2FsbHMoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2g7XG4gICAgICAgIGlmICgoKF9kID0gKF9jID0gKF9iID0gKF9hID0gdGhpcy5jYW5kaWRhdGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jb250ZW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucGFydHMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5sZW5ndGgpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNhbmRpZGF0ZXMgJiYgdGhpcy5jYW5kaWRhdGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybigndGhlcmUgYXJlIG11bHRpcGxlIGNhbmRpZGF0ZXMgaW4gdGhlIHJlc3BvbnNlLCByZXR1cm5pbmcgZnVuY3Rpb24gY2FsbHMgZnJvbSB0aGUgZmlyc3Qgb25lLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZ1bmN0aW9uQ2FsbHMgPSAoX2ggPSAoX2cgPSAoX2YgPSAoX2UgPSB0aGlzLmNhbmRpZGF0ZXMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZVswXSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmNvbnRlbnQpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5wYXJ0cykgPT09IG51bGwgfHwgX2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oLmZpbHRlcigocGFydCkgPT4gcGFydC5mdW5jdGlvbkNhbGwpLm1hcCgocGFydCkgPT4gcGFydC5mdW5jdGlvbkNhbGwpLmZpbHRlcigoZnVuY3Rpb25DYWxsKSA9PiBmdW5jdGlvbkNhbGwgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgIGlmICgoZnVuY3Rpb25DYWxscyA9PT0gbnVsbCB8fCBmdW5jdGlvbkNhbGxzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmdW5jdGlvbkNhbGxzLmxlbmd0aCkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uQ2FsbHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IGV4ZWN1dGFibGUgY29kZSBmcm9tIHRoZSBmaXJzdCBjYW5kaWRhdGUgaW4gdGhlIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgY2FuZGlkYXRlcyBpbiB0aGUgcmVzcG9uc2UsIHRoZSBleGVjdXRhYmxlIGNvZGUgZnJvbVxuICAgICAqIHRoZSBmaXJzdCBvbmUgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKiBJZiB0aGVyZSBhcmUgbm8gZXhlY3V0YWJsZSBjb2RlIGluIHRoZSByZXNwb25zZSwgdW5kZWZpbmVkIHdpbGwgYmVcbiAgICAgKiByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLm1vZGVscy5nZW5lcmF0ZUNvbnRlbnQoe1xuICAgICAqICAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJyxcbiAgICAgKiAgIGNvbnRlbnRzOlxuICAgICAqICAgICAnV2hhdCBpcyB0aGUgc3VtIG9mIHRoZSBmaXJzdCA1MCBwcmltZSBudW1iZXJzPyBHZW5lcmF0ZSBhbmQgcnVuIGNvZGUgZm9yIHRoZSBjYWxjdWxhdGlvbiwgYW5kIG1ha2Ugc3VyZSB5b3UgZ2V0IGFsbCA1MC4nXG4gICAgICogICBjb25maWc6IHtcbiAgICAgKiAgICAgdG9vbHM6IFt7Y29kZUV4ZWN1dGlvbjoge319XSxcbiAgICAgKiAgIH0sXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmRlYnVnKHJlc3BvbnNlLmV4ZWN1dGFibGVDb2RlKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXQgZXhlY3V0YWJsZUNvZGUoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qO1xuICAgICAgICBpZiAoKChfZCA9IChfYyA9IChfYiA9IChfYSA9IHRoaXMuY2FuZGlkYXRlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY29udGVudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnBhcnRzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jYW5kaWRhdGVzICYmIHRoaXMuY2FuZGlkYXRlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ3RoZXJlIGFyZSBtdWx0aXBsZSBjYW5kaWRhdGVzIGluIHRoZSByZXNwb25zZSwgcmV0dXJuaW5nIGV4ZWN1dGFibGUgY29kZSBmcm9tIHRoZSBmaXJzdCBvbmUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXhlY3V0YWJsZUNvZGUgPSAoX2ggPSAoX2cgPSAoX2YgPSAoX2UgPSB0aGlzLmNhbmRpZGF0ZXMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZVswXSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmNvbnRlbnQpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5wYXJ0cykgPT09IG51bGwgfHwgX2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oLmZpbHRlcigocGFydCkgPT4gcGFydC5leGVjdXRhYmxlQ29kZSkubWFwKChwYXJ0KSA9PiBwYXJ0LmV4ZWN1dGFibGVDb2RlKS5maWx0ZXIoKGV4ZWN1dGFibGVDb2RlKSA9PiBleGVjdXRhYmxlQ29kZSAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKChleGVjdXRhYmxlQ29kZSA9PT0gbnVsbCB8fCBleGVjdXRhYmxlQ29kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXhlY3V0YWJsZUNvZGUubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKF9qID0gZXhlY3V0YWJsZUNvZGUgPT09IG51bGwgfHwgZXhlY3V0YWJsZUNvZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV4ZWN1dGFibGVDb2RlWzBdKSA9PT0gbnVsbCB8fCBfaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2ouY29kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3QgY29kZSBleGVjdXRpb24gcmVzdWx0IGZyb20gdGhlIGZpcnN0IGNhbmRpZGF0ZSBpbiB0aGUgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIElmIHRoZXJlIGFyZSBtdWx0aXBsZSBjYW5kaWRhdGVzIGluIHRoZSByZXNwb25zZSwgdGhlIGNvZGUgZXhlY3V0aW9uIHJlc3VsdCBmcm9tXG4gICAgICogdGhlIGZpcnN0IG9uZSB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqIElmIHRoZXJlIGFyZSBubyBjb2RlIGV4ZWN1dGlvbiByZXN1bHQgaW4gdGhlIHJlc3BvbnNlLCB1bmRlZmluZWQgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLm1vZGVscy5nZW5lcmF0ZUNvbnRlbnQoe1xuICAgICAqICAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJyxcbiAgICAgKiAgIGNvbnRlbnRzOlxuICAgICAqICAgICAnV2hhdCBpcyB0aGUgc3VtIG9mIHRoZSBmaXJzdCA1MCBwcmltZSBudW1iZXJzPyBHZW5lcmF0ZSBhbmQgcnVuIGNvZGUgZm9yIHRoZSBjYWxjdWxhdGlvbiwgYW5kIG1ha2Ugc3VyZSB5b3UgZ2V0IGFsbCA1MC4nXG4gICAgICogICBjb25maWc6IHtcbiAgICAgKiAgICAgdG9vbHM6IFt7Y29kZUV4ZWN1dGlvbjoge319XSxcbiAgICAgKiAgIH0sXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmRlYnVnKHJlc3BvbnNlLmNvZGVFeGVjdXRpb25SZXN1bHQpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCBjb2RlRXhlY3V0aW9uUmVzdWx0KCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfajtcbiAgICAgICAgaWYgKCgoX2QgPSAoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLmNhbmRpZGF0ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNvbnRlbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5wYXJ0cykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmxlbmd0aCkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2FuZGlkYXRlcyAmJiB0aGlzLmNhbmRpZGF0ZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCd0aGVyZSBhcmUgbXVsdGlwbGUgY2FuZGlkYXRlcyBpbiB0aGUgcmVzcG9uc2UsIHJldHVybmluZyBjb2RlIGV4ZWN1dGlvbiByZXN1bHQgZnJvbSB0aGUgZmlyc3Qgb25lLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvZGVFeGVjdXRpb25SZXN1bHQgPSAoX2ggPSAoX2cgPSAoX2YgPSAoX2UgPSB0aGlzLmNhbmRpZGF0ZXMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZVswXSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmNvbnRlbnQpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5wYXJ0cykgPT09IG51bGwgfHwgX2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oLmZpbHRlcigocGFydCkgPT4gcGFydC5jb2RlRXhlY3V0aW9uUmVzdWx0KS5tYXAoKHBhcnQpID0+IHBhcnQuY29kZUV4ZWN1dGlvblJlc3VsdCkuZmlsdGVyKChjb2RlRXhlY3V0aW9uUmVzdWx0KSA9PiBjb2RlRXhlY3V0aW9uUmVzdWx0ICE9PSB1bmRlZmluZWQpO1xuICAgICAgICBpZiAoKGNvZGVFeGVjdXRpb25SZXN1bHQgPT09IG51bGwgfHwgY29kZUV4ZWN1dGlvblJlc3VsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29kZUV4ZWN1dGlvblJlc3VsdC5sZW5ndGgpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoX2ogPSBjb2RlRXhlY3V0aW9uUmVzdWx0ID09PSBudWxsIHx8IGNvZGVFeGVjdXRpb25SZXN1bHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvZGVFeGVjdXRpb25SZXN1bHRbMF0pID09PSBudWxsIHx8IF9qID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfai5vdXRwdXQ7XG4gICAgfVxufVxuLyoqIFJlc3BvbnNlIGZvciB0aGUgZW1iZWRfY29udGVudCBtZXRob2QuICovXG5jbGFzcyBFbWJlZENvbnRlbnRSZXNwb25zZSB7XG59XG4vKiogVGhlIG91dHB1dCBpbWFnZXMgcmVzcG9uc2UuICovXG5jbGFzcyBHZW5lcmF0ZUltYWdlc1Jlc3BvbnNlIHtcbn1cbi8qKiBSZXNwb25zZSBmb3IgY291bnRpbmcgdG9rZW5zLiAqL1xuY2xhc3MgQ291bnRUb2tlbnNSZXNwb25zZSB7XG59XG4vKiogUmVzcG9uc2UgZm9yIGNvbXB1dGluZyB0b2tlbnMuICovXG5jbGFzcyBDb21wdXRlVG9rZW5zUmVzcG9uc2Uge1xufVxuLyoqIFJlc3BvbnNlIHdpdGggZ2VuZXJhdGVkIHZpZGVvcy4gKi9cbmNsYXNzIEdlbmVyYXRlVmlkZW9zUmVzcG9uc2Uge1xufVxuLyoqIEVtcHR5IHJlc3BvbnNlIGZvciBjYWNoZXMuZGVsZXRlIG1ldGhvZC4gKi9cbmNsYXNzIERlbGV0ZUNhY2hlZENvbnRlbnRSZXNwb25zZSB7XG59XG5jbGFzcyBMaXN0Q2FjaGVkQ29udGVudHNSZXNwb25zZSB7XG59XG4vKiogUmVzcG9uc2UgZm9yIHRoZSBsaXN0IGZpbGVzIG1ldGhvZC4gKi9cbmNsYXNzIExpc3RGaWxlc1Jlc3BvbnNlIHtcbn1cbi8qKiBBIHdyYXBwZXIgY2xhc3MgZm9yIHRoZSBodHRwIHJlc3BvbnNlLiAqL1xuY2xhc3MgSHR0cFJlc3BvbnNlIHtcbiAgICBjb25zdHJ1Y3RvcihyZXNwb25zZSkge1xuICAgICAgICAvLyBQcm9jZXNzIHRoZSBoZWFkZXJzLlxuICAgICAgICBjb25zdCBoZWFkZXJzID0ge307XG4gICAgICAgIGZvciAoY29uc3QgcGFpciBvZiByZXNwb25zZS5oZWFkZXJzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgaGVhZGVyc1twYWlyWzBdXSA9IHBhaXJbMV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycztcbiAgICAgICAgLy8gS2VlcCB0aGUgb3JpZ2luYWwgcmVzcG9uc2UuXG4gICAgICAgIHRoaXMucmVzcG9uc2VJbnRlcm5hbCA9IHJlc3BvbnNlO1xuICAgIH1cbiAgICBqc29uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNwb25zZUludGVybmFsLmpzb24oKTtcbiAgICB9XG59XG4vKiogUmVzcG9uc2UgZm9yIHRoZSBjcmVhdGUgZmlsZSBtZXRob2QuICovXG5jbGFzcyBDcmVhdGVGaWxlUmVzcG9uc2Uge1xufVxuLyoqIFJlc3BvbnNlIGZvciB0aGUgZGVsZXRlIGZpbGUgbWV0aG9kLiAqL1xuY2xhc3MgRGVsZXRlRmlsZVJlc3BvbnNlIHtcbn1cbi8qKiBSZXByZXNlbnRzIGEgc2luZ2xlIHJlc3BvbnNlIGluIGEgcmVwbGF5LiAqL1xuY2xhc3MgUmVwbGF5UmVzcG9uc2Uge1xufVxuLyoqIENsaWVudCBnZW5lcmF0ZWQgcmVzcG9uc2UgdG8gYSBgVG9vbENhbGxgIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlci5cblxuICBJbmRpdmlkdWFsIGBGdW5jdGlvblJlc3BvbnNlYCBvYmplY3RzIGFyZSBtYXRjaGVkIHRvIHRoZSByZXNwZWN0aXZlXG4gIGBGdW5jdGlvbkNhbGxgIG9iamVjdHMgYnkgdGhlIGBpZGAgZmllbGQuXG5cbiAgTm90ZSB0aGF0IGluIHRoZSB1bmFyeSBhbmQgc2VydmVyLXN0cmVhbWluZyBHZW5lcmF0ZUNvbnRlbnQgQVBJcyBmdW5jdGlvblxuICBjYWxsaW5nIGhhcHBlbnMgYnkgZXhjaGFuZ2luZyB0aGUgYENvbnRlbnRgIHBhcnRzLCB3aGlsZSBpbiB0aGUgYmlkaVxuICBHZW5lcmF0ZUNvbnRlbnQgQVBJcyBmdW5jdGlvbiBjYWxsaW5nIGhhcHBlbnMgb3ZlciB0aGlzIGRlZGljYXRlZCBzZXQgb2ZcbiAgbWVzc2FnZXMuXG4gICAqL1xuY2xhc3MgTGl2ZUNsaWVudFRvb2xSZXNwb25zZSB7XG59XG4vKiogUGFyYW1ldGVycyBmb3Igc2VuZGluZyB0b29sIHJlc3BvbnNlcyB0byB0aGUgbGl2ZSBBUEkuICovXG5jbGFzcyBMaXZlU2VuZFRvb2xSZXNwb25zZVBhcmFtZXRlcnMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvKiogVG9vbCByZXNwb25zZXMgdG8gc2VuZCB0byB0aGUgc2Vzc2lvbi4gKi9cbiAgICAgICAgdGhpcy5mdW5jdGlvblJlc3BvbnNlcyA9IFtdO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY2xhc3MgQ2FjaGVzIGV4dGVuZHMgQmFzZU1vZHVsZSB7XG4gICAgY29uc3RydWN0b3IoYXBpQ2xpZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdHMgY2FjaGVkIGNvbnRlbnQgY29uZmlndXJhdGlvbnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGxpc3QgcmVxdWVzdC5cbiAgICAgICAgICogQHJldHVybiBUaGUgcGFnaW5hdGVkIHJlc3VsdHMgb2YgdGhlIGxpc3Qgb2YgY2FjaGVkIGNvbnRlbnRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBjb25zdCBjYWNoZWRDb250ZW50cyA9IGF3YWl0IGFpLmNhY2hlcy5saXN0KHtjb25maWc6IHsncGFnZVNpemUnOiAyfX0pO1xuICAgICAgICAgKiBmb3IgKGNvbnN0IGNhY2hlZENvbnRlbnQgb2YgY2FjaGVkQ29udGVudHMpIHtcbiAgICAgICAgICogICBjb25zb2xlLmxvZyhjYWNoZWRDb250ZW50KTtcbiAgICAgICAgICogfVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGlzdCA9IGFzeW5jIChwYXJhbXMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYWdlcihleHBvcnRzLlBhZ2VkSXRlbS5QQUdFRF9JVEVNX0NBQ0hFRF9DT05URU5UUywgKHgpID0+IHRoaXMubGlzdEludGVybmFsKHgpLCBhd2FpdCB0aGlzLmxpc3RJbnRlcm5hbChwYXJhbXMpLCBwYXJhbXMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2FjaGVkIGNvbnRlbnRzIHJlc291cmNlLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBDb250ZXh0IGNhY2hpbmcgaXMgb25seSBzdXBwb3J0ZWQgZm9yIHNwZWNpZmljIG1vZGVscy4gU2VlIFtHZW1pbmlcbiAgICAgKiBEZXZlbG9wZXIgQVBJIHJlZmVyZW5jZV0oaHR0cHM6Ly9haS5nb29nbGUuZGV2L2dlbWluaS1hcGkvZG9jcy9jYWNoaW5nP2xhbmc9bm9kZS9jb250ZXh0LWNhYylcbiAgICAgKiBhbmQgW1ZlcnRleCBBSSByZWZlcmVuY2VdKGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS92ZXJ0ZXgtYWkvZ2VuZXJhdGl2ZS1haS9kb2NzL2NvbnRleHQtY2FjaGUvY29udGV4dC1jYWNoZS1vdmVydmlldyNzdXBwb3J0ZWRfbW9kZWxzKVxuICAgICAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgY3JlYXRlIHJlcXVlc3QuXG4gICAgICogQHJldHVybiBUaGUgY3JlYXRlZCBjYWNoZWQgY29udGVudC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBjb250ZW50cyA9IC4uLjsgLy8gSW5pdGlhbGl6ZSB0aGUgY29udGVudCB0byBjYWNoZS5cbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLmNhY2hlcy5jcmVhdGUoe1xuICAgICAqICAgbW9kZWw6ICdnZW1pbmktMS41LWZsYXNoJyxcbiAgICAgKiAgIGNvbmZpZzoge1xuICAgICAqICAgICdjb250ZW50cyc6IGNvbnRlbnRzLFxuICAgICAqICAgICdkaXNwbGF5TmFtZSc6ICd0ZXN0IGNhY2hlJyxcbiAgICAgKiAgICAnc3lzdGVtSW5zdHJ1Y3Rpb24nOiAnV2hhdCBpcyB0aGUgc3VtIG9mIHRoZSB0d28gcGRmcz8nLFxuICAgICAqICAgICd0dGwnOiAnODY0MDBzJyxcbiAgICAgKiAgfVxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY3JlYXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2NhY2hlZENvbnRlbnRzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnY29uZmlnJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBjYWNoZWRDb250ZW50RnJvbVZlcnRleCh0aGlzLmFwaUNsaWVudCwgYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY3JlYXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnY2FjaGVkQ29udGVudHMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGNhY2hlZENvbnRlbnRGcm9tTWxkZXYodGhpcy5hcGlDbGllbnQsIGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgY2FjaGVkIGNvbnRlbnQgY29uZmlndXJhdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBnZXQgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIFRoZSBjYWNoZWQgY29udGVudC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBhd2FpdCBhaS5jYWNoZXMuZ2V0KHtuYW1lOiAnZ2VtaW5pLTEuNS1mbGFzaCd9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBnZXQocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdldENhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gY2FjaGVkQ29udGVudEZyb21WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdldENhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBjYWNoZWRDb250ZW50RnJvbU1sZGV2KHRoaXMuYXBpQ2xpZW50LCBhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGNhY2hlZCBjb250ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgZGVsZXRlIHJlcXVlc3QuXG4gICAgICogQHJldHVybiBUaGUgZW1wdHkgcmVzcG9uc2UgcmV0dXJuZWQgYnkgdGhlIEFQSS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBhd2FpdCBhaS5jYWNoZXMuZGVsZXRlKHtuYW1lOiAnZ2VtaW5pLTEuNS1mbGFzaCd9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGUocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGRlbGV0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGRlbGV0ZUNhY2hlZENvbnRlbnRSZXNwb25zZUZyb21WZXJ0ZXgoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgRGVsZXRlQ2FjaGVkQ29udGVudFJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBkZWxldGVDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGRlbGV0ZUNhY2hlZENvbnRlbnRSZXNwb25zZUZyb21NbGRldigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBEZWxldGVDYWNoZWRDb250ZW50UmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgY2FjaGVkIGNvbnRlbnQgY29uZmlndXJhdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSB1cGRhdGUgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIFRoZSB1cGRhdGVkIGNhY2hlZCBjb250ZW50LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkuY2FjaGVzLnVwZGF0ZSh7XG4gICAgICogICBuYW1lOiAnZ2VtaW5pLTEuNS1mbGFzaCcsXG4gICAgICogICBjb25maWc6IHsndHRsJzogJzc2MDBzJ31cbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGUocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IHVwZGF0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQQVRDSCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBjYWNoZWRDb250ZW50RnJvbVZlcnRleCh0aGlzLmFwaUNsaWVudCwgYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gdXBkYXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnY29uZmlnJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUEFUQ0gnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gY2FjaGVkQ29udGVudEZyb21NbGRldih0aGlzLmFwaUNsaWVudCwgYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgbGlzdEludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBsaXN0Q2FjaGVkQ29udGVudHNQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdjYWNoZWRDb250ZW50cycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBsaXN0Q2FjaGVkQ29udGVudHNSZXNwb25zZUZyb21WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgTGlzdENhY2hlZENvbnRlbnRzUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGxpc3RDYWNoZWRDb250ZW50c1BhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnY2FjaGVkQ29udGVudHMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gbGlzdENhY2hlZENvbnRlbnRzUmVzcG9uc2VGcm9tTWxkZXYodGhpcy5hcGlDbGllbnQsIGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgTGlzdENhY2hlZENvbnRlbnRzUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UsIFN1cHByZXNzZWRFcnJvciwgU3ltYm9sLCBJdGVyYXRvciAqL1xyXG5cclxuXHJcbmZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICByZXR1cm4gaSA9IE9iamVjdC5jcmVhdGUoKHR5cGVvZiBBc3luY0l0ZXJhdG9yID09PSBcImZ1bmN0aW9uXCIgPyBBc3luY0l0ZXJhdG9yIDogT2JqZWN0KS5wcm90b3R5cGUpLCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIsIGF3YWl0UmV0dXJuKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gYXdhaXRSZXR1cm4oZikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGYsIHJlamVjdCk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpZiAoZ1tuXSkgeyBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyBpZiAoZikgaVtuXSA9IGYoaVtuXSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cclxuXHJcbnR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uIChlcnJvciwgc3VwcHJlc3NlZCwgbWVzc2FnZSkge1xyXG4gICAgdmFyIGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgICByZXR1cm4gZS5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgZS5lcnJvciA9IGVycm9yLCBlLnN1cHByZXNzZWQgPSBzdXBwcmVzc2VkLCBlO1xyXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcmVzcG9uc2UgaXMgdmFsaWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZFJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChyZXNwb25zZS5jYW5kaWRhdGVzID09IHVuZGVmaW5lZCB8fCByZXNwb25zZS5jYW5kaWRhdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRlbnQgPSAoX2EgPSByZXNwb25zZS5jYW5kaWRhdGVzWzBdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29udGVudDtcbiAgICBpZiAoY29udGVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzVmFsaWRDb250ZW50KGNvbnRlbnQpO1xufVxuZnVuY3Rpb24gaXNWYWxpZENvbnRlbnQoY29udGVudCkge1xuICAgIGlmIChjb250ZW50LnBhcnRzID09PSB1bmRlZmluZWQgfHwgY29udGVudC5wYXJ0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHBhcnQgb2YgY29udGVudC5wYXJ0cykge1xuICAgICAgICBpZiAocGFydCA9PT0gdW5kZWZpbmVkIHx8IE9iamVjdC5rZXlzKHBhcnQpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LnRleHQgIT09IHVuZGVmaW5lZCAmJiBwYXJ0LnRleHQgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIFZhbGlkYXRlcyB0aGUgaGlzdG9yeSBjb250YWlucyB0aGUgY29ycmVjdCByb2xlcy5cbiAqXG4gKiBAcmVtYXJrc1xuICogRXhwZWN0cyB0aGUgaGlzdG9yeSB0byBzdGFydCB3aXRoIGEgdXNlciB0dXJuIGFuZCB0aGVuIGFsdGVybmF0ZSBiZXR3ZWVuXG4gKiB1c2VyIGFuZCBtb2RlbCB0dXJucy5cbiAqXG4gKiBAdGhyb3dzIEVycm9yIGlmIHRoZSBoaXN0b3J5IGRvZXMgbm90IHN0YXJ0IHdpdGggYSB1c2VyIHR1cm4uXG4gKiBAdGhyb3dzIEVycm9yIGlmIHRoZSBoaXN0b3J5IGNvbnRhaW5zIGFuIGludmFsaWQgcm9sZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVIaXN0b3J5KGhpc3RvcnkpIHtcbiAgICAvLyBFbXB0eSBoaXN0b3J5IGlzIHZhbGlkLlxuICAgIGlmIChoaXN0b3J5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChoaXN0b3J5WzBdLnJvbGUgIT09ICd1c2VyJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hpc3RvcnkgbXVzdCBzdGFydCB3aXRoIGEgdXNlciB0dXJuLicpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGNvbnRlbnQgb2YgaGlzdG9yeSkge1xuICAgICAgICBpZiAoY29udGVudC5yb2xlICE9PSAndXNlcicgJiYgY29udGVudC5yb2xlICE9PSAnbW9kZWwnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJvbGUgbXVzdCBiZSB1c2VyIG9yIG1vZGVsLCBidXQgZ290ICR7Y29udGVudC5yb2xlfS5gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogRXh0cmFjdHMgdGhlIGN1cmF0ZWQgKHZhbGlkKSBoaXN0b3J5IGZyb20gYSBjb21wcmVoZW5zaXZlIGhpc3RvcnkuXG4gKlxuICogQHJlbWFya3NcbiAqIFRoZSBtb2RlbCBtYXkgc29tZXRpbWVzIGdlbmVyYXRlIGludmFsaWQgb3IgZW1wdHkgY29udGVudHMoZS5nLiwgZHVlIHRvIHNhZnR5XG4gKiBmaWx0ZXJzIG9yIHJlY2l0YXRpb24pLiBFeHRyYWN0aW5nIHZhbGlkIHR1cm5zIGZyb20gdGhlIGhpc3RvcnlcbiAqIGVuc3VyZXMgdGhhdCBzdWJzZXF1ZW50IHJlcXVlc3RzIGNvdWxkIGJlIGFjY3BldGVkIGJ5IHRoZSBtb2RlbC5cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdEN1cmF0ZWRIaXN0b3J5KGNvbXByZWhlbnNpdmVIaXN0b3J5KSB7XG4gICAgaWYgKGNvbXByZWhlbnNpdmVIaXN0b3J5ID09PSB1bmRlZmluZWQgfHwgY29tcHJlaGVuc2l2ZUhpc3RvcnkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgY3VyYXRlZEhpc3RvcnkgPSBbXTtcbiAgICBjb25zdCBsZW5ndGggPSBjb21wcmVoZW5zaXZlSGlzdG9yeS5sZW5ndGg7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCB1c2VySW5wdXQgPSBjb21wcmVoZW5zaXZlSGlzdG9yeVswXTtcbiAgICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgICAgICBpZiAoY29tcHJlaGVuc2l2ZUhpc3RvcnlbaV0ucm9sZSA9PT0gJ3VzZXInKSB7XG4gICAgICAgICAgICB1c2VySW5wdXQgPSBjb21wcmVoZW5zaXZlSGlzdG9yeVtpXTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG1vZGVsT3V0cHV0ID0gW107XG4gICAgICAgICAgICBsZXQgaXNWYWxpZCA9IHRydWU7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IGxlbmd0aCAmJiBjb21wcmVoZW5zaXZlSGlzdG9yeVtpXS5yb2xlID09PSAnbW9kZWwnKSB7XG4gICAgICAgICAgICAgICAgbW9kZWxPdXRwdXQucHVzaChjb21wcmVoZW5zaXZlSGlzdG9yeVtpXSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzVmFsaWQgJiYgIWlzVmFsaWRDb250ZW50KGNvbXByZWhlbnNpdmVIaXN0b3J5W2ldKSkge1xuICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgY3VyYXRlZEhpc3RvcnkucHVzaCh1c2VySW5wdXQpO1xuICAgICAgICAgICAgICAgIGN1cmF0ZWRIaXN0b3J5LnB1c2goLi4ubW9kZWxPdXRwdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjdXJhdGVkSGlzdG9yeTtcbn1cbi8qKlxuICogQSB1dGlsaXR5IGNsYXNzIHRvIGNyZWF0ZSBhIGNoYXQgc2Vzc2lvbi5cbiAqL1xuY2xhc3MgQ2hhdHMge1xuICAgIGNvbnN0cnVjdG9yKG1vZGVsc01vZHVsZSwgYXBpQ2xpZW50KSB7XG4gICAgICAgIHRoaXMubW9kZWxzTW9kdWxlID0gbW9kZWxzTW9kdWxlO1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBjaGF0IHNlc3Npb24uXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRoZSBjb25maWcgaW4gdGhlIHBhcmFtcyB3aWxsIGJlIHVzZWQgZm9yIGFsbCByZXF1ZXN0cyB3aXRoaW4gdGhlIGNoYXRcbiAgICAgKiBzZXNzaW9uIHVubGVzcyBvdmVycmlkZGVuIGJ5IGEgcGVyLXJlcXVlc3QgYGNvbmZpZ2AgaW5cbiAgICAgKiBAc2VlIHtAbGluayB0eXBlcy5TZW5kTWVzc2FnZVBhcmFtZXRlcnMjY29uZmlnfS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBQYXJhbWV0ZXJzIGZvciBjcmVhdGluZyBhIGNoYXQgc2Vzc2lvbi5cbiAgICAgKiBAcmV0dXJucyBBIG5ldyBjaGF0IHNlc3Npb24uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgY2hhdCA9IGFpLmNoYXRzLmNyZWF0ZSh7XG4gICAgICogICBtb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gnXG4gICAgICogICBjb25maWc6IHtcbiAgICAgKiAgICAgdGVtcGVyYXR1cmU6IDAuNSxcbiAgICAgKiAgICAgbWF4T3V0cHV0VG9rZW5zOiAxMDI0LFxuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGNyZWF0ZShwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGF0KHRoaXMuYXBpQ2xpZW50LCB0aGlzLm1vZGVsc01vZHVsZSwgcGFyYW1zLm1vZGVsLCBwYXJhbXMuY29uZmlnLCBwYXJhbXMuaGlzdG9yeSk7XG4gICAgfVxufVxuLyoqXG4gKiBDaGF0IHNlc3Npb24gdGhhdCBlbmFibGVzIHNlbmRpbmcgbWVzc2FnZXMgdG8gdGhlIG1vZGVsIHdpdGggcHJldmlvdXNcbiAqIGNvbnZlcnNhdGlvbiBjb250ZXh0LlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGUgc2Vzc2lvbiBtYWludGFpbnMgYWxsIHRoZSB0dXJucyBiZXR3ZWVuIHVzZXIgYW5kIG1vZGVsLlxuICovXG5jbGFzcyBDaGF0IHtcbiAgICBjb25zdHJ1Y3RvcihhcGlDbGllbnQsIG1vZGVsc01vZHVsZSwgbW9kZWwsIGNvbmZpZyA9IHt9LCBoaXN0b3J5ID0gW10pIHtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBhcGlDbGllbnQ7XG4gICAgICAgIHRoaXMubW9kZWxzTW9kdWxlID0gbW9kZWxzTW9kdWxlO1xuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLmhpc3RvcnkgPSBoaXN0b3J5O1xuICAgICAgICAvLyBBIHByb21pc2UgdG8gcmVwcmVzZW50IHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBtZXNzYWdlIGJlaW5nIHNlbnQgdG8gdGhlXG4gICAgICAgIC8vIG1vZGVsLlxuICAgICAgICB0aGlzLnNlbmRQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIHZhbGlkYXRlSGlzdG9yeShoaXN0b3J5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBtZXNzYWdlIHRvIHRoZSBtb2RlbCBhbmQgcmV0dXJucyB0aGUgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgd2FpdCBmb3IgdGhlIHByZXZpb3VzIG1lc3NhZ2UgdG8gYmUgcHJvY2Vzc2VkIGJlZm9yZVxuICAgICAqIHNlbmRpbmcgdGhlIG5leHQgbWVzc2FnZS5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIENoYXQjc2VuZE1lc3NhZ2VTdHJlYW19IGZvciBzdHJlYW1pbmcgbWV0aG9kLlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBwYXJhbWV0ZXJzIGZvciBzZW5kaW5nIG1lc3NhZ2VzIHdpdGhpbiBhIGNoYXQgc2Vzc2lvbi5cbiAgICAgKiBAcmV0dXJucyBUaGUgbW9kZWwncyByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBjaGF0ID0gYWkuY2hhdHMuY3JlYXRlKHttb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gnfSk7XG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjaGF0LnNlbmRNZXNzYWdlKHtcbiAgICAgKiAgIG1lc3NhZ2U6ICdXaHkgaXMgdGhlIHNreSBibHVlPydcbiAgICAgKiB9KTtcbiAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZS50ZXh0KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBzZW5kTWVzc2FnZShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBhd2FpdCB0aGlzLnNlbmRQcm9taXNlO1xuICAgICAgICBjb25zdCBpbnB1dENvbnRlbnQgPSB0Q29udGVudCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zLm1lc3NhZ2UpO1xuICAgICAgICBjb25zdCByZXNwb25zZVByb21pc2UgPSB0aGlzLm1vZGVsc01vZHVsZS5nZW5lcmF0ZUNvbnRlbnQoe1xuICAgICAgICAgICAgbW9kZWw6IHRoaXMubW9kZWwsXG4gICAgICAgICAgICBjb250ZW50czogdGhpcy5nZXRIaXN0b3J5KHRydWUpLmNvbmNhdChpbnB1dENvbnRlbnQpLFxuICAgICAgICAgICAgY29uZmlnOiAoX2EgPSBwYXJhbXMuY29uZmlnKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLmNvbmZpZyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2VuZFByb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVzcG9uc2VQcm9taXNlO1xuICAgICAgICAgICAgY29uc3Qgb3V0cHV0Q29udGVudCA9IChfYiA9IChfYSA9IHJlc3BvbnNlLmNhbmRpZGF0ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNvbnRlbnQ7XG4gICAgICAgICAgICBjb25zdCBtb2RlbE91dHB1dCA9IG91dHB1dENvbnRlbnQgPyBbb3V0cHV0Q29udGVudF0gOiBbXTtcbiAgICAgICAgICAgIHRoaXMucmVjb3JkSGlzdG9yeShpbnB1dENvbnRlbnQsIG1vZGVsT3V0cHV0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kUHJvbWlzZTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlUHJvbWlzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBtZXNzYWdlIHRvIHRoZSBtb2RlbCBhbmQgcmV0dXJucyB0aGUgcmVzcG9uc2UgaW4gY2h1bmtzLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIHdhaXQgZm9yIHRoZSBwcmV2aW91cyBtZXNzYWdlIHRvIGJlIHByb2Nlc3NlZCBiZWZvcmVcbiAgICAgKiBzZW5kaW5nIHRoZSBuZXh0IG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBDaGF0I3NlbmRNZXNzYWdlfSBmb3Igbm9uLXN0cmVhbWluZyBtZXRob2QuXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIHBhcmFtZXRlcnMgZm9yIHNlbmRpbmcgdGhlIG1lc3NhZ2UuXG4gICAgICogQHJldHVybiBUaGUgbW9kZWwncyByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBjaGF0ID0gYWkuY2hhdHMuY3JlYXRlKHttb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gnfSk7XG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjaGF0LnNlbmRNZXNzYWdlU3RyZWFtKHtcbiAgICAgKiAgIG1lc3NhZ2U6ICdXaHkgaXMgdGhlIHNreSBibHVlPydcbiAgICAgKiB9KTtcbiAgICAgKiBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHJlc3BvbnNlKSB7XG4gICAgICogICBjb25zb2xlLmxvZyhjaHVuay50ZXh0KTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgc2VuZE1lc3NhZ2VTdHJlYW0ocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kUHJvbWlzZTtcbiAgICAgICAgY29uc3QgaW5wdXRDb250ZW50ID0gdENvbnRlbnQodGhpcy5hcGlDbGllbnQsIHBhcmFtcy5tZXNzYWdlKTtcbiAgICAgICAgY29uc3Qgc3RyZWFtUmVzcG9uc2UgPSB0aGlzLm1vZGVsc01vZHVsZS5nZW5lcmF0ZUNvbnRlbnRTdHJlYW0oe1xuICAgICAgICAgICAgbW9kZWw6IHRoaXMubW9kZWwsXG4gICAgICAgICAgICBjb250ZW50czogdGhpcy5nZXRIaXN0b3J5KHRydWUpLmNvbmNhdChpbnB1dENvbnRlbnQpLFxuICAgICAgICAgICAgY29uZmlnOiAoX2EgPSBwYXJhbXMuY29uZmlnKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLmNvbmZpZyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2VuZFByb21pc2UgPSBzdHJlYW1SZXNwb25zZS50aGVuKCgpID0+IHVuZGVmaW5lZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc3RyZWFtUmVzcG9uc2U7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucHJvY2Vzc1N0cmVhbVJlc3BvbnNlKHJlc3BvbnNlLCBpbnB1dENvbnRlbnQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjaGF0IGhpc3RvcnkuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRoZSBoaXN0b3J5IGlzIGEgbGlzdCBvZiBjb250ZW50cyBhbHRlcm5hdGluZyBiZXR3ZWVuIHVzZXIgYW5kIG1vZGVsLlxuICAgICAqXG4gICAgICogVGhlcmUgYXJlIHR3byB0eXBlcyBvZiBoaXN0b3J5OlxuICAgICAqIC0gVGhlIGBjdXJhdGVkIGhpc3RvcnlgIGNvbnRhaW5zIG9ubHkgdGhlIHZhbGlkIHR1cm5zIGJldHdlZW4gdXNlciBhbmRcbiAgICAgKiBtb2RlbCwgd2hpY2ggd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgc3Vic2VxdWVudCByZXF1ZXN0cyBzZW50IHRvIHRoZSBtb2RlbC5cbiAgICAgKiAtIFRoZSBgY29tcHJlaGVuc2l2ZSBoaXN0b3J5YCBjb250YWlucyBhbGwgdHVybnMsIGluY2x1ZGluZyBpbnZhbGlkIG9yXG4gICAgICogICBlbXB0eSBtb2RlbCBvdXRwdXRzLCBwcm92aWRpbmcgYSBjb21wbGV0ZSByZWNvcmQgb2YgdGhlIGhpc3RvcnkuXG4gICAgICpcbiAgICAgKiBUaGUgaGlzdG9yeSBpcyB1cGRhdGVkIGFmdGVyIHJlY2VpdmluZyB0aGUgcmVzcG9uc2UgZnJvbSB0aGUgbW9kZWwsXG4gICAgICogZm9yIHN0cmVhbWluZyByZXNwb25zZSwgaXQgbWVhbnMgcmVjZWl2aW5nIHRoZSBsYXN0IGNodW5rIG9mIHRoZSByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIFRoZSBgY29tcHJlaGVuc2l2ZSBoaXN0b3J5YCBpcyByZXR1cm5lZCBieSBkZWZhdWx0LiBUbyBnZXQgdGhlIGBjdXJhdGVkXG4gICAgICogaGlzdG9yeWAsIHNldCB0aGUgYGN1cmF0ZWRgIHBhcmFtZXRlciB0byBgdHJ1ZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY3VyYXRlZCAtIHdoZXRoZXIgdG8gcmV0dXJuIHRoZSBjdXJhdGVkIGhpc3Rvcnkgb3IgdGhlIGNvbXByZWhlbnNpdmVcbiAgICAgKiAgICAgaGlzdG9yeS5cbiAgICAgKiBAcmV0dXJuIEhpc3RvcnkgY29udGVudHMgYWx0ZXJuYXRpbmcgYmV0d2VlbiB1c2VyIGFuZCBtb2RlbCBmb3IgdGhlIGVudGlyZVxuICAgICAqICAgICBjaGF0IHNlc3Npb24uXG4gICAgICovXG4gICAgZ2V0SGlzdG9yeShjdXJhdGVkID0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGN1cmF0ZWQgPyBleHRyYWN0Q3VyYXRlZEhpc3RvcnkodGhpcy5oaXN0b3J5KSA6IHRoaXMuaGlzdG9yeTtcbiAgICB9XG4gICAgcHJvY2Vzc1N0cmVhbVJlc3BvbnNlKHN0cmVhbVJlc3BvbnNlLCBpbnB1dENvbnRlbnQpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogcHJvY2Vzc1N0cmVhbVJlc3BvbnNlXzEoKSB7XG4gICAgICAgICAgICB2YXIgX2MsIGVfMSwgX2QsIF9lO1xuICAgICAgICAgICAgY29uc3Qgb3V0cHV0Q29udGVudCA9IFtdO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfZiA9IHRydWUsIHN0cmVhbVJlc3BvbnNlXzEgPSBfX2FzeW5jVmFsdWVzKHN0cmVhbVJlc3BvbnNlKSwgc3RyZWFtUmVzcG9uc2VfMV8xOyBzdHJlYW1SZXNwb25zZV8xXzEgPSB5aWVsZCBfX2F3YWl0KHN0cmVhbVJlc3BvbnNlXzEubmV4dCgpKSwgX2MgPSBzdHJlYW1SZXNwb25zZV8xXzEuZG9uZSwgIV9jOyBfZiA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgX2UgPSBzdHJlYW1SZXNwb25zZV8xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIF9mID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gX2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkUmVzcG9uc2UoY2h1bmspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gKF9iID0gKF9hID0gY2h1bmsuY2FuZGlkYXRlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRDb250ZW50LnB1c2goY29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdChjaHVuayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX2YgJiYgIV9jICYmIChfZCA9IHN0cmVhbVJlc3BvbnNlXzEucmV0dXJuKSkgeWllbGQgX19hd2FpdChfZC5jYWxsKHN0cmVhbVJlc3BvbnNlXzEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZWNvcmRIaXN0b3J5KGlucHV0Q29udGVudCwgb3V0cHV0Q29udGVudCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZWNvcmRIaXN0b3J5KHVzZXJJbnB1dCwgbW9kZWxPdXRwdXQpIHtcbiAgICAgICAgbGV0IG91dHB1dENvbnRlbnRzID0gW107XG4gICAgICAgIGlmIChtb2RlbE91dHB1dC5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICBtb2RlbE91dHB1dC5ldmVyeSgoY29udGVudCkgPT4gY29udGVudC5yb2xlID09PSAnbW9kZWwnKSkge1xuICAgICAgICAgICAgb3V0cHV0Q29udGVudHMgPSBtb2RlbE91dHB1dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEFwcGVuZHMgYW4gZW1wdHkgY29udGVudCB3aGVuIG1vZGVsIHJldHVybnMgZW1wdHkgcmVzcG9uc2UsIHNvIHRoYXQgdGhlXG4gICAgICAgICAgICAvLyBoaXN0b3J5IGlzIGFsd2F5cyBhbHRlcm5hdGluZyBiZXR3ZWVuIHVzZXIgYW5kIG1vZGVsLlxuICAgICAgICAgICAgb3V0cHV0Q29udGVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgcm9sZTogJ21vZGVsJyxcbiAgICAgICAgICAgICAgICBwYXJ0czogW10sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhpc3RvcnkucHVzaCh1c2VySW5wdXQpO1xuICAgICAgICB0aGlzLmhpc3RvcnkucHVzaCguLi5vdXRwdXRDb250ZW50cyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5mdW5jdGlvbiBsaXN0RmlsZXNDb25maWdUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFnZVNpemUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VTaXplJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVNpemUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VTaXplJ10sIGZyb21QYWdlU2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VUb2tlbiddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVRva2VuJ10sIGZyb21QYWdlVG9rZW4pO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0RmlsZXNQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCBsaXN0RmlsZXNDb25maWdUb01sZGV2KGFwaUNsaWVudCwgZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZmlsZVN0YXR1c1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGV0YWlscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGV0YWlscyddKTtcbiAgICBpZiAoZnJvbURldGFpbHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXRhaWxzJ10sIGZyb21EZXRhaWxzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1lc3NhZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21lc3NhZ2UnXSk7XG4gICAgaWYgKGZyb21NZXNzYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWVzc2FnZSddLCBmcm9tTWVzc2FnZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb2RlJ10pO1xuICAgIGlmIChmcm9tQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGUnXSwgZnJvbUNvZGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmaWxlVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2l6ZUJ5dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzaXplQnl0ZXMnXSk7XG4gICAgaWYgKGZyb21TaXplQnl0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzaXplQnl0ZXMnXSwgZnJvbVNpemVCeXRlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DcmVhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjcmVhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tQ3JlYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSwgZnJvbUNyZWF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhwaXJhdGlvblRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdleHBpcmF0aW9uVGltZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FeHBpcmF0aW9uVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4cGlyYXRpb25UaW1lJ10sIGZyb21FeHBpcmF0aW9uVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcGRhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cGRhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tVXBkYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSwgZnJvbVVwZGF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2hhMjU2SGFzaCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2hhMjU2SGFzaCddKTtcbiAgICBpZiAoZnJvbVNoYTI1Nkhhc2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzaGEyNTZIYXNoJ10sIGZyb21TaGEyNTZIYXNoKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXJpJ10pO1xuICAgIGlmIChmcm9tVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJpJ10sIGZyb21VcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRG93bmxvYWRVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rvd25sb2FkVXJpJ10pO1xuICAgIGlmIChmcm9tRG93bmxvYWRVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkb3dubG9hZFVyaSddLCBmcm9tRG93bmxvYWRVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhdGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0YXRlJ10pO1xuICAgIGlmIChmcm9tU3RhdGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGF0ZSddLCBmcm9tU3RhdGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU291cmNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzb3VyY2UnXSk7XG4gICAgaWYgKGZyb21Tb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzb3VyY2UnXSwgZnJvbVNvdXJjZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WaWRlb01ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndmlkZW9NZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21WaWRlb01ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW9NZXRhZGF0YSddLCBmcm9tVmlkZW9NZXRhZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcnJvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXJyb3InXSk7XG4gICAgaWYgKGZyb21FcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vycm9yJ10sIGZpbGVTdGF0dXNUb01sZGV2KGFwaUNsaWVudCwgZnJvbUVycm9yKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpbGVQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GaWxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlJ10pO1xuICAgIGlmIChmcm9tRmlsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGUnXSwgZmlsZVRvTWxkZXYoYXBpQ2xpZW50LCBmcm9tRmlsZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgZnJvbUNvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdldEZpbGVQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnZmlsZSddLCB0RmlsZU5hbWUoYXBpQ2xpZW50LCBmcm9tTmFtZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgZnJvbUNvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUZpbGVQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnZmlsZSddLCB0RmlsZU5hbWUoYXBpQ2xpZW50LCBmcm9tTmFtZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgZnJvbUNvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZpbGVTdGF0dXNGcm9tTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGV0YWlscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGV0YWlscyddKTtcbiAgICBpZiAoZnJvbURldGFpbHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXRhaWxzJ10sIGZyb21EZXRhaWxzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1lc3NhZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21lc3NhZ2UnXSk7XG4gICAgaWYgKGZyb21NZXNzYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWVzc2FnZSddLCBmcm9tTWVzc2FnZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb2RlJ10pO1xuICAgIGlmIChmcm9tQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGUnXSwgZnJvbUNvZGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmaWxlRnJvbU1sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSk7XG4gICAgaWYgKGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10sIGZyb21EaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TaXplQnl0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NpemVCeXRlcyddKTtcbiAgICBpZiAoZnJvbVNpemVCeXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NpemVCeXRlcyddLCBmcm9tU2l6ZUJ5dGVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNyZWF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21DcmVhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY3JlYXRlVGltZSddLCBmcm9tQ3JlYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeHBpcmF0aW9uVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2V4cGlyYXRpb25UaW1lJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUV4cGlyYXRpb25UaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhwaXJhdGlvblRpbWUnXSwgZnJvbUV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVwZGF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21VcGRhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXBkYXRlVGltZSddLCBmcm9tVXBkYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TaGEyNTZIYXNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzaGEyNTZIYXNoJ10pO1xuICAgIGlmIChmcm9tU2hhMjU2SGFzaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NoYTI1Nkhhc2gnXSwgZnJvbVNoYTI1Nkhhc2gpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cmknXSk7XG4gICAgaWYgKGZyb21VcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cmknXSwgZnJvbVVyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Eb3dubG9hZFVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZG93bmxvYWRVcmknXSk7XG4gICAgaWYgKGZyb21Eb3dubG9hZFVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rvd25sb2FkVXJpJ10sIGZyb21Eb3dubG9hZFVyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdGF0ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhdGUnXSk7XG4gICAgaWYgKGZyb21TdGF0ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXRlJ10sIGZyb21TdGF0ZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Tb3VyY2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NvdXJjZSddKTtcbiAgICBpZiAoZnJvbVNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NvdXJjZSddLCBmcm9tU291cmNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd2aWRlb01ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVZpZGVvTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlb01ldGFkYXRhJ10sIGZyb21WaWRlb01ldGFkYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVycm9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcnJvciddKTtcbiAgICBpZiAoZnJvbUVycm9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXJyb3InXSwgZmlsZVN0YXR1c0Zyb21NbGRldihhcGlDbGllbnQsIGZyb21FcnJvcikpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0RmlsZXNSZXNwb25zZUZyb21NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OZXh0UGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmV4dFBhZ2VUb2tlbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21OZXh0UGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmV4dFBhZ2VUb2tlbiddLCBmcm9tTmV4dFBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZXMnXSk7XG4gICAgaWYgKGZyb21GaWxlcyAhPSBudWxsKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZyb21GaWxlcykpIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVzJ10sIGZyb21GaWxlcy5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZUZyb21NbGRldihhcGlDbGllbnQsIGl0ZW0pO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZXMnXSwgZnJvbUZpbGVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWxlUmVzcG9uc2VGcm9tTWxkZXYoKSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkZWxldGVGaWxlUmVzcG9uc2VGcm9tTWxkZXYoKSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNsYXNzIEZpbGVzIGV4dGVuZHMgQmFzZU1vZHVsZSB7XG4gICAgY29uc3RydWN0b3IoYXBpQ2xpZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdHMgYWxsIGN1cnJlbnQgcHJvamVjdCBmaWxlcyBmcm9tIHRoZSBzZXJ2aWNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBsaXN0IHJlcXVlc3RcbiAgICAgICAgICogQHJldHVybiBUaGUgcGFnaW5hdGVkIHJlc3VsdHMgb2YgdGhlIGxpc3Qgb2YgZmlsZXNcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogVGhlIGZvbGxvd2luZyBjb2RlIHByaW50cyB0aGUgbmFtZXMgb2YgYWxsIGZpbGVzIGZyb20gdGhlIHNlcnZpY2UsIHRoZVxuICAgICAgICAgKiBzaXplIG9mIGVhY2ggcGFnZSBpcyAxMC5cbiAgICAgICAgICpcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogY29uc3QgbGlzdFJlc3BvbnNlID0gYXdhaXQgYWkuZmlsZXMubGlzdCh7Y29uZmlnOiB7J3BhZ2VTaXplJzogMTB9fSk7XG4gICAgICAgICAqIGZvciBhd2FpdCAoY29uc3QgZmlsZSBvZiBsaXN0UmVzcG9uc2UpIHtcbiAgICAgICAgICogICBjb25zb2xlLmxvZyhmaWxlLm5hbWUpO1xuICAgICAgICAgKiB9XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saXN0ID0gYXN5bmMgKHBhcmFtcyA9IHt9KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhZ2VyKGV4cG9ydHMuUGFnZWRJdGVtLlBBR0VEX0lURU1fRklMRVMsICh4KSA9PiB0aGlzLmxpc3RJbnRlcm5hbCh4KSwgYXdhaXQgdGhpcy5saXN0SW50ZXJuYWwocGFyYW1zKSwgcGFyYW1zKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBsb2FkcyBhIGZpbGUgYXN5bmNocm9ub3VzbHkgdG8gdGhlIEdlbWluaSBBUEkuXG4gICAgICogVGhpcyBtZXRob2QgaXMgbm90IGF2YWlsYWJsZSBpbiBWZXJ0ZXggQUkuXG4gICAgICogU3VwcG9ydGVkIHVwbG9hZCBzb3VyY2VzOlxuICAgICAqIC0gTm9kZS5qczogRmlsZSBwYXRoIChzdHJpbmcpIG9yIEJsb2Igb2JqZWN0LlxuICAgICAqIC0gQnJvd3NlcjogQmxvYiBvYmplY3QgKGUuZy4sIEZpbGUpLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGUgYG1pbWVUeXBlYCBjYW4gYmUgc3BlY2lmaWVkIGluIHRoZSBgY29uZmlnYCBwYXJhbWV0ZXIuIElmIG9taXR0ZWQ6XG4gICAgICogIC0gRm9yIGZpbGUgcGF0aCAoc3RyaW5nKSBpbnB1dHMsIHRoZSBgbWltZVR5cGVgIHdpbGwgYmUgaW5mZXJyZWQgZnJvbSB0aGVcbiAgICAgKiAgICAgZmlsZSBleHRlbnNpb24uXG4gICAgICogIC0gRm9yIEJsb2Igb2JqZWN0IGlucHV0cywgdGhlIGBtaW1lVHlwZWAgd2lsbCBiZSBzZXQgdG8gdGhlIEJsb2IncyBgdHlwZWBcbiAgICAgKiAgICAgcHJvcGVydHkuXG4gICAgICogU29tZXggZWFtcGxlcyBmb3IgZmlsZSBleHRlbnNpb24gdG8gbWltZVR5cGUgbWFwcGluZzpcbiAgICAgKiAudHh0IC0+IHRleHQvcGxhaW5cbiAgICAgKiAuanNvbiAtPiBhcHBsaWNhdGlvbi9qc29uXG4gICAgICogLmpwZyAgLT4gaW1hZ2UvanBlZ1xuICAgICAqIC5wbmcgLT4gaW1hZ2UvcG5nXG4gICAgICogLm1wMyAtPiBhdWRpby9tcGVnXG4gICAgICogLm1wNCAtPiB2aWRlby9tcDRcbiAgICAgKlxuICAgICAqIFRoaXMgc2VjdGlvbiBjYW4gY29udGFpbiBtdWx0aXBsZSBwYXJhZ3JhcGhzIGFuZCBjb2RlIGV4YW1wbGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIE9wdGlvbmFsIHBhcmFtZXRlcnMgc3BlY2lmaWVkIGluIHRoZVxuICAgICAqICAgICAgICBgdHlwZXMuVXBsb2FkRmlsZVBhcmFtZXRlcnNgIGludGVyZmFjZS5cbiAgICAgKiAgICAgICAgIEBzZWUge0BsaW5rIHR5cGVzLlVwbG9hZEZpbGVQYXJhbWV0ZXJzI2NvbmZpZ30gZm9yIHRoZSBvcHRpb25hbFxuICAgICAqICAgICAgICAgY29uZmlnIGluIHRoZSBwYXJhbWV0ZXJzLlxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgdHlwZXMuRmlsZWAgb2JqZWN0LlxuICAgICAqIEB0aHJvd3MgQW4gZXJyb3IgaWYgY2FsbGVkIG9uIGEgVmVydGV4IEFJIGNsaWVudC5cbiAgICAgKiBAdGhyb3dzIEFuIGVycm9yIGlmIHRoZSBgbWltZVR5cGVgIGlzIG5vdCBwcm92aWRlZCBhbmQgY2FuIG5vdCBiZSBpbmZlcnJlZCxcbiAgICAgKiB0aGUgYG1pbWVUeXBlYCBjYW4gYmUgcHJvdmlkZWQgaW4gdGhlIGBwYXJhbXMuY29uZmlnYCBwYXJhbWV0ZXIuXG4gICAgICogQHRocm93cyBBbiBlcnJvciBvY2N1cnMgaWYgYSBzdWl0YWJsZSB1cGxvYWQgbG9jYXRpb24gY2Fubm90IGJlIGVzdGFibGlzaGVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBUaGUgZm9sbG93aW5nIGNvZGUgdXBsb2FkcyBhIGZpbGUgdG8gR2VtaW5pIEFQSS5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgZmlsZSA9IGF3YWl0IGFpLmZpbGVzLnVwbG9hZCh7ZmlsZTogJ2ZpbGUudHh0JywgY29uZmlnOiB7XG4gICAgICogICBtaW1lVHlwZTogJ3RleHQvcGxhaW4nLFxuICAgICAqIH19KTtcbiAgICAgKiBjb25zb2xlLmxvZyhmaWxlLm5hbWUpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIHVwbG9hZChwYXJhbXMpIHtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWZXJ0ZXggQUkgZG9lcyBub3Qgc3VwcG9ydCB1cGxvYWRpbmcgZmlsZXMuIFlvdSBjYW4gc2hhcmUgZmlsZXMgdGhyb3VnaCBhIEdDUyBidWNrZXQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAudXBsb2FkRmlsZShwYXJhbXMuZmlsZSwgcGFyYW1zLmNvbmZpZylcbiAgICAgICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZmlsZSA9IGZpbGVGcm9tTWxkZXYodGhpcy5hcGlDbGllbnQsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIHJldHVybiBmaWxlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgbGlzdEludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBHZW1pbmkgRGV2ZWxvcGVyIEFQSS4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBsaXN0RmlsZXNQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2ZpbGVzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnY29uZmlnJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGxpc3RGaWxlc1Jlc3BvbnNlRnJvbU1sZGV2KHRoaXMuYXBpQ2xpZW50LCBhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IExpc3RGaWxlc1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBjcmVhdGVJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgR2VtaW5pIERldmVsb3BlciBBUEkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY3JlYXRlRmlsZVBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgndXBsb2FkL3YxYmV0YS9maWxlcycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGNyZWF0ZUZpbGVSZXNwb25zZUZyb21NbGRldigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBDcmVhdGVGaWxlUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgZmlsZSBpbmZvcm1hdGlvbiBmcm9tIHRoZSBzZXJ2aWNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgZ2V0IHJlcXVlc3RcbiAgICAgKiBAcmV0dXJuIFRoZSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHR5cGVzLkZpbGUgb2JqZWN0IHJlcXVlc3RlZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBjb25maWc6IEdldEZpbGVQYXJhbWV0ZXJzID0ge1xuICAgICAqICAgbmFtZTogZmlsZU5hbWUsXG4gICAgICogfTtcbiAgICAgKiBmaWxlID0gYXdhaXQgYWkuZmlsZXMuZ2V0KGNvbmZpZyk7XG4gICAgICogY29uc29sZS5sb2coZmlsZS5uYW1lKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBnZXQocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIEdlbWluaSBEZXZlbG9wZXIgQVBJLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdldEZpbGVQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2ZpbGVzL3tmaWxlfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBmaWxlRnJvbU1sZGV2KHRoaXMuYXBpQ2xpZW50LCBhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGEgcmVtb3RlbHkgc3RvcmVkIGZpbGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBkZWxldGUgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIFRoZSBEZWxldGVGaWxlUmVzcG9uc2UsIHRoZSByZXNwb25zZSBmb3IgdGhlIGRlbGV0ZSBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIFRoZSBmb2xsb3dpbmcgY29kZSBkZWxldGVzIGFuIGV4YW1wbGUgZmlsZSBuYW1lZCBcImZpbGVzL21laG96cHhmODc3ZFwiLlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBhd2FpdCBhaS5maWxlcy5kZWxldGUoe25hbWU6IGZpbGUubmFtZX0pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgR2VtaW5pIERldmVsb3BlciBBUEkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZGVsZXRlRmlsZVBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnZmlsZXMve2ZpbGV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnY29uZmlnJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBkZWxldGVGaWxlUmVzcG9uc2VGcm9tTWxkZXYoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgRGVsZXRlRmlsZVJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuZnVuY3Rpb24gcGFydFRvTWxkZXYkMShhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZpZGVvTWV0YWRhdGEnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZpZGVvTWV0YWRhdGEgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rob3VnaHQnXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodCddLCBmcm9tVGhvdWdodCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvblJlc3VsdCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvblJlc3VsdCddLCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeGVjdXRhYmxlQ29kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2V4ZWN1dGFibGVDb2RlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUV4ZWN1dGFibGVDb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhlY3V0YWJsZUNvZGUnXSwgZnJvbUV4ZWN1dGFibGVDb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlRGF0YSddKTtcbiAgICBpZiAoZnJvbUZpbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZURhdGEnXSwgZnJvbUZpbGVEYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uQ2FsbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25DYWxsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10sIGZyb21GdW5jdGlvbkNhbGwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uUmVzcG9uc2UnXSwgZnJvbUZ1bmN0aW9uUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5saW5lRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW5saW5lRGF0YSddKTtcbiAgICBpZiAoZnJvbUlubGluZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbmxpbmVEYXRhJ10sIGZyb21JbmxpbmVEYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RleHQnXSk7XG4gICAgaWYgKGZyb21UZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGV4dCddLCBmcm9tVGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHBhcnRUb1ZlcnRleCQxKGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZpZGVvTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd2aWRlb01ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVZpZGVvTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlb01ldGFkYXRhJ10sIGZyb21WaWRlb01ldGFkYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rob3VnaHQnXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodCddLCBmcm9tVGhvdWdodCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvblJlc3VsdCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvblJlc3VsdCddLCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeGVjdXRhYmxlQ29kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2V4ZWN1dGFibGVDb2RlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUV4ZWN1dGFibGVDb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhlY3V0YWJsZUNvZGUnXSwgZnJvbUV4ZWN1dGFibGVDb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlRGF0YSddKTtcbiAgICBpZiAoZnJvbUZpbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZURhdGEnXSwgZnJvbUZpbGVEYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uQ2FsbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25DYWxsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10sIGZyb21GdW5jdGlvbkNhbGwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uUmVzcG9uc2UnXSwgZnJvbUZ1bmN0aW9uUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5saW5lRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW5saW5lRGF0YSddKTtcbiAgICBpZiAoZnJvbUlubGluZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbmxpbmVEYXRhJ10sIGZyb21JbmxpbmVEYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RleHQnXSk7XG4gICAgaWYgKGZyb21UZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGV4dCddLCBmcm9tVGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbnRlbnRUb01sZGV2JDEoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFydHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcnRzJ10pO1xuICAgIGlmIChmcm9tUGFydHMgIT0gbnVsbCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmcm9tUGFydHMpKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJ0cyddLCBmcm9tUGFydHMubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRUb01sZGV2JDEoYXBpQ2xpZW50LCBpdGVtKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcnRzJ10sIGZyb21QYXJ0cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZnJvbVJvbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JvbGUnXSk7XG4gICAgaWYgKGZyb21Sb2xlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncm9sZSddLCBmcm9tUm9sZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbnRlbnRUb1ZlcnRleCQxKGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhcnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJ0cyddKTtcbiAgICBpZiAoZnJvbVBhcnRzICE9IG51bGwpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZnJvbVBhcnRzKSkge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFydHMnXSwgZnJvbVBhcnRzLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0VG9WZXJ0ZXgkMShhcGlDbGllbnQsIGl0ZW0pO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFydHMnXSwgZnJvbVBhcnRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmcm9tUm9sZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncm9sZSddKTtcbiAgICBpZiAoZnJvbVJvbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyb2xlJ10sIGZyb21Sb2xlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc2NoZW1hVG9WZXJ0ZXgkMShhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21FeGFtcGxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleGFtcGxlJ10pO1xuICAgIGlmIChmcm9tRXhhbXBsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4YW1wbGUnXSwgZnJvbUV4YW1wbGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGF0dGVybiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGF0dGVybiddKTtcbiAgICBpZiAoZnJvbVBhdHRlcm4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXR0ZXJuJ10sIGZyb21QYXR0ZXJuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlZmF1bHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RlZmF1bHQnXSk7XG4gICAgaWYgKGZyb21EZWZhdWx0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVmYXVsdCddLCBmcm9tRGVmYXVsdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhMZW5ndGggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21heExlbmd0aCddKTtcbiAgICBpZiAoZnJvbU1heExlbmd0aCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21heExlbmd0aCddLCBmcm9tTWF4TGVuZ3RoKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbkxlbmd0aCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWluTGVuZ3RoJ10pO1xuICAgIGlmIChmcm9tTWluTGVuZ3RoICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWluTGVuZ3RoJ10sIGZyb21NaW5MZW5ndGgpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWluUHJvcGVydGllcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21pblByb3BlcnRpZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTWluUHJvcGVydGllcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pblByb3BlcnRpZXMnXSwgZnJvbU1pblByb3BlcnRpZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWF4UHJvcGVydGllcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21heFByb3BlcnRpZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTWF4UHJvcGVydGllcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21heFByb3BlcnRpZXMnXSwgZnJvbU1heFByb3BlcnRpZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQW55T2YgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FueU9mJ10pO1xuICAgIGlmIChmcm9tQW55T2YgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhbnlPZiddLCBmcm9tQW55T2YpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10pO1xuICAgIGlmIChmcm9tRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXNjcmlwdGlvbiddLCBmcm9tRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW51bSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW51bSddKTtcbiAgICBpZiAoZnJvbUVudW0gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbnVtJ10sIGZyb21FbnVtKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZvcm1hdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZm9ybWF0J10pO1xuICAgIGlmIChmcm9tRm9ybWF0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZm9ybWF0J10sIGZyb21Gb3JtYXQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSXRlbXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2l0ZW1zJ10pO1xuICAgIGlmIChmcm9tSXRlbXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpdGVtcyddLCBmcm9tSXRlbXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWF4SXRlbXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21heEl0ZW1zJ10pO1xuICAgIGlmIChmcm9tTWF4SXRlbXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtYXhJdGVtcyddLCBmcm9tTWF4SXRlbXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWF4aW11bSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWF4aW11bSddKTtcbiAgICBpZiAoZnJvbU1heGltdW0gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtYXhpbXVtJ10sIGZyb21NYXhpbXVtKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbkl0ZW1zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW5JdGVtcyddKTtcbiAgICBpZiAoZnJvbU1pbkl0ZW1zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWluSXRlbXMnXSwgZnJvbU1pbkl0ZW1zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbmltdW0gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbmltdW0nXSk7XG4gICAgaWYgKGZyb21NaW5pbXVtICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWluaW11bSddLCBmcm9tTWluaW11bSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OdWxsYWJsZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbnVsbGFibGUnXSk7XG4gICAgaWYgKGZyb21OdWxsYWJsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ251bGxhYmxlJ10sIGZyb21OdWxsYWJsZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9wZXJ0aWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9wZXJ0aWVzJ10pO1xuICAgIGlmIChmcm9tUHJvcGVydGllcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Byb3BlcnRpZXMnXSwgZnJvbVByb3BlcnRpZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvcGVydHlPcmRlcmluZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Byb3BlcnR5T3JkZXJpbmcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJvcGVydHlPcmRlcmluZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Byb3BlcnR5T3JkZXJpbmcnXSwgZnJvbVByb3BlcnR5T3JkZXJpbmcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVxdWlyZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JlcXVpcmVkJ10pO1xuICAgIGlmIChmcm9tUmVxdWlyZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXF1aXJlZCddLCBmcm9tUmVxdWlyZWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGl0bGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RpdGxlJ10pO1xuICAgIGlmIChmcm9tVGl0bGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aXRsZSddLCBmcm9tVGl0bGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndHlwZSddKTtcbiAgICBpZiAoZnJvbVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0eXBlJ10sIGZyb21UeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25EZWNsYXJhdGlvblRvTWxkZXYkMShhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3BvbnNlJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXNwb25zZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10pO1xuICAgIGlmIChmcm9tRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXNjcmlwdGlvbiddLCBmcm9tRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhcmFtZXRlcnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcmFtZXRlcnMnXSk7XG4gICAgaWYgKGZyb21QYXJhbWV0ZXJzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFyYW1ldGVycyddLCBmcm9tUGFyYW1ldGVycyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uRGVjbGFyYXRpb25Ub1ZlcnRleCQxKGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNwb25zZSddKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2UnXSwgc2NoZW1hVG9WZXJ0ZXgkMShhcGlDbGllbnQsIGZyb21SZXNwb25zZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10pO1xuICAgIGlmIChmcm9tRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXNjcmlwdGlvbiddLCBmcm9tRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhcmFtZXRlcnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcmFtZXRlcnMnXSk7XG4gICAgaWYgKGZyb21QYXJhbWV0ZXJzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFyYW1ldGVycyddLCBmcm9tUGFyYW1ldGVycyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZVNlYXJjaFRvTWxkZXYkMSgpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZVNlYXJjaFRvVmVydGV4JDEoKSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkeW5hbWljUmV0cmlldmFsQ29uZmlnVG9NbGRldiQxKGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGUnXSk7XG4gICAgaWYgKGZyb21Nb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZSddLCBmcm9tTW9kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EeW5hbWljVGhyZXNob2xkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZHluYW1pY1RocmVzaG9sZCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21EeW5hbWljVGhyZXNob2xkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZHluYW1pY1RocmVzaG9sZCddLCBmcm9tRHluYW1pY1RocmVzaG9sZCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGR5bmFtaWNSZXRyaWV2YWxDb25maWdUb1ZlcnRleCQxKGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGUnXSk7XG4gICAgaWYgKGZyb21Nb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZSddLCBmcm9tTW9kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EeW5hbWljVGhyZXNob2xkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZHluYW1pY1RocmVzaG9sZCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21EeW5hbWljVGhyZXNob2xkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZHluYW1pY1RocmVzaG9sZCddLCBmcm9tRHluYW1pY1RocmVzaG9sZCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZVNlYXJjaFJldHJpZXZhbFRvTWxkZXYkMShhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EeW5hbWljUmV0cmlldmFsQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZHluYW1pY1JldHJpZXZhbENvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21EeW5hbWljUmV0cmlldmFsQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZHluYW1pY1JldHJpZXZhbENvbmZpZyddLCBkeW5hbWljUmV0cmlldmFsQ29uZmlnVG9NbGRldiQxKGFwaUNsaWVudCwgZnJvbUR5bmFtaWNSZXRyaWV2YWxDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ29vZ2xlU2VhcmNoUmV0cmlldmFsVG9WZXJ0ZXgkMShhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EeW5hbWljUmV0cmlldmFsQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZHluYW1pY1JldHJpZXZhbENvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21EeW5hbWljUmV0cmlldmFsQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZHluYW1pY1JldHJpZXZhbENvbmZpZyddLCBkeW5hbWljUmV0cmlldmFsQ29uZmlnVG9WZXJ0ZXgkMShhcGlDbGllbnQsIGZyb21EeW5hbWljUmV0cmlldmFsQ29uZmlnKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRvb2xUb01sZGV2JDEoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvbkRlY2xhcmF0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucykpIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJ10sIGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucy5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb25EZWNsYXJhdGlvblRvTWxkZXYkMShhcGlDbGllbnQsIGl0ZW0pO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25EZWNsYXJhdGlvbnMnXSwgZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXRyaWV2YWwnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JldHJpZXZhbCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVTZWFyY2gnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2gnXSwgZ29vZ2xlU2VhcmNoVG9NbGRldiQxKCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ29vZ2xlU2VhcmNoUmV0cmlldmFsJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCddLCBnb29nbGVTZWFyY2hSZXRyaWV2YWxUb01sZGV2JDEoYXBpQ2xpZW50LCBmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvbiddLCBmcm9tQ29kZUV4ZWN1dGlvbik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRvb2xUb1ZlcnRleCQxKGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25EZWNsYXJhdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMpKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkRlY2xhcmF0aW9ucyddLCBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uRGVjbGFyYXRpb25Ub1ZlcnRleCQxKGFwaUNsaWVudCwgaXRlbSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkRlY2xhcmF0aW9ucyddLCBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXRyaWV2YWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JldHJpZXZhbCddKTtcbiAgICBpZiAoZnJvbVJldHJpZXZhbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JldHJpZXZhbCddLCBmcm9tUmV0cmlldmFsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ29vZ2xlU2VhcmNoJ10pO1xuICAgIGlmIChmcm9tR29vZ2xlU2VhcmNoICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlU2VhcmNoJ10sIGdvb2dsZVNlYXJjaFRvVmVydGV4JDEoKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnb29nbGVTZWFyY2hSZXRyaWV2YWwnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlU2VhcmNoUmV0cmlldmFsJ10sIGdvb2dsZVNlYXJjaFJldHJpZXZhbFRvVmVydGV4JDEoYXBpQ2xpZW50LCBmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvbiddLCBmcm9tQ29kZUV4ZWN1dGlvbik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNlc3Npb25SZXN1bXB0aW9uQ29uZmlnVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21IYW5kbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2hhbmRsZSddKTtcbiAgICBpZiAoZnJvbUhhbmRsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2hhbmRsZSddLCBmcm9tSGFuZGxlKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndHJhbnNwYXJlbnQnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyYW5zcGFyZW50IHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNlc3Npb25SZXN1bXB0aW9uQ29uZmlnVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSGFuZGxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydoYW5kbGUnXSk7XG4gICAgaWYgKGZyb21IYW5kbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydoYW5kbGUnXSwgZnJvbUhhbmRsZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UcmFuc3BhcmVudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndHJhbnNwYXJlbnQnXSk7XG4gICAgaWYgKGZyb21UcmFuc3BhcmVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RyYW5zcGFyZW50J10sIGZyb21UcmFuc3BhcmVudCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGF1ZGlvVHJhbnNjcmlwdGlvbkNvbmZpZ1RvTWxkZXYoKSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBhdWRpb1RyYW5zY3JpcHRpb25Db25maWdUb1ZlcnRleCgpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGF1dG9tYXRpY0FjdGl2aXR5RGV0ZWN0aW9uVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EaXNhYmxlZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzYWJsZWQnXSk7XG4gICAgaWYgKGZyb21EaXNhYmxlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rpc2FibGVkJ10sIGZyb21EaXNhYmxlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdGFydE9mU3BlZWNoU2Vuc2l0aXZpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzdGFydE9mU3BlZWNoU2Vuc2l0aXZpdHknLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU3RhcnRPZlNwZWVjaFNlbnNpdGl2aXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhcnRPZlNwZWVjaFNlbnNpdGl2aXR5J10sIGZyb21TdGFydE9mU3BlZWNoU2Vuc2l0aXZpdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kT2ZTcGVlY2hTZW5zaXRpdml0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2VuZE9mU3BlZWNoU2Vuc2l0aXZpdHknLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRW5kT2ZTcGVlY2hTZW5zaXRpdml0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZE9mU3BlZWNoU2Vuc2l0aXZpdHknXSwgZnJvbUVuZE9mU3BlZWNoU2Vuc2l0aXZpdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJlZml4UGFkZGluZ01zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlZml4UGFkZGluZ01zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByZWZpeFBhZGRpbmdNcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ByZWZpeFBhZGRpbmdNcyddLCBmcm9tUHJlZml4UGFkZGluZ01zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNpbGVuY2VEdXJhdGlvbk1zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2lsZW5jZUR1cmF0aW9uTXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2lsZW5jZUR1cmF0aW9uTXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzaWxlbmNlRHVyYXRpb25NcyddLCBmcm9tU2lsZW5jZUR1cmF0aW9uTXMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBhdXRvbWF0aWNBY3Rpdml0eURldGVjdGlvblRvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURpc2FibGVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNhYmxlZCddKTtcbiAgICBpZiAoZnJvbURpc2FibGVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGlzYWJsZWQnXSwgZnJvbURpc2FibGVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXJ0T2ZTcGVlY2hTZW5zaXRpdml0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N0YXJ0T2ZTcGVlY2hTZW5zaXRpdml0eScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TdGFydE9mU3BlZWNoU2Vuc2l0aXZpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGFydE9mU3BlZWNoU2Vuc2l0aXZpdHknXSwgZnJvbVN0YXJ0T2ZTcGVlY2hTZW5zaXRpdml0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmRPZlNwZWVjaFNlbnNpdGl2aXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZW5kT2ZTcGVlY2hTZW5zaXRpdml0eScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FbmRPZlNwZWVjaFNlbnNpdGl2aXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5kT2ZTcGVlY2hTZW5zaXRpdml0eSddLCBmcm9tRW5kT2ZTcGVlY2hTZW5zaXRpdml0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QcmVmaXhQYWRkaW5nTXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVmaXhQYWRkaW5nTXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJlZml4UGFkZGluZ01zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJlZml4UGFkZGluZ01zJ10sIGZyb21QcmVmaXhQYWRkaW5nTXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2lsZW5jZUR1cmF0aW9uTXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzaWxlbmNlRHVyYXRpb25NcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TaWxlbmNlRHVyYXRpb25NcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NpbGVuY2VEdXJhdGlvbk1zJ10sIGZyb21TaWxlbmNlRHVyYXRpb25Ncyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHJlYWx0aW1lSW5wdXRDb25maWdUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUF1dG9tYXRpY0FjdGl2aXR5RGV0ZWN0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYXV0b21hdGljQWN0aXZpdHlEZXRlY3Rpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQXV0b21hdGljQWN0aXZpdHlEZXRlY3Rpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhdXRvbWF0aWNBY3Rpdml0eURldGVjdGlvbiddLCBhdXRvbWF0aWNBY3Rpdml0eURldGVjdGlvblRvTWxkZXYoYXBpQ2xpZW50LCBmcm9tQXV0b21hdGljQWN0aXZpdHlEZXRlY3Rpb24pKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFjdGl2aXR5SGFuZGxpbmcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdhY3Rpdml0eUhhbmRsaW5nJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUFjdGl2aXR5SGFuZGxpbmcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhY3Rpdml0eUhhbmRsaW5nJ10sIGZyb21BY3Rpdml0eUhhbmRsaW5nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVR1cm5Db3ZlcmFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndHVybkNvdmVyYWdlJ10pO1xuICAgIGlmIChmcm9tVHVybkNvdmVyYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHVybkNvdmVyYWdlJ10sIGZyb21UdXJuQ292ZXJhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiByZWFsdGltZUlucHV0Q29uZmlnVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQXV0b21hdGljQWN0aXZpdHlEZXRlY3Rpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdhdXRvbWF0aWNBY3Rpdml0eURldGVjdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21BdXRvbWF0aWNBY3Rpdml0eURldGVjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2F1dG9tYXRpY0FjdGl2aXR5RGV0ZWN0aW9uJ10sIGF1dG9tYXRpY0FjdGl2aXR5RGV0ZWN0aW9uVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tQXV0b21hdGljQWN0aXZpdHlEZXRlY3Rpb24pKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFjdGl2aXR5SGFuZGxpbmcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdhY3Rpdml0eUhhbmRsaW5nJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUFjdGl2aXR5SGFuZGxpbmcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhY3Rpdml0eUhhbmRsaW5nJ10sIGZyb21BY3Rpdml0eUhhbmRsaW5nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVR1cm5Db3ZlcmFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndHVybkNvdmVyYWdlJ10pO1xuICAgIGlmIChmcm9tVHVybkNvdmVyYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHVybkNvdmVyYWdlJ10sIGZyb21UdXJuQ292ZXJhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzbGlkaW5nV2luZG93VG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UYXJnZXRUb2tlbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RhcmdldFRva2VucyddKTtcbiAgICBpZiAoZnJvbVRhcmdldFRva2VucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RhcmdldFRva2VucyddLCBmcm9tVGFyZ2V0VG9rZW5zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc2xpZGluZ1dpbmRvd1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVRhcmdldFRva2VucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGFyZ2V0VG9rZW5zJ10pO1xuICAgIGlmIChmcm9tVGFyZ2V0VG9rZW5zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGFyZ2V0VG9rZW5zJ10sIGZyb21UYXJnZXRUb2tlbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb250ZXh0V2luZG93Q29tcHJlc3Npb25Db25maWdUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVRyaWdnZXJUb2tlbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0cmlnZ2VyVG9rZW5zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRyaWdnZXJUb2tlbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0cmlnZ2VyVG9rZW5zJ10sIGZyb21UcmlnZ2VyVG9rZW5zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNsaWRpbmdXaW5kb3cgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzbGlkaW5nV2luZG93JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNsaWRpbmdXaW5kb3cgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzbGlkaW5nV2luZG93J10sIHNsaWRpbmdXaW5kb3dUb01sZGV2KGFwaUNsaWVudCwgZnJvbVNsaWRpbmdXaW5kb3cpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udGV4dFdpbmRvd0NvbXByZXNzaW9uQ29uZmlnVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVHJpZ2dlclRva2VucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RyaWdnZXJUb2tlbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVHJpZ2dlclRva2VucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RyaWdnZXJUb2tlbnMnXSwgZnJvbVRyaWdnZXJUb2tlbnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2xpZGluZ1dpbmRvdyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NsaWRpbmdXaW5kb3cnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2xpZGluZ1dpbmRvdyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NsaWRpbmdXaW5kb3cnXSwgc2xpZGluZ1dpbmRvd1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbVNsaWRpbmdXaW5kb3cpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZUNvbm5lY3RDb25maWdUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2VuZXJhdGlvbkNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dlbmVyYXRpb25Db25maWcnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tR2VuZXJhdGlvbkNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJ10sIGZyb21HZW5lcmF0aW9uQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTW9kYWxpdGllcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21SZXNwb25zZU1vZGFsaXRpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdyZXNwb25zZU1vZGFsaXRpZXMnXSwgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZW1wZXJhdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGVtcGVyYXR1cmUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UZW1wZXJhdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3RlbXBlcmF0dXJlJ10sIGZyb21UZW1wZXJhdHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BQID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BQJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9wUCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3RvcFAnXSwgZnJvbVRvcFApO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wSyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wSyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvcEsgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICd0b3BLJ10sIGZyb21Ub3BLKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heE91dHB1dFRva2VucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21heE91dHB1dFRva2VucycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21NYXhPdXRwdXRUb2tlbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdtYXhPdXRwdXRUb2tlbnMnXSwgZnJvbU1heE91dHB1dFRva2Vucyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZWRpYVJlc29sdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtZWRpYVJlc29sdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTWVkaWFSZXNvbHV0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnbWVkaWFSZXNvbHV0aW9uJ10sIGZyb21NZWRpYVJlc29sdXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VlZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2VlZCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNlZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdzZWVkJ10sIGZyb21TZWVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNwZWVjaENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3BlZWNoQ29uZmlnJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU3BlZWNoQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnc3BlZWNoQ29uZmlnJ10sIGZyb21TcGVlY2hDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzeXN0ZW1JbnN0cnVjdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TeXN0ZW1JbnN0cnVjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdzeXN0ZW1JbnN0cnVjdGlvbiddLCBjb250ZW50VG9NbGRldiQxKGFwaUNsaWVudCwgdENvbnRlbnQoYXBpQ2xpZW50LCBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24pKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29scyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub29scyAhPSBudWxsKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZyb21Ub29scykpIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICd0b29scyddLCB0VG9vbHMoYXBpQ2xpZW50LCB0VG9vbHMoYXBpQ2xpZW50LCBmcm9tVG9vbHMpLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b29sVG9NbGRldiQxKGFwaUNsaWVudCwgdFRvb2woYXBpQ2xpZW50LCBpdGVtKSk7XG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3Rvb2xzJ10sIHRUb29scyhhcGlDbGllbnQsIGZyb21Ub29scykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZXNzaW9uUmVzdW1wdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nlc3Npb25SZXN1bXB0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNlc3Npb25SZXN1bXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3Nlc3Npb25SZXN1bXB0aW9uJ10sIHNlc3Npb25SZXN1bXB0aW9uQ29uZmlnVG9NbGRldihhcGlDbGllbnQsIGZyb21TZXNzaW9uUmVzdW1wdGlvbikpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbiddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW5wdXRBdWRpb1RyYW5zY3JpcHRpb24gcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnb3V0cHV0QXVkaW9UcmFuc2NyaXB0aW9uJ10sIGF1ZGlvVHJhbnNjcmlwdGlvbkNvbmZpZ1RvTWxkZXYoKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZWFsdGltZUlucHV0Q29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVhbHRpbWVJbnB1dENvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21SZWFsdGltZUlucHV0Q29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3JlYWx0aW1lSW5wdXRDb25maWcnXSwgcmVhbHRpbWVJbnB1dENvbmZpZ1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tUmVhbHRpbWVJbnB1dENvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGV4dFdpbmRvd0NvbXByZXNzaW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29udGV4dFdpbmRvd0NvbXByZXNzaW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUNvbnRleHRXaW5kb3dDb21wcmVzc2lvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdjb250ZXh0V2luZG93Q29tcHJlc3Npb24nXSwgY29udGV4dFdpbmRvd0NvbXByZXNzaW9uQ29uZmlnVG9NbGRldihhcGlDbGllbnQsIGZyb21Db250ZXh0V2luZG93Q29tcHJlc3Npb24pKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZUNvbm5lY3RDb25maWdUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUdlbmVyYXRpb25Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnZW5lcmF0aW9uQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUdlbmVyYXRpb25Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZyddLCBmcm9tR2VuZXJhdGlvbkNvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZU1vZGFsaXRpZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZU1vZGFsaXRpZXMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAncmVzcG9uc2VNb2RhbGl0aWVzJ10sIGZyb21SZXNwb25zZU1vZGFsaXRpZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGVtcGVyYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RlbXBlcmF0dXJlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVGVtcGVyYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICd0ZW1wZXJhdHVyZSddLCBmcm9tVGVtcGVyYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wUCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wUCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvcFAgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICd0b3BQJ10sIGZyb21Ub3BQKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcEsgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcEsnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub3BLICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAndG9wSyddLCBmcm9tVG9wSyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhPdXRwdXRUb2tlbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtYXhPdXRwdXRUb2tlbnMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTWF4T3V0cHV0VG9rZW5zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnbWF4T3V0cHV0VG9rZW5zJ10sIGZyb21NYXhPdXRwdXRUb2tlbnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWVkaWFSZXNvbHV0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWVkaWFSZXNvbHV0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU1lZGlhUmVzb2x1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ21lZGlhUmVzb2x1dGlvbiddLCBmcm9tTWVkaWFSZXNvbHV0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TZWVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnc2VlZCddLCBmcm9tU2VlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TcGVlY2hDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NwZWVjaENvbmZpZyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNwZWVjaENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3NwZWVjaENvbmZpZyddLCBmcm9tU3BlZWNoQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN5c3RlbUluc3RydWN0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3lzdGVtSW5zdHJ1Y3Rpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnc3lzdGVtSW5zdHJ1Y3Rpb24nXSwgY29udGVudFRvVmVydGV4JDEoYXBpQ2xpZW50LCB0Q29udGVudChhcGlDbGllbnQsIGZyb21TeXN0ZW1JbnN0cnVjdGlvbikpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29scyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xzICE9IG51bGwpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZnJvbVRvb2xzKSkge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3Rvb2xzJ10sIHRUb29scyhhcGlDbGllbnQsIHRUb29scyhhcGlDbGllbnQsIGZyb21Ub29scykubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvb2xUb1ZlcnRleCQxKGFwaUNsaWVudCwgdFRvb2woYXBpQ2xpZW50LCBpdGVtKSk7XG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3Rvb2xzJ10sIHRUb29scyhhcGlDbGllbnQsIGZyb21Ub29scykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZXNzaW9uUmVzdW1wdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nlc3Npb25SZXN1bXB0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNlc3Npb25SZXN1bXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3Nlc3Npb25SZXN1bXB0aW9uJ10sIHNlc3Npb25SZXN1bXB0aW9uQ29uZmlnVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tU2Vzc2lvblJlc3VtcHRpb24pKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlucHV0QXVkaW9UcmFuc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5wdXRBdWRpb1RyYW5zY3JpcHRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW5wdXRBdWRpb1RyYW5zY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnaW5wdXRBdWRpb1RyYW5zY3JpcHRpb24nXSwgYXVkaW9UcmFuc2NyaXB0aW9uQ29uZmlnVG9WZXJ0ZXgoKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0QXVkaW9UcmFuc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ291dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbiddLCBhdWRpb1RyYW5zY3JpcHRpb25Db25maWdUb1ZlcnRleCgpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlYWx0aW1lSW5wdXRDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZWFsdGltZUlucHV0Q29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVJlYWx0aW1lSW5wdXRDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAncmVhbHRpbWVJbnB1dENvbmZpZyddLCByZWFsdGltZUlucHV0Q29uZmlnVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tUmVhbHRpbWVJbnB1dENvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGV4dFdpbmRvd0NvbXByZXNzaW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29udGV4dFdpbmRvd0NvbXByZXNzaW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUNvbnRleHRXaW5kb3dDb21wcmVzc2lvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdjb250ZXh0V2luZG93Q29tcHJlc3Npb24nXSwgY29udGV4dFdpbmRvd0NvbXByZXNzaW9uQ29uZmlnVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tQ29udGV4dFdpbmRvd0NvbXByZXNzaW9uKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVDb25uZWN0UGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZXR1cCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGxpdmVDb25uZWN0Q29uZmlnVG9NbGRldihhcGlDbGllbnQsIGZyb21Db25maWcsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVDb25uZWN0UGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2V0dXAnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCBsaXZlQ29ubmVjdENvbmZpZ1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYWN0aXZpdHlTdGFydFRvTWxkZXYoKSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBhY3Rpdml0eVN0YXJ0VG9WZXJ0ZXgoKSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBhY3Rpdml0eUVuZFRvTWxkZXYoKSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBhY3Rpdml0eUVuZFRvVmVydGV4KCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZVNlbmRSZWFsdGltZUlucHV0UGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTWVkaWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21lZGlhJ10pO1xuICAgIGlmIChmcm9tTWVkaWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZWRpYUNodW5rcyddLCB0QmxvYnMoYXBpQ2xpZW50LCBmcm9tTWVkaWEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUF1ZGlvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdWRpbyddKTtcbiAgICBpZiAoZnJvbUF1ZGlvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXVkaW8nXSwgdEF1ZGlvQmxvYihhcGlDbGllbnQsIGZyb21BdWRpbykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXVkaW9TdHJlYW1FbmQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdhdWRpb1N0cmVhbUVuZCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21BdWRpb1N0cmVhbUVuZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2F1ZGlvU3RyZWFtRW5kJ10sIGZyb21BdWRpb1N0cmVhbUVuZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WaWRlbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmlkZW8nXSk7XG4gICAgaWYgKGZyb21WaWRlbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvJ10sIHRJbWFnZUJsb2IoYXBpQ2xpZW50LCBmcm9tVmlkZW8pKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RleHQnXSk7XG4gICAgaWYgKGZyb21UZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGV4dCddLCBmcm9tVGV4dCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BY3Rpdml0eVN0YXJ0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYWN0aXZpdHlTdGFydCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21BY3Rpdml0eVN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYWN0aXZpdHlTdGFydCddLCBhY3Rpdml0eVN0YXJ0VG9NbGRldigpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFjdGl2aXR5RW5kID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhY3Rpdml0eUVuZCddKTtcbiAgICBpZiAoZnJvbUFjdGl2aXR5RW5kICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYWN0aXZpdHlFbmQnXSwgYWN0aXZpdHlFbmRUb01sZGV2KCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlU2VuZFJlYWx0aW1lSW5wdXRQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTWVkaWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21lZGlhJ10pO1xuICAgIGlmIChmcm9tTWVkaWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZWRpYUNodW5rcyddLCB0QmxvYnMoYXBpQ2xpZW50LCBmcm9tTWVkaWEpKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXVkaW8nXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F1ZGlvIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUF1ZGlvU3RyZWFtRW5kID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYXVkaW9TdHJlYW1FbmQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQXVkaW9TdHJlYW1FbmQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhdWRpb1N0cmVhbUVuZCddLCBmcm9tQXVkaW9TdHJlYW1FbmQpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2aWRlbyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndmlkZW8gcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZXh0J10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0ZXh0IHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFjdGl2aXR5U3RhcnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdhY3Rpdml0eVN0YXJ0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUFjdGl2aXR5U3RhcnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhY3Rpdml0eVN0YXJ0J10sIGFjdGl2aXR5U3RhcnRUb1ZlcnRleCgpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFjdGl2aXR5RW5kID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhY3Rpdml0eUVuZCddKTtcbiAgICBpZiAoZnJvbUFjdGl2aXR5RW5kICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYWN0aXZpdHlFbmQnXSwgYWN0aXZpdHlFbmRUb1ZlcnRleCgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZVNlcnZlclNldHVwQ29tcGxldGVGcm9tTWxkZXYoKSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlU2VydmVyU2V0dXBDb21wbGV0ZUZyb21WZXJ0ZXgoKSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBwYXJ0RnJvbU1sZGV2JDEoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVGhvdWdodCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGhvdWdodCddKTtcbiAgICBpZiAoZnJvbVRob3VnaHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0J10sIGZyb21UaG91Z2h0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uUmVzdWx0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uUmVzdWx0J10sIGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4ZWN1dGFibGVDb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZXhlY3V0YWJsZUNvZGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRXhlY3V0YWJsZUNvZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleGVjdXRhYmxlQ29kZSddLCBmcm9tRXhlY3V0YWJsZUNvZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVEYXRhJ10pO1xuICAgIGlmIChmcm9tRmlsZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlRGF0YSddLCBmcm9tRmlsZURhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25DYWxsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmdW5jdGlvbkNhbGwnXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkNhbGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkNhbGwnXSwgZnJvbUZ1bmN0aW9uQ2FsbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvblJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25SZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvblJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25SZXNwb25zZSddLCBmcm9tRnVuY3Rpb25SZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmxpbmVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmxpbmVEYXRhJ10pO1xuICAgIGlmIChmcm9tSW5saW5lRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lubGluZURhdGEnXSwgZnJvbUlubGluZURhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGV4dCddKTtcbiAgICBpZiAoZnJvbVRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZXh0J10sIGZyb21UZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcGFydEZyb21WZXJ0ZXgkMShhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21WaWRlb01ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndmlkZW9NZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21WaWRlb01ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW9NZXRhZGF0YSddLCBmcm9tVmlkZW9NZXRhZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aG91Z2h0J10pO1xuICAgIGlmIChmcm9tVGhvdWdodCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHQnXSwgZnJvbVRob3VnaHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb25SZXN1bHQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb25SZXN1bHQnXSwgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhlY3V0YWJsZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdleGVjdXRhYmxlQ29kZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FeGVjdXRhYmxlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4ZWN1dGFibGVDb2RlJ10sIGZyb21FeGVjdXRhYmxlQ29kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZURhdGEnXSk7XG4gICAgaWYgKGZyb21GaWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVEYXRhJ10sIGZyb21GaWxlRGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvbkNhbGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uQ2FsbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddLCBmcm9tRnVuY3Rpb25DYWxsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvblJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvblJlc3BvbnNlJ10sIGZyb21GdW5jdGlvblJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlubGluZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lubGluZURhdGEnXSk7XG4gICAgaWYgKGZyb21JbmxpbmVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5saW5lRGF0YSddLCBmcm9tSW5saW5lRGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZXh0J10pO1xuICAgIGlmIChmcm9tVGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RleHQnXSwgZnJvbVRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb250ZW50RnJvbU1sZGV2JDEoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFydHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcnRzJ10pO1xuICAgIGlmIChmcm9tUGFydHMgIT0gbnVsbCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmcm9tUGFydHMpKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJ0cyddLCBmcm9tUGFydHMubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRGcm9tTWxkZXYkMShhcGlDbGllbnQsIGl0ZW0pO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFydHMnXSwgZnJvbVBhcnRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmcm9tUm9sZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncm9sZSddKTtcbiAgICBpZiAoZnJvbVJvbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyb2xlJ10sIGZyb21Sb2xlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udGVudEZyb21WZXJ0ZXgkMShhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYXJ0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFydHMnXSk7XG4gICAgaWYgKGZyb21QYXJ0cyAhPSBudWxsKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZyb21QYXJ0cykpIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcnRzJ10sIGZyb21QYXJ0cy5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydEZyb21WZXJ0ZXgkMShhcGlDbGllbnQsIGl0ZW0pO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFydHMnXSwgZnJvbVBhcnRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmcm9tUm9sZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncm9sZSddKTtcbiAgICBpZiAoZnJvbVJvbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyb2xlJ10sIGZyb21Sb2xlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdHJhbnNjcmlwdGlvbkZyb21NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZXh0J10pO1xuICAgIGlmIChmcm9tVGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RleHQnXSwgZnJvbVRleHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmluaXNoZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbmlzaGVkJ10pO1xuICAgIGlmIChmcm9tRmluaXNoZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaW5pc2hlZCddLCBmcm9tRmluaXNoZWQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0cmFuc2NyaXB0aW9uRnJvbVZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZXh0J10pO1xuICAgIGlmIChmcm9tVGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RleHQnXSwgZnJvbVRleHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmluaXNoZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbmlzaGVkJ10pO1xuICAgIGlmIChmcm9tRmluaXNoZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaW5pc2hlZCddLCBmcm9tRmluaXNoZWQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlU2VydmVyQ29udGVudEZyb21NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbFR1cm4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsVHVybiddKTtcbiAgICBpZiAoZnJvbU1vZGVsVHVybiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGVsVHVybiddLCBjb250ZW50RnJvbU1sZGV2JDEoYXBpQ2xpZW50LCBmcm9tTW9kZWxUdXJuKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdXJuQ29tcGxldGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3R1cm5Db21wbGV0ZSddKTtcbiAgICBpZiAoZnJvbVR1cm5Db21wbGV0ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3R1cm5Db21wbGV0ZSddLCBmcm9tVHVybkNvbXBsZXRlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUludGVycnVwdGVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbnRlcnJ1cHRlZCddKTtcbiAgICBpZiAoZnJvbUludGVycnVwdGVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW50ZXJydXB0ZWQnXSwgZnJvbUludGVycnVwdGVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdlbmVyYXRpb25Db21wbGV0ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dlbmVyYXRpb25Db21wbGV0ZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21HZW5lcmF0aW9uQ29tcGxldGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnZW5lcmF0aW9uQ29tcGxldGUnXSwgZnJvbUdlbmVyYXRpb25Db21wbGV0ZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbnB1dFRyYW5zY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbnB1dFRyYW5zY3JpcHRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tSW5wdXRUcmFuc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5wdXRUcmFuc2NyaXB0aW9uJ10sIHRyYW5zY3JpcHRpb25Gcm9tTWxkZXYoYXBpQ2xpZW50LCBmcm9tSW5wdXRUcmFuc2NyaXB0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRUcmFuc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0VHJhbnNjcmlwdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21PdXRwdXRUcmFuc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnb3V0cHV0VHJhbnNjcmlwdGlvbiddLCB0cmFuc2NyaXB0aW9uRnJvbU1sZGV2KGFwaUNsaWVudCwgZnJvbU91dHB1dFRyYW5zY3JpcHRpb24pKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZVNlcnZlckNvbnRlbnRGcm9tVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsVHVybiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWxUdXJuJ10pO1xuICAgIGlmIChmcm9tTW9kZWxUdXJuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWxUdXJuJ10sIGNvbnRlbnRGcm9tVmVydGV4JDEoYXBpQ2xpZW50LCBmcm9tTW9kZWxUdXJuKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdXJuQ29tcGxldGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3R1cm5Db21wbGV0ZSddKTtcbiAgICBpZiAoZnJvbVR1cm5Db21wbGV0ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3R1cm5Db21wbGV0ZSddLCBmcm9tVHVybkNvbXBsZXRlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUludGVycnVwdGVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbnRlcnJ1cHRlZCddKTtcbiAgICBpZiAoZnJvbUludGVycnVwdGVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW50ZXJydXB0ZWQnXSwgZnJvbUludGVycnVwdGVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdlbmVyYXRpb25Db21wbGV0ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dlbmVyYXRpb25Db21wbGV0ZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21HZW5lcmF0aW9uQ29tcGxldGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnZW5lcmF0aW9uQ29tcGxldGUnXSwgZnJvbUdlbmVyYXRpb25Db21wbGV0ZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbnB1dFRyYW5zY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbnB1dFRyYW5zY3JpcHRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tSW5wdXRUcmFuc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5wdXRUcmFuc2NyaXB0aW9uJ10sIHRyYW5zY3JpcHRpb25Gcm9tVmVydGV4KGFwaUNsaWVudCwgZnJvbUlucHV0VHJhbnNjcmlwdGlvbikpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0VHJhbnNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dFRyYW5zY3JpcHRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tT3V0cHV0VHJhbnNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ291dHB1dFRyYW5zY3JpcHRpb24nXSwgdHJhbnNjcmlwdGlvbkZyb21WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT3V0cHV0VHJhbnNjcmlwdGlvbikpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkNhbGxGcm9tTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lkJ10pO1xuICAgIGlmIChmcm9tSWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpZCddLCBmcm9tSWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXJncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXJncyddKTtcbiAgICBpZiAoZnJvbUFyZ3MgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhcmdzJ10sIGZyb21BcmdzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbEZyb21WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQXJncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXJncyddKTtcbiAgICBpZiAoZnJvbUFyZ3MgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhcmdzJ10sIGZyb21BcmdzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVTZXJ2ZXJUb29sQ2FsbEZyb21NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GdW5jdGlvbkNhbGxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25DYWxscycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkNhbGxzICE9IG51bGwpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZnJvbUZ1bmN0aW9uQ2FsbHMpKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkNhbGxzJ10sIGZyb21GdW5jdGlvbkNhbGxzLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbkNhbGxGcm9tTWxkZXYoYXBpQ2xpZW50LCBpdGVtKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbHMnXSwgZnJvbUZ1bmN0aW9uQ2FsbHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVTZXJ2ZXJUb29sQ2FsbEZyb21WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnVuY3Rpb25DYWxscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uQ2FsbHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25DYWxscyAhPSBudWxsKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZyb21GdW5jdGlvbkNhbGxzKSkge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25DYWxscyddLCBmcm9tRnVuY3Rpb25DYWxscy5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb25DYWxsRnJvbVZlcnRleChhcGlDbGllbnQsIGl0ZW0pO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25DYWxscyddLCBmcm9tRnVuY3Rpb25DYWxscyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZVNlcnZlclRvb2xDYWxsQ2FuY2VsbGF0aW9uRnJvbU1sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUlkcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaWRzJ10pO1xuICAgIGlmIChmcm9tSWRzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaWRzJ10sIGZyb21JZHMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlU2VydmVyVG9vbENhbGxDYW5jZWxsYXRpb25Gcm9tVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUlkcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaWRzJ10pO1xuICAgIGlmIChmcm9tSWRzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaWRzJ10sIGZyb21JZHMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBtb2RhbGl0eVRva2VuQ291bnRGcm9tTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kYWxpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGFsaXR5J10pO1xuICAgIGlmIChmcm9tTW9kYWxpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RhbGl0eSddLCBmcm9tTW9kYWxpdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9rZW5Db3VudCddKTtcbiAgICBpZiAoZnJvbVRva2VuQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b2tlbkNvdW50J10sIGZyb21Ub2tlbkNvdW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbW9kYWxpdHlUb2tlbkNvdW50RnJvbVZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RhbGl0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kYWxpdHknXSk7XG4gICAgaWYgKGZyb21Nb2RhbGl0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGFsaXR5J10sIGZyb21Nb2RhbGl0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b2tlbkNvdW50J10pO1xuICAgIGlmIChmcm9tVG9rZW5Db3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rva2VuQ291bnQnXSwgZnJvbVRva2VuQ291bnQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1c2FnZU1ldGFkYXRhRnJvbU1sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVByb21wdFRva2VuQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcm9tcHRUb2tlbkNvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByb21wdFRva2VuQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcm9tcHRUb2tlbkNvdW50J10sIGZyb21Qcm9tcHRUb2tlbkNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhY2hlZENvbnRlbnRUb2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2FjaGVkQ29udGVudFRva2VuQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2FjaGVkQ29udGVudFRva2VuQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYWNoZWRDb250ZW50VG9rZW5Db3VudCddLCBmcm9tQ2FjaGVkQ29udGVudFRva2VuQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VUb2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VUb2tlbkNvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlVG9rZW5Db3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlVG9rZW5Db3VudCddLCBmcm9tUmVzcG9uc2VUb2tlbkNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xVc2VQcm9tcHRUb2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndG9vbFVzZVByb21wdFRva2VuQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVG9vbFVzZVByb21wdFRva2VuQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b29sVXNlUHJvbXB0VG9rZW5Db3VudCddLCBmcm9tVG9vbFVzZVByb21wdFRva2VuQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodHNUb2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhvdWdodHNUb2tlbkNvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRob3VnaHRzVG9rZW5Db3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHRzVG9rZW5Db3VudCddLCBmcm9tVGhvdWdodHNUb2tlbkNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvdGFsVG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RvdGFsVG9rZW5Db3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Ub3RhbFRva2VuQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3RhbFRva2VuQ291bnQnXSwgZnJvbVRvdGFsVG9rZW5Db3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9tcHRUb2tlbnNEZXRhaWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJvbXB0VG9rZW5zRGV0YWlscycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Qcm9tcHRUb2tlbnNEZXRhaWxzICE9IG51bGwpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZnJvbVByb21wdFRva2Vuc0RldGFpbHMpKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcm9tcHRUb2tlbnNEZXRhaWxzJ10sIGZyb21Qcm9tcHRUb2tlbnNEZXRhaWxzLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb2RhbGl0eVRva2VuQ291bnRGcm9tTWxkZXYoYXBpQ2xpZW50LCBpdGVtKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Byb21wdFRva2Vuc0RldGFpbHMnXSwgZnJvbVByb21wdFRva2Vuc0RldGFpbHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYWNoZVRva2Vuc0RldGFpbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYWNoZVRva2Vuc0RldGFpbHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2FjaGVUb2tlbnNEZXRhaWxzICE9IG51bGwpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZnJvbUNhY2hlVG9rZW5zRGV0YWlscykpIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhY2hlVG9rZW5zRGV0YWlscyddLCBmcm9tQ2FjaGVUb2tlbnNEZXRhaWxzLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb2RhbGl0eVRva2VuQ291bnRGcm9tTWxkZXYoYXBpQ2xpZW50LCBpdGVtKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhY2hlVG9rZW5zRGV0YWlscyddLCBmcm9tQ2FjaGVUb2tlbnNEZXRhaWxzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VUb2tlbnNEZXRhaWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VUb2tlbnNEZXRhaWxzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlVG9rZW5zRGV0YWlscyAhPSBudWxsKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZyb21SZXNwb25zZVRva2Vuc0RldGFpbHMpKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZVRva2Vuc0RldGFpbHMnXSwgZnJvbVJlc3BvbnNlVG9rZW5zRGV0YWlscy5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kYWxpdHlUb2tlbkNvdW50RnJvbU1sZGV2KGFwaUNsaWVudCwgaXRlbSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZVRva2Vuc0RldGFpbHMnXSwgZnJvbVJlc3BvbnNlVG9rZW5zRGV0YWlscyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xVc2VQcm9tcHRUb2tlbnNEZXRhaWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndG9vbFVzZVByb21wdFRva2Vuc0RldGFpbHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVG9vbFVzZVByb21wdFRva2Vuc0RldGFpbHMgIT0gbnVsbCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmcm9tVG9vbFVzZVByb21wdFRva2Vuc0RldGFpbHMpKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b29sVXNlUHJvbXB0VG9rZW5zRGV0YWlscyddLCBmcm9tVG9vbFVzZVByb21wdFRva2Vuc0RldGFpbHMubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZGFsaXR5VG9rZW5Db3VudEZyb21NbGRldihhcGlDbGllbnQsIGl0ZW0pO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9vbFVzZVByb21wdFRva2Vuc0RldGFpbHMnXSwgZnJvbVRvb2xVc2VQcm9tcHRUb2tlbnNEZXRhaWxzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1c2FnZU1ldGFkYXRhRnJvbVZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Qcm9tcHRUb2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJvbXB0VG9rZW5Db3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Qcm9tcHRUb2tlbkNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJvbXB0VG9rZW5Db3VudCddLCBmcm9tUHJvbXB0VG9rZW5Db3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYWNoZWRDb250ZW50VG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NhY2hlZENvbnRlbnRUb2tlbkNvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNhY2hlZENvbnRlbnRUb2tlbkNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2FjaGVkQ29udGVudFRva2VuQ291bnQnXSwgZnJvbUNhY2hlZENvbnRlbnRUb2tlbkNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlVG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NhbmRpZGF0ZXNUb2tlbkNvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlVG9rZW5Db3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlVG9rZW5Db3VudCddLCBmcm9tUmVzcG9uc2VUb2tlbkNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xVc2VQcm9tcHRUb2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndG9vbFVzZVByb21wdFRva2VuQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVG9vbFVzZVByb21wdFRva2VuQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b29sVXNlUHJvbXB0VG9rZW5Db3VudCddLCBmcm9tVG9vbFVzZVByb21wdFRva2VuQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodHNUb2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhvdWdodHNUb2tlbkNvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRob3VnaHRzVG9rZW5Db3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHRzVG9rZW5Db3VudCddLCBmcm9tVGhvdWdodHNUb2tlbkNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvdGFsVG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RvdGFsVG9rZW5Db3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Ub3RhbFRva2VuQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3RhbFRva2VuQ291bnQnXSwgZnJvbVRvdGFsVG9rZW5Db3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9tcHRUb2tlbnNEZXRhaWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJvbXB0VG9rZW5zRGV0YWlscycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Qcm9tcHRUb2tlbnNEZXRhaWxzICE9IG51bGwpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZnJvbVByb21wdFRva2Vuc0RldGFpbHMpKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcm9tcHRUb2tlbnNEZXRhaWxzJ10sIGZyb21Qcm9tcHRUb2tlbnNEZXRhaWxzLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb2RhbGl0eVRva2VuQ291bnRGcm9tVmVydGV4KGFwaUNsaWVudCwgaXRlbSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcm9tcHRUb2tlbnNEZXRhaWxzJ10sIGZyb21Qcm9tcHRUb2tlbnNEZXRhaWxzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FjaGVUb2tlbnNEZXRhaWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2FjaGVUb2tlbnNEZXRhaWxzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNhY2hlVG9rZW5zRGV0YWlscyAhPSBudWxsKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZyb21DYWNoZVRva2Vuc0RldGFpbHMpKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYWNoZVRva2Vuc0RldGFpbHMnXSwgZnJvbUNhY2hlVG9rZW5zRGV0YWlscy5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kYWxpdHlUb2tlbkNvdW50RnJvbVZlcnRleChhcGlDbGllbnQsIGl0ZW0pO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2FjaGVUb2tlbnNEZXRhaWxzJ10sIGZyb21DYWNoZVRva2Vuc0RldGFpbHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZVRva2Vuc0RldGFpbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYW5kaWRhdGVzVG9rZW5zRGV0YWlscycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZVRva2Vuc0RldGFpbHMgIT0gbnVsbCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmcm9tUmVzcG9uc2VUb2tlbnNEZXRhaWxzKSkge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VUb2tlbnNEZXRhaWxzJ10sIGZyb21SZXNwb25zZVRva2Vuc0RldGFpbHMubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZGFsaXR5VG9rZW5Db3VudEZyb21WZXJ0ZXgoYXBpQ2xpZW50LCBpdGVtKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlVG9rZW5zRGV0YWlscyddLCBmcm9tUmVzcG9uc2VUb2tlbnNEZXRhaWxzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbFVzZVByb21wdFRva2Vuc0RldGFpbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0b29sVXNlUHJvbXB0VG9rZW5zRGV0YWlscycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Ub29sVXNlUHJvbXB0VG9rZW5zRGV0YWlscyAhPSBudWxsKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZyb21Ub29sVXNlUHJvbXB0VG9rZW5zRGV0YWlscykpIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rvb2xVc2VQcm9tcHRUb2tlbnNEZXRhaWxzJ10sIGZyb21Ub29sVXNlUHJvbXB0VG9rZW5zRGV0YWlscy5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kYWxpdHlUb2tlbkNvdW50RnJvbVZlcnRleChhcGlDbGllbnQsIGl0ZW0pO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9vbFVzZVByb21wdFRva2Vuc0RldGFpbHMnXSwgZnJvbVRvb2xVc2VQcm9tcHRUb2tlbnNEZXRhaWxzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmcm9tVHJhZmZpY1R5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RyYWZmaWNUeXBlJ10pO1xuICAgIGlmIChmcm9tVHJhZmZpY1R5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0cmFmZmljVHlwZSddLCBmcm9tVHJhZmZpY1R5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlU2VydmVyR29Bd2F5RnJvbU1sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVRpbWVMZWZ0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aW1lTGVmdCddKTtcbiAgICBpZiAoZnJvbVRpbWVMZWZ0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGltZUxlZnQnXSwgZnJvbVRpbWVMZWZ0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZVNlcnZlckdvQXdheUZyb21WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVGltZUxlZnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RpbWVMZWZ0J10pO1xuICAgIGlmIChmcm9tVGltZUxlZnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aW1lTGVmdCddLCBmcm9tVGltZUxlZnQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlU2VydmVyU2Vzc2lvblJlc3VtcHRpb25VcGRhdGVGcm9tTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmV3SGFuZGxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduZXdIYW5kbGUnXSk7XG4gICAgaWYgKGZyb21OZXdIYW5kbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduZXdIYW5kbGUnXSwgZnJvbU5ld0hhbmRsZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXN1bWFibGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3VtYWJsZSddKTtcbiAgICBpZiAoZnJvbVJlc3VtYWJsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3VtYWJsZSddLCBmcm9tUmVzdW1hYmxlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhc3RDb25zdW1lZENsaWVudE1lc3NhZ2VJbmRleCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2xhc3RDb25zdW1lZENsaWVudE1lc3NhZ2VJbmRleCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21MYXN0Q29uc3VtZWRDbGllbnRNZXNzYWdlSW5kZXggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsYXN0Q29uc3VtZWRDbGllbnRNZXNzYWdlSW5kZXgnXSwgZnJvbUxhc3RDb25zdW1lZENsaWVudE1lc3NhZ2VJbmRleCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVTZXJ2ZXJTZXNzaW9uUmVzdW1wdGlvblVwZGF0ZUZyb21WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmV3SGFuZGxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduZXdIYW5kbGUnXSk7XG4gICAgaWYgKGZyb21OZXdIYW5kbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduZXdIYW5kbGUnXSwgZnJvbU5ld0hhbmRsZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXN1bWFibGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3VtYWJsZSddKTtcbiAgICBpZiAoZnJvbVJlc3VtYWJsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3VtYWJsZSddLCBmcm9tUmVzdW1hYmxlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhc3RDb25zdW1lZENsaWVudE1lc3NhZ2VJbmRleCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2xhc3RDb25zdW1lZENsaWVudE1lc3NhZ2VJbmRleCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21MYXN0Q29uc3VtZWRDbGllbnRNZXNzYWdlSW5kZXggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsYXN0Q29uc3VtZWRDbGllbnRNZXNzYWdlSW5kZXgnXSwgZnJvbUxhc3RDb25zdW1lZENsaWVudE1lc3NhZ2VJbmRleCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVTZXJ2ZXJNZXNzYWdlRnJvbU1sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNldHVwQ29tcGxldGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZXR1cENvbXBsZXRlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNldHVwQ29tcGxldGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZXR1cENvbXBsZXRlJ10sIGxpdmVTZXJ2ZXJTZXR1cENvbXBsZXRlRnJvbU1sZGV2KCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VydmVyQ29udGVudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NlcnZlckNvbnRlbnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2VydmVyQ29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NlcnZlckNvbnRlbnQnXSwgbGl2ZVNlcnZlckNvbnRlbnRGcm9tTWxkZXYoYXBpQ2xpZW50LCBmcm9tU2VydmVyQ29udGVudCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbENhbGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rvb2xDYWxsJ10pO1xuICAgIGlmIChmcm9tVG9vbENhbGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b29sQ2FsbCddLCBsaXZlU2VydmVyVG9vbENhbGxGcm9tTWxkZXYoYXBpQ2xpZW50LCBmcm9tVG9vbENhbGwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xDYWxsQ2FuY2VsbGF0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndG9vbENhbGxDYW5jZWxsYXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVG9vbENhbGxDYW5jZWxsYXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b29sQ2FsbENhbmNlbGxhdGlvbiddLCBsaXZlU2VydmVyVG9vbENhbGxDYW5jZWxsYXRpb25Gcm9tTWxkZXYoYXBpQ2xpZW50LCBmcm9tVG9vbENhbGxDYW5jZWxsYXRpb24pKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVzYWdlTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd1c2FnZU1ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVVzYWdlTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1c2FnZU1ldGFkYXRhJ10sIHVzYWdlTWV0YWRhdGFGcm9tTWxkZXYoYXBpQ2xpZW50LCBmcm9tVXNhZ2VNZXRhZGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29Bd2F5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb0F3YXknXSk7XG4gICAgaWYgKGZyb21Hb0F3YXkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb0F3YXknXSwgbGl2ZVNlcnZlckdvQXdheUZyb21NbGRldihhcGlDbGllbnQsIGZyb21Hb0F3YXkpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlc3Npb25SZXN1bXB0aW9uVXBkYXRlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2Vzc2lvblJlc3VtcHRpb25VcGRhdGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2Vzc2lvblJlc3VtcHRpb25VcGRhdGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZXNzaW9uUmVzdW1wdGlvblVwZGF0ZSddLCBsaXZlU2VydmVyU2Vzc2lvblJlc3VtcHRpb25VcGRhdGVGcm9tTWxkZXYoYXBpQ2xpZW50LCBmcm9tU2Vzc2lvblJlc3VtcHRpb25VcGRhdGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZVNlcnZlck1lc3NhZ2VGcm9tVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNldHVwQ29tcGxldGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZXR1cENvbXBsZXRlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNldHVwQ29tcGxldGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZXR1cENvbXBsZXRlJ10sIGxpdmVTZXJ2ZXJTZXR1cENvbXBsZXRlRnJvbVZlcnRleCgpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlcnZlckNvbnRlbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZXJ2ZXJDb250ZW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNlcnZlckNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZXJ2ZXJDb250ZW50J10sIGxpdmVTZXJ2ZXJDb250ZW50RnJvbVZlcnRleChhcGlDbGllbnQsIGZyb21TZXJ2ZXJDb250ZW50KSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29sQ2FsbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbENhbGwnXSk7XG4gICAgaWYgKGZyb21Ub29sQ2FsbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rvb2xDYWxsJ10sIGxpdmVTZXJ2ZXJUb29sQ2FsbEZyb21WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tVG9vbENhbGwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xDYWxsQ2FuY2VsbGF0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndG9vbENhbGxDYW5jZWxsYXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVG9vbENhbGxDYW5jZWxsYXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b29sQ2FsbENhbmNlbGxhdGlvbiddLCBsaXZlU2VydmVyVG9vbENhbGxDYW5jZWxsYXRpb25Gcm9tVmVydGV4KGFwaUNsaWVudCwgZnJvbVRvb2xDYWxsQ2FuY2VsbGF0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Vc2FnZU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndXNhZ2VNZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Vc2FnZU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXNhZ2VNZXRhZGF0YSddLCB1c2FnZU1ldGFkYXRhRnJvbVZlcnRleChhcGlDbGllbnQsIGZyb21Vc2FnZU1ldGFkYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb0F3YXkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvQXdheSddKTtcbiAgICBpZiAoZnJvbUdvQXdheSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvQXdheSddLCBsaXZlU2VydmVyR29Bd2F5RnJvbVZlcnRleChhcGlDbGllbnQsIGZyb21Hb0F3YXkpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlc3Npb25SZXN1bXB0aW9uVXBkYXRlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2Vzc2lvblJlc3VtcHRpb25VcGRhdGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2Vzc2lvblJlc3VtcHRpb25VcGRhdGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZXNzaW9uUmVzdW1wdGlvblVwZGF0ZSddLCBsaXZlU2VydmVyU2Vzc2lvblJlc3VtcHRpb25VcGRhdGVGcm9tVmVydGV4KGFwaUNsaWVudCwgZnJvbVNlc3Npb25SZXN1bXB0aW9uVXBkYXRlKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuZnVuY3Rpb24gcGFydFRvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2aWRlb01ldGFkYXRhJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd2aWRlb01ldGFkYXRhIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aG91Z2h0J10pO1xuICAgIGlmIChmcm9tVGhvdWdodCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHQnXSwgZnJvbVRob3VnaHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb25SZXN1bHQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb25SZXN1bHQnXSwgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhlY3V0YWJsZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdleGVjdXRhYmxlQ29kZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FeGVjdXRhYmxlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4ZWN1dGFibGVDb2RlJ10sIGZyb21FeGVjdXRhYmxlQ29kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZURhdGEnXSk7XG4gICAgaWYgKGZyb21GaWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVEYXRhJ10sIGZyb21GaWxlRGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvbkNhbGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uQ2FsbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddLCBmcm9tRnVuY3Rpb25DYWxsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvblJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvblJlc3BvbnNlJ10sIGZyb21GdW5jdGlvblJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlubGluZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lubGluZURhdGEnXSk7XG4gICAgaWYgKGZyb21JbmxpbmVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5saW5lRGF0YSddLCBmcm9tSW5saW5lRGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZXh0J10pO1xuICAgIGlmIChmcm9tVGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RleHQnXSwgZnJvbVRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb250ZW50VG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYXJ0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFydHMnXSk7XG4gICAgaWYgKGZyb21QYXJ0cyAhPSBudWxsKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZyb21QYXJ0cykpIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcnRzJ10sIGZyb21QYXJ0cy5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydFRvTWxkZXYoYXBpQ2xpZW50LCBpdGVtKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcnRzJ10sIGZyb21QYXJ0cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZnJvbVJvbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JvbGUnXSk7XG4gICAgaWYgKGZyb21Sb2xlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncm9sZSddLCBmcm9tUm9sZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNjaGVtYVRvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleGFtcGxlJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleGFtcGxlIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhdHRlcm4nXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhdHRlcm4gcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVmYXVsdCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGVmYXVsdCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtYXhMZW5ndGgnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21heExlbmd0aCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW5MZW5ndGgnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pbkxlbmd0aCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW5Qcm9wZXJ0aWVzJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaW5Qcm9wZXJ0aWVzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21heFByb3BlcnRpZXMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21heFByb3BlcnRpZXMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFueU9mID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhbnlPZiddKTtcbiAgICBpZiAoZnJvbUFueU9mICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYW55T2YnXSwgZnJvbUFueU9mKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXNjcmlwdGlvbiddKTtcbiAgICBpZiAoZnJvbURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVzY3JpcHRpb24nXSwgZnJvbURlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVudW0gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VudW0nXSk7XG4gICAgaWYgKGZyb21FbnVtICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW51bSddLCBmcm9tRW51bSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Gb3JtYXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Zvcm1hdCddKTtcbiAgICBpZiAoZnJvbUZvcm1hdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Zvcm1hdCddLCBmcm9tRm9ybWF0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUl0ZW1zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpdGVtcyddKTtcbiAgICBpZiAoZnJvbUl0ZW1zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaXRlbXMnXSwgZnJvbUl0ZW1zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heEl0ZW1zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtYXhJdGVtcyddKTtcbiAgICBpZiAoZnJvbU1heEl0ZW1zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWF4SXRlbXMnXSwgZnJvbU1heEl0ZW1zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heGltdW0gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21heGltdW0nXSk7XG4gICAgaWYgKGZyb21NYXhpbXVtICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWF4aW11bSddLCBmcm9tTWF4aW11bSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW5JdGVtcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWluSXRlbXMnXSk7XG4gICAgaWYgKGZyb21NaW5JdGVtcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbkl0ZW1zJ10sIGZyb21NaW5JdGVtcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW5pbXVtID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW5pbXVtJ10pO1xuICAgIGlmIChmcm9tTWluaW11bSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbmltdW0nXSwgZnJvbU1pbmltdW0pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTnVsbGFibGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ251bGxhYmxlJ10pO1xuICAgIGlmIChmcm9tTnVsbGFibGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydudWxsYWJsZSddLCBmcm9tTnVsbGFibGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvcGVydGllcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJvcGVydGllcyddKTtcbiAgICBpZiAoZnJvbVByb3BlcnRpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcm9wZXJ0aWVzJ10sIGZyb21Qcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb3BlcnR5T3JkZXJpbmcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcm9wZXJ0eU9yZGVyaW5nJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByb3BlcnR5T3JkZXJpbmcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcm9wZXJ0eU9yZGVyaW5nJ10sIGZyb21Qcm9wZXJ0eU9yZGVyaW5nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlcXVpcmVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXF1aXJlZCddKTtcbiAgICBpZiAoZnJvbVJlcXVpcmVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVxdWlyZWQnXSwgZnJvbVJlcXVpcmVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRpdGxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aXRsZSddKTtcbiAgICBpZiAoZnJvbVRpdGxlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGl0bGUnXSwgZnJvbVRpdGxlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3R5cGUnXSk7XG4gICAgaWYgKGZyb21UeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHlwZSddLCBmcm9tVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNhZmV0eVNldHRpbmdUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWV0aG9kJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtZXRob2QgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhdGVnb3J5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjYXRlZ29yeSddKTtcbiAgICBpZiAoZnJvbUNhdGVnb3J5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2F0ZWdvcnknXSwgZnJvbUNhdGVnb3J5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRocmVzaG9sZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGhyZXNob2xkJ10pO1xuICAgIGlmIChmcm9tVGhyZXNob2xkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhyZXNob2xkJ10sIGZyb21UaHJlc2hvbGQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkRlY2xhcmF0aW9uVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3BvbnNlJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXNwb25zZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10pO1xuICAgIGlmIChmcm9tRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXNjcmlwdGlvbiddLCBmcm9tRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhcmFtZXRlcnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcmFtZXRlcnMnXSk7XG4gICAgaWYgKGZyb21QYXJhbWV0ZXJzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFyYW1ldGVycyddLCBmcm9tUGFyYW1ldGVycyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZVNlYXJjaFRvTWxkZXYoKSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkeW5hbWljUmV0cmlldmFsQ29uZmlnVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlJ10pO1xuICAgIGlmIChmcm9tTW9kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGUnXSwgZnJvbU1vZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRHluYW1pY1RocmVzaG9sZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2R5bmFtaWNUaHJlc2hvbGQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRHluYW1pY1RocmVzaG9sZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2R5bmFtaWNUaHJlc2hvbGQnXSwgZnJvbUR5bmFtaWNUaHJlc2hvbGQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnb29nbGVTZWFyY2hSZXRyaWV2YWxUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUR5bmFtaWNSZXRyaWV2YWxDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdkeW5hbWljUmV0cmlldmFsQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUR5bmFtaWNSZXRyaWV2YWxDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkeW5hbWljUmV0cmlldmFsQ29uZmlnJ10sIGR5bmFtaWNSZXRyaWV2YWxDb25maWdUb01sZGV2KGFwaUNsaWVudCwgZnJvbUR5bmFtaWNSZXRyaWV2YWxDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdG9vbFRvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvbkRlY2xhcmF0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucykpIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJ10sIGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucy5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb25EZWNsYXJhdGlvblRvTWxkZXYoYXBpQ2xpZW50LCBpdGVtKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJ10sIGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmV0cmlldmFsJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXRyaWV2YWwgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ29vZ2xlU2VhcmNoJ10pO1xuICAgIGlmIChmcm9tR29vZ2xlU2VhcmNoICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlU2VhcmNoJ10sIGdvb2dsZVNlYXJjaFRvTWxkZXYoKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnb29nbGVTZWFyY2hSZXRyaWV2YWwnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlU2VhcmNoUmV0cmlldmFsJ10sIGdvb2dsZVNlYXJjaFJldHJpZXZhbFRvTWxkZXYoYXBpQ2xpZW50LCBmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvbiddLCBmcm9tQ29kZUV4ZWN1dGlvbik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZSddKTtcbiAgICBpZiAoZnJvbU1vZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlJ10sIGZyb21Nb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFsbG93ZWRGdW5jdGlvbk5hbWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYWxsb3dlZEZ1bmN0aW9uTmFtZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQWxsb3dlZEZ1bmN0aW9uTmFtZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhbGxvd2VkRnVuY3Rpb25OYW1lcyddLCBmcm9tQWxsb3dlZEZ1bmN0aW9uTmFtZXMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0b29sQ29uZmlnVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GdW5jdGlvbkNhbGxpbmdDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvbkNhbGxpbmdDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25DYWxsaW5nQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25DYWxsaW5nQ29uZmlnJ10sIGZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tRnVuY3Rpb25DYWxsaW5nQ29uZmlnKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHByZWJ1aWx0Vm9pY2VDb25maWdUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZvaWNlTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndm9pY2VOYW1lJ10pO1xuICAgIGlmIChmcm9tVm9pY2VOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndm9pY2VOYW1lJ10sIGZyb21Wb2ljZU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB2b2ljZUNvbmZpZ1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUHJlYnVpbHRWb2ljZUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZWJ1aWx0Vm9pY2VDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJlYnVpbHRWb2ljZUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ByZWJ1aWx0Vm9pY2VDb25maWcnXSwgcHJlYnVpbHRWb2ljZUNvbmZpZ1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tUHJlYnVpbHRWb2ljZUNvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzcGVlY2hDb25maWdUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZvaWNlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2b2ljZUNvbmZpZyddKTtcbiAgICBpZiAoZnJvbVZvaWNlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndm9pY2VDb25maWcnXSwgdm9pY2VDb25maWdUb01sZGV2KGFwaUNsaWVudCwgZnJvbVZvaWNlQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYW5ndWFnZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhbmd1YWdlQ29kZSddKTtcbiAgICBpZiAoZnJvbUxhbmd1YWdlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhbmd1YWdlQ29kZSddLCBmcm9tTGFuZ3VhZ2VDb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdGhpbmtpbmdDb25maWdUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUluY2x1ZGVUaG91Z2h0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2luY2x1ZGVUaG91Z2h0cycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21JbmNsdWRlVGhvdWdodHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbmNsdWRlVGhvdWdodHMnXSwgZnJvbUluY2x1ZGVUaG91Z2h0cyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaGlua2luZ0J1ZGdldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RoaW5raW5nQnVkZ2V0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRoaW5raW5nQnVkZ2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhpbmtpbmdCdWRnZXQnXSwgZnJvbVRoaW5raW5nQnVkZ2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVDb250ZW50Q29uZmlnVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVN5c3RlbUluc3RydWN0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3lzdGVtSW5zdHJ1Y3Rpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc3lzdGVtSW5zdHJ1Y3Rpb24nXSwgY29udGVudFRvTWxkZXYoYXBpQ2xpZW50LCB0Q29udGVudChhcGlDbGllbnQsIGZyb21TeXN0ZW1JbnN0cnVjdGlvbikpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRlbXBlcmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZW1wZXJhdHVyZSddKTtcbiAgICBpZiAoZnJvbVRlbXBlcmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGVtcGVyYXR1cmUnXSwgZnJvbVRlbXBlcmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcFAgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcFAnXSk7XG4gICAgaWYgKGZyb21Ub3BQICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9wUCddLCBmcm9tVG9wUCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BLID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BLJ10pO1xuICAgIGlmIChmcm9tVG9wSyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RvcEsnXSwgZnJvbVRvcEspO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FuZGlkYXRlQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYW5kaWRhdGVDb3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DYW5kaWRhdGVDb3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhbmRpZGF0ZUNvdW50J10sIGZyb21DYW5kaWRhdGVDb3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhPdXRwdXRUb2tlbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtYXhPdXRwdXRUb2tlbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTWF4T3V0cHV0VG9rZW5zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWF4T3V0cHV0VG9rZW5zJ10sIGZyb21NYXhPdXRwdXRUb2tlbnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RvcFNlcXVlbmNlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N0b3BTZXF1ZW5jZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU3RvcFNlcXVlbmNlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0b3BTZXF1ZW5jZXMnXSwgZnJvbVN0b3BTZXF1ZW5jZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VMb2dwcm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTG9ncHJvYnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VMb2dwcm9icyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlTG9ncHJvYnMnXSwgZnJvbVJlc3BvbnNlTG9ncHJvYnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTG9ncHJvYnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xvZ3Byb2JzJ10pO1xuICAgIGlmIChmcm9tTG9ncHJvYnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsb2dwcm9icyddLCBmcm9tTG9ncHJvYnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJlc2VuY2VQZW5hbHR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlc2VuY2VQZW5hbHR5JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByZXNlbmNlUGVuYWx0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ByZXNlbmNlUGVuYWx0eSddLCBmcm9tUHJlc2VuY2VQZW5hbHR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZyZXF1ZW5jeVBlbmFsdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmcmVxdWVuY3lQZW5hbHR5JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZyZXF1ZW5jeVBlbmFsdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmcmVxdWVuY3lQZW5hbHR5J10sIGZyb21GcmVxdWVuY3lQZW5hbHR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSk7XG4gICAgaWYgKGZyb21TZWVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2VlZCddLCBmcm9tU2VlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VNaW1lVHlwZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VNaW1lVHlwZSddLCBmcm9tUmVzcG9uc2VNaW1lVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZVNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VTY2hlbWEnXSwgc2NoZW1hVG9NbGRldihhcGlDbGllbnQsIHRTY2hlbWEoYXBpQ2xpZW50LCBmcm9tUmVzcG9uc2VTY2hlbWEpKSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JvdXRpbmdDb25maWcnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JvdXRpbmdDb25maWcgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWxTZWxlY3Rpb25Db25maWcnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21vZGVsU2VsZWN0aW9uQ29uZmlnIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TYWZldHlTZXR0aW5ncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eVNldHRpbmdzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNhZmV0eVNldHRpbmdzICE9IG51bGwpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZnJvbVNhZmV0eVNldHRpbmdzKSkge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NhZmV0eVNldHRpbmdzJ10sIGZyb21TYWZldHlTZXR0aW5ncy5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2FmZXR5U2V0dGluZ1RvTWxkZXYoYXBpQ2xpZW50LCBpdGVtKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzYWZldHlTZXR0aW5ncyddLCBmcm9tU2FmZXR5U2V0dGluZ3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29scyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub29scyAhPSBudWxsKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZyb21Ub29scykpIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0b29scyddLCB0VG9vbHMoYXBpQ2xpZW50LCB0VG9vbHMoYXBpQ2xpZW50LCBmcm9tVG9vbHMpLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b29sVG9NbGRldihhcGlDbGllbnQsIHRUb29sKGFwaUNsaWVudCwgaXRlbSkpO1xuICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0b29scyddLCB0VG9vbHMoYXBpQ2xpZW50LCBmcm9tVG9vbHMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbENvbmZpZyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndG9vbENvbmZpZyddLCB0b29sQ29uZmlnVG9NbGRldihhcGlDbGllbnQsIGZyb21Ub29sQ29uZmlnKSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhYmVscyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbGFiZWxzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYWNoZWRDb250ZW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2FjaGVkQ29udGVudCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21DYWNoZWRDb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2NhY2hlZENvbnRlbnQnXSwgdENhY2hlZENvbnRlbnROYW1lKGFwaUNsaWVudCwgZnJvbUNhY2hlZENvbnRlbnQpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTW9kYWxpdGllcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZU1vZGFsaXRpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZU1vZGFsaXRpZXMnXSwgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZWRpYVJlc29sdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtZWRpYVJlc29sdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTWVkaWFSZXNvbHV0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWVkaWFSZXNvbHV0aW9uJ10sIGZyb21NZWRpYVJlc29sdXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3BlZWNoQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzcGVlY2hDb25maWcnXSk7XG4gICAgaWYgKGZyb21TcGVlY2hDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzcGVlY2hDb25maWcnXSwgc3BlZWNoQ29uZmlnVG9NbGRldihhcGlDbGllbnQsIHRTcGVlY2hDb25maWcoYXBpQ2xpZW50LCBmcm9tU3BlZWNoQ29uZmlnKSkpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdWRpb1RpbWVzdGFtcCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXVkaW9UaW1lc3RhbXAgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRoaW5raW5nQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhpbmtpbmdDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGhpbmtpbmdDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aGlua2luZ0NvbmZpZyddLCB0aGlua2luZ0NvbmZpZ1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tVGhpbmtpbmdDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnRzJ10pO1xuICAgIGlmIChmcm9tQ29udGVudHMgIT0gbnVsbCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmcm9tQ29udGVudHMpKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb250ZW50cyddLCB0Q29udGVudHMoYXBpQ2xpZW50LCB0Q29udGVudHMoYXBpQ2xpZW50LCBmcm9tQ29udGVudHMpLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50VG9NbGRldihhcGlDbGllbnQsIGl0ZW0pO1xuICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbnRlbnRzJ10sIHRDb250ZW50cyhhcGlDbGllbnQsIGZyb21Db250ZW50cykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dlbmVyYXRpb25Db25maWcnXSwgZ2VuZXJhdGVDb250ZW50Q29uZmlnVG9NbGRldihhcGlDbGllbnQsIGZyb21Db25maWcsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVtYmVkQ29udGVudENvbmZpZ1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UYXNrVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGFza1R5cGUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UYXNrVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydyZXF1ZXN0c1tdJywgJ3Rhc2tUeXBlJ10sIGZyb21UYXNrVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaXRsZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGl0bGUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UaXRsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydyZXF1ZXN0c1tdJywgJ3RpdGxlJ10sIGZyb21UaXRsZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXREaW1lbnNpb25hbGl0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dERpbWVuc2lvbmFsaXR5JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dERpbWVuc2lvbmFsaXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3JlcXVlc3RzW10nLCAnb3V0cHV0RGltZW5zaW9uYWxpdHknXSwgZnJvbU91dHB1dERpbWVuc2lvbmFsaXR5KTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pbWVUeXBlIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2F1dG9UcnVuY2F0ZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXV0b1RydW5jYXRlIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVtYmVkQ29udGVudFBhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbnRlbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb250ZW50cyddKTtcbiAgICBpZiAoZnJvbUNvbnRlbnRzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVxdWVzdHNbXScsICdjb250ZW50J10sIHRDb250ZW50c0ZvckVtYmVkKGFwaUNsaWVudCwgZnJvbUNvbnRlbnRzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCBlbWJlZENvbnRlbnRDb25maWdUb01sZGV2KGFwaUNsaWVudCwgZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1vZGVsRm9yRW1iZWRDb250ZW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsRm9yRW1iZWRDb250ZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVxdWVzdHNbXScsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWxGb3JFbWJlZENvbnRlbnQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVJbWFnZXNDb25maWdUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvdXRwdXRHY3NVcmknXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ291dHB1dEdjc1VyaSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduZWdhdGl2ZVByb21wdCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbmVnYXRpdmVQcm9tcHQgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU51bWJlck9mSW1hZ2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbnVtYmVyT2ZJbWFnZXMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTnVtYmVyT2ZJbWFnZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzYW1wbGVDb3VudCddLCBmcm9tTnVtYmVyT2ZJbWFnZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXNwZWN0UmF0aW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FzcGVjdFJhdGlvJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQXNwZWN0UmF0aW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdhc3BlY3RSYXRpbyddLCBmcm9tQXNwZWN0UmF0aW8pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR3VpZGFuY2VTY2FsZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2d1aWRhbmNlU2NhbGUnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tR3VpZGFuY2VTY2FsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2d1aWRhbmNlU2NhbGUnXSwgZnJvbUd1aWRhbmNlU2NhbGUpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZWVkJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZWVkIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TYWZldHlGaWx0ZXJMZXZlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eUZpbHRlckxldmVsJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNhZmV0eUZpbHRlckxldmVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2FmZXR5U2V0dGluZyddLCBmcm9tU2FmZXR5RmlsdGVyTGV2ZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGVyc29uR2VuZXJhdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3BlcnNvbkdlbmVyYXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGVyc29uR2VuZXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3BlcnNvbkdlbmVyYXRpb24nXSwgZnJvbVBlcnNvbkdlbmVyYXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbmNsdWRlU2FmZXR5QXR0cmlidXRlcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbmNsdWRlU2FmZXR5QXR0cmlidXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2luY2x1ZGVTYWZldHlBdHRyaWJ1dGVzJ10sIGZyb21JbmNsdWRlU2FmZXR5QXR0cmlidXRlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmNsdWRlUmFpUmVhc29uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5jbHVkZVJhaVJlYXNvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbmNsdWRlUmFpUmVhc29uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnaW5jbHVkZVJhaVJlYXNvbiddLCBmcm9tSW5jbHVkZVJhaVJlYXNvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYW5ndWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFuZ3VhZ2UnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MYW5ndWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2xhbmd1YWdlJ10sIGZyb21MYW5ndWFnZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRNaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dE1pbWVUeXBlJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dE1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnb3V0cHV0T3B0aW9ucycsICdtaW1lVHlwZSddLCBmcm9tT3V0cHV0TWltZVR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ291dHB1dE9wdGlvbnMnLCAnY29tcHJlc3Npb25RdWFsaXR5J10sIGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhZGRXYXRlcm1hcmsnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FkZFdhdGVybWFyayBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmhhbmNlUHJvbXB0J10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbmhhbmNlUHJvbXB0IHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlSW1hZ2VzUGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9tcHQnXSk7XG4gICAgaWYgKGZyb21Qcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAncHJvbXB0J10sIGZyb21Qcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgZ2VuZXJhdGVJbWFnZXNDb25maWdUb01sZGV2KGFwaUNsaWVudCwgZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2V0TW9kZWxQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGZyb21Db25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb3VudFRva2Vuc0NvbmZpZ1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzeXN0ZW1JbnN0cnVjdGlvbiddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3lzdGVtSW5zdHJ1Y3Rpb24gcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbHMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Rvb2xzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dlbmVyYXRpb25Db25maWcnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dlbmVyYXRpb25Db25maWcgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY291bnRUb2tlbnNQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudHMnXSk7XG4gICAgaWYgKGZyb21Db250ZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZyb21Db250ZW50cykpIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbnRlbnRzJ10sIHRDb250ZW50cyhhcGlDbGllbnQsIHRDb250ZW50cyhhcGlDbGllbnQsIGZyb21Db250ZW50cykubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRUb01sZGV2KGFwaUNsaWVudCwgaXRlbSk7XG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29udGVudHMnXSwgdENvbnRlbnRzKGFwaUNsaWVudCwgZnJvbUNvbnRlbnRzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGNvdW50VG9rZW5zQ29uZmlnVG9NbGRldihhcGlDbGllbnQsIGZyb21Db25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW1hZ2VUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ2NzVXJpJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnY3NVcmkgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUltYWdlQnl0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ltYWdlQnl0ZXMnXSk7XG4gICAgaWYgKGZyb21JbWFnZUJ5dGVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYnl0ZXNCYXNlNjRFbmNvZGVkJ10sIHRCeXRlcyhhcGlDbGllbnQsIGZyb21JbWFnZUJ5dGVzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVmlkZW9zQ29uZmlnVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU51bWJlck9mVmlkZW9zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbnVtYmVyT2ZWaWRlb3MnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTnVtYmVyT2ZWaWRlb3MgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzYW1wbGVDb3VudCddLCBmcm9tTnVtYmVyT2ZWaWRlb3MpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvdXRwdXRHY3NVcmknXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ291dHB1dEdjc1VyaSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmcHMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZwcyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRHVyYXRpb25TZWNvbmRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZHVyYXRpb25TZWNvbmRzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUR1cmF0aW9uU2Vjb25kcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2R1cmF0aW9uU2Vjb25kcyddLCBmcm9tRHVyYXRpb25TZWNvbmRzKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2VlZCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2VlZCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXNwZWN0UmF0aW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FzcGVjdFJhdGlvJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQXNwZWN0UmF0aW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdhc3BlY3RSYXRpbyddLCBmcm9tQXNwZWN0UmF0aW8pO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNvbHV0aW9uJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXNvbHV0aW9uIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QZXJzb25HZW5lcmF0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncGVyc29uR2VuZXJhdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QZXJzb25HZW5lcmF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAncGVyc29uR2VuZXJhdGlvbiddLCBmcm9tUGVyc29uR2VuZXJhdGlvbik7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3B1YnN1YlRvcGljJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwdWJzdWJUb3BpYyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmVnYXRpdmVQcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZWdhdGl2ZVByb21wdCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21OZWdhdGl2ZVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ25lZ2F0aXZlUHJvbXB0J10sIGZyb21OZWdhdGl2ZVByb21wdCk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuaGFuY2VQcm9tcHQnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VuaGFuY2VQcm9tcHQgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVWaWRlb3NQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Byb21wdCddKTtcbiAgICBpZiAoZnJvbVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdwcm9tcHQnXSwgZnJvbVByb21wdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2UnXSk7XG4gICAgaWYgKGZyb21JbWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdpbWFnZSddLCBpbWFnZVRvTWxkZXYoYXBpQ2xpZW50LCBmcm9tSW1hZ2UpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGdlbmVyYXRlVmlkZW9zQ29uZmlnVG9NbGRldihhcGlDbGllbnQsIGZyb21Db25maWcsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHBhcnRUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21WaWRlb01ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndmlkZW9NZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21WaWRlb01ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW9NZXRhZGF0YSddLCBmcm9tVmlkZW9NZXRhZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aG91Z2h0J10pO1xuICAgIGlmIChmcm9tVGhvdWdodCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHQnXSwgZnJvbVRob3VnaHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb25SZXN1bHQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb25SZXN1bHQnXSwgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhlY3V0YWJsZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdleGVjdXRhYmxlQ29kZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FeGVjdXRhYmxlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4ZWN1dGFibGVDb2RlJ10sIGZyb21FeGVjdXRhYmxlQ29kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZURhdGEnXSk7XG4gICAgaWYgKGZyb21GaWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVEYXRhJ10sIGZyb21GaWxlRGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvbkNhbGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uQ2FsbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddLCBmcm9tRnVuY3Rpb25DYWxsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvblJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvblJlc3BvbnNlJ10sIGZyb21GdW5jdGlvblJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlubGluZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lubGluZURhdGEnXSk7XG4gICAgaWYgKGZyb21JbmxpbmVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5saW5lRGF0YSddLCBmcm9tSW5saW5lRGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZXh0J10pO1xuICAgIGlmIChmcm9tVGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RleHQnXSwgZnJvbVRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb250ZW50VG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFydHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcnRzJ10pO1xuICAgIGlmIChmcm9tUGFydHMgIT0gbnVsbCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmcm9tUGFydHMpKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJ0cyddLCBmcm9tUGFydHMubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRUb1ZlcnRleChhcGlDbGllbnQsIGl0ZW0pO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFydHMnXSwgZnJvbVBhcnRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmcm9tUm9sZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncm9sZSddKTtcbiAgICBpZiAoZnJvbVJvbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyb2xlJ10sIGZyb21Sb2xlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc2NoZW1hVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRXhhbXBsZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhhbXBsZSddKTtcbiAgICBpZiAoZnJvbUV4YW1wbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleGFtcGxlJ10sIGZyb21FeGFtcGxlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhdHRlcm4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhdHRlcm4nXSk7XG4gICAgaWYgKGZyb21QYXR0ZXJuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGF0dGVybiddLCBmcm9tUGF0dGVybik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZWZhdWx0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZWZhdWx0J10pO1xuICAgIGlmIChmcm9tRGVmYXVsdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RlZmF1bHQnXSwgZnJvbURlZmF1bHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWF4TGVuZ3RoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtYXhMZW5ndGgnXSk7XG4gICAgaWYgKGZyb21NYXhMZW5ndGggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtYXhMZW5ndGgnXSwgZnJvbU1heExlbmd0aCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW5MZW5ndGggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbkxlbmd0aCddKTtcbiAgICBpZiAoZnJvbU1pbkxlbmd0aCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbkxlbmd0aCddLCBmcm9tTWluTGVuZ3RoKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pblByb3BlcnRpZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtaW5Qcm9wZXJ0aWVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1pblByb3BlcnRpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW5Qcm9wZXJ0aWVzJ10sIGZyb21NaW5Qcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heFByb3BlcnRpZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtYXhQcm9wZXJ0aWVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1heFByb3BlcnRpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtYXhQcm9wZXJ0aWVzJ10sIGZyb21NYXhQcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFueU9mID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhbnlPZiddKTtcbiAgICBpZiAoZnJvbUFueU9mICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYW55T2YnXSwgZnJvbUFueU9mKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXNjcmlwdGlvbiddKTtcbiAgICBpZiAoZnJvbURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVzY3JpcHRpb24nXSwgZnJvbURlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVudW0gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VudW0nXSk7XG4gICAgaWYgKGZyb21FbnVtICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW51bSddLCBmcm9tRW51bSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Gb3JtYXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Zvcm1hdCddKTtcbiAgICBpZiAoZnJvbUZvcm1hdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Zvcm1hdCddLCBmcm9tRm9ybWF0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUl0ZW1zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpdGVtcyddKTtcbiAgICBpZiAoZnJvbUl0ZW1zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaXRlbXMnXSwgZnJvbUl0ZW1zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heEl0ZW1zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtYXhJdGVtcyddKTtcbiAgICBpZiAoZnJvbU1heEl0ZW1zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWF4SXRlbXMnXSwgZnJvbU1heEl0ZW1zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heGltdW0gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21heGltdW0nXSk7XG4gICAgaWYgKGZyb21NYXhpbXVtICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWF4aW11bSddLCBmcm9tTWF4aW11bSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW5JdGVtcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWluSXRlbXMnXSk7XG4gICAgaWYgKGZyb21NaW5JdGVtcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbkl0ZW1zJ10sIGZyb21NaW5JdGVtcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW5pbXVtID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW5pbXVtJ10pO1xuICAgIGlmIChmcm9tTWluaW11bSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbmltdW0nXSwgZnJvbU1pbmltdW0pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTnVsbGFibGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ251bGxhYmxlJ10pO1xuICAgIGlmIChmcm9tTnVsbGFibGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydudWxsYWJsZSddLCBmcm9tTnVsbGFibGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvcGVydGllcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJvcGVydGllcyddKTtcbiAgICBpZiAoZnJvbVByb3BlcnRpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcm9wZXJ0aWVzJ10sIGZyb21Qcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb3BlcnR5T3JkZXJpbmcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcm9wZXJ0eU9yZGVyaW5nJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByb3BlcnR5T3JkZXJpbmcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcm9wZXJ0eU9yZGVyaW5nJ10sIGZyb21Qcm9wZXJ0eU9yZGVyaW5nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlcXVpcmVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXF1aXJlZCddKTtcbiAgICBpZiAoZnJvbVJlcXVpcmVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVxdWlyZWQnXSwgZnJvbVJlcXVpcmVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRpdGxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aXRsZSddKTtcbiAgICBpZiAoZnJvbVRpdGxlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGl0bGUnXSwgZnJvbVRpdGxlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3R5cGUnXSk7XG4gICAgaWYgKGZyb21UeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHlwZSddLCBmcm9tVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIG1vZGVsU2VsZWN0aW9uQ29uZmlnVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRmVhdHVyZVNlbGVjdGlvblByZWZlcmVuY2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmZWF0dXJlU2VsZWN0aW9uUHJlZmVyZW5jZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GZWF0dXJlU2VsZWN0aW9uUHJlZmVyZW5jZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZlYXR1cmVTZWxlY3Rpb25QcmVmZXJlbmNlJ10sIGZyb21GZWF0dXJlU2VsZWN0aW9uUHJlZmVyZW5jZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNhZmV0eVNldHRpbmdUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21NZXRob2QgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21ldGhvZCddKTtcbiAgICBpZiAoZnJvbU1ldGhvZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21ldGhvZCddLCBmcm9tTWV0aG9kKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhdGVnb3J5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjYXRlZ29yeSddKTtcbiAgICBpZiAoZnJvbUNhdGVnb3J5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2F0ZWdvcnknXSwgZnJvbUNhdGVnb3J5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRocmVzaG9sZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGhyZXNob2xkJ10pO1xuICAgIGlmIChmcm9tVGhyZXNob2xkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhyZXNob2xkJ10sIGZyb21UaHJlc2hvbGQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkRlY2xhcmF0aW9uVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3BvbnNlJ10pO1xuICAgIGlmIChmcm9tUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZSddLCBzY2hlbWFUb1ZlcnRleChhcGlDbGllbnQsIGZyb21SZXNwb25zZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10pO1xuICAgIGlmIChmcm9tRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXNjcmlwdGlvbiddLCBmcm9tRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhcmFtZXRlcnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcmFtZXRlcnMnXSk7XG4gICAgaWYgKGZyb21QYXJhbWV0ZXJzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFyYW1ldGVycyddLCBmcm9tUGFyYW1ldGVycyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZVNlYXJjaFRvVmVydGV4KCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZHluYW1pY1JldHJpZXZhbENvbmZpZ1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGUnXSk7XG4gICAgaWYgKGZyb21Nb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZSddLCBmcm9tTW9kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EeW5hbWljVGhyZXNob2xkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZHluYW1pY1RocmVzaG9sZCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21EeW5hbWljVGhyZXNob2xkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZHluYW1pY1RocmVzaG9sZCddLCBmcm9tRHluYW1pY1RocmVzaG9sZCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZVNlYXJjaFJldHJpZXZhbFRvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUR5bmFtaWNSZXRyaWV2YWxDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdkeW5hbWljUmV0cmlldmFsQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUR5bmFtaWNSZXRyaWV2YWxDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkeW5hbWljUmV0cmlldmFsQ29uZmlnJ10sIGR5bmFtaWNSZXRyaWV2YWxDb25maWdUb1ZlcnRleChhcGlDbGllbnQsIGZyb21EeW5hbWljUmV0cmlldmFsQ29uZmlnKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRvb2xUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zICE9IG51bGwpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zKSkge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25EZWNsYXJhdGlvbnMnXSwgZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbkRlY2xhcmF0aW9uVG9WZXJ0ZXgoYXBpQ2xpZW50LCBpdGVtKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJ10sIGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZnJvbVJldHJpZXZhbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmV0cmlldmFsJ10pO1xuICAgIGlmIChmcm9tUmV0cmlldmFsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmV0cmlldmFsJ10sIGZyb21SZXRyaWV2YWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVTZWFyY2gnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2gnXSwgZ29vZ2xlU2VhcmNoVG9WZXJ0ZXgoKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnb29nbGVTZWFyY2hSZXRyaWV2YWwnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlU2VhcmNoUmV0cmlldmFsJ10sIGdvb2dsZVNlYXJjaFJldHJpZXZhbFRvVmVydGV4KGFwaUNsaWVudCwgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb24nXSwgZnJvbUNvZGVFeGVjdXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkNhbGxpbmdDb25maWdUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlJ10pO1xuICAgIGlmIChmcm9tTW9kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGUnXSwgZnJvbU1vZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQWxsb3dlZEZ1bmN0aW9uTmFtZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdhbGxvd2VkRnVuY3Rpb25OYW1lcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21BbGxvd2VkRnVuY3Rpb25OYW1lcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FsbG93ZWRGdW5jdGlvbk5hbWVzJ10sIGZyb21BbGxvd2VkRnVuY3Rpb25OYW1lcyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRvb2xDb25maWdUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GdW5jdGlvbkNhbGxpbmdDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvbkNhbGxpbmdDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25DYWxsaW5nQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25DYWxsaW5nQ29uZmlnJ10sIGZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbUZ1bmN0aW9uQ2FsbGluZ0NvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBwcmVidWlsdFZvaWNlQ29uZmlnVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVm9pY2VOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2b2ljZU5hbWUnXSk7XG4gICAgaWYgKGZyb21Wb2ljZU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2b2ljZU5hbWUnXSwgZnJvbVZvaWNlTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZvaWNlQ29uZmlnVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUHJlYnVpbHRWb2ljZUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZWJ1aWx0Vm9pY2VDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJlYnVpbHRWb2ljZUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ByZWJ1aWx0Vm9pY2VDb25maWcnXSwgcHJlYnVpbHRWb2ljZUNvbmZpZ1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbVByZWJ1aWx0Vm9pY2VDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc3BlZWNoQ29uZmlnVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVm9pY2VDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZvaWNlQ29uZmlnJ10pO1xuICAgIGlmIChmcm9tVm9pY2VDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2b2ljZUNvbmZpZyddLCB2b2ljZUNvbmZpZ1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbVZvaWNlQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYW5ndWFnZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhbmd1YWdlQ29kZSddKTtcbiAgICBpZiAoZnJvbUxhbmd1YWdlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhbmd1YWdlQ29kZSddLCBmcm9tTGFuZ3VhZ2VDb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdGhpbmtpbmdDb25maWdUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21JbmNsdWRlVGhvdWdodHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbmNsdWRlVGhvdWdodHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tSW5jbHVkZVRob3VnaHRzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5jbHVkZVRob3VnaHRzJ10sIGZyb21JbmNsdWRlVGhvdWdodHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhpbmtpbmdCdWRnZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aGlua2luZ0J1ZGdldCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaGlua2luZ0J1ZGdldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RoaW5raW5nQnVkZ2V0J10sIGZyb21UaGlua2luZ0J1ZGdldCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlQ29udGVudENvbmZpZ1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzeXN0ZW1JbnN0cnVjdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TeXN0ZW1JbnN0cnVjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzeXN0ZW1JbnN0cnVjdGlvbiddLCBjb250ZW50VG9WZXJ0ZXgoYXBpQ2xpZW50LCB0Q29udGVudChhcGlDbGllbnQsIGZyb21TeXN0ZW1JbnN0cnVjdGlvbikpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRlbXBlcmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZW1wZXJhdHVyZSddKTtcbiAgICBpZiAoZnJvbVRlbXBlcmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGVtcGVyYXR1cmUnXSwgZnJvbVRlbXBlcmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcFAgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcFAnXSk7XG4gICAgaWYgKGZyb21Ub3BQICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9wUCddLCBmcm9tVG9wUCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BLID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BLJ10pO1xuICAgIGlmIChmcm9tVG9wSyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RvcEsnXSwgZnJvbVRvcEspO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FuZGlkYXRlQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYW5kaWRhdGVDb3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DYW5kaWRhdGVDb3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhbmRpZGF0ZUNvdW50J10sIGZyb21DYW5kaWRhdGVDb3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhPdXRwdXRUb2tlbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtYXhPdXRwdXRUb2tlbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTWF4T3V0cHV0VG9rZW5zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWF4T3V0cHV0VG9rZW5zJ10sIGZyb21NYXhPdXRwdXRUb2tlbnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RvcFNlcXVlbmNlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N0b3BTZXF1ZW5jZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU3RvcFNlcXVlbmNlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0b3BTZXF1ZW5jZXMnXSwgZnJvbVN0b3BTZXF1ZW5jZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VMb2dwcm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTG9ncHJvYnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VMb2dwcm9icyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlTG9ncHJvYnMnXSwgZnJvbVJlc3BvbnNlTG9ncHJvYnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTG9ncHJvYnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xvZ3Byb2JzJ10pO1xuICAgIGlmIChmcm9tTG9ncHJvYnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsb2dwcm9icyddLCBmcm9tTG9ncHJvYnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJlc2VuY2VQZW5hbHR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlc2VuY2VQZW5hbHR5JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByZXNlbmNlUGVuYWx0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ByZXNlbmNlUGVuYWx0eSddLCBmcm9tUHJlc2VuY2VQZW5hbHR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZyZXF1ZW5jeVBlbmFsdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmcmVxdWVuY3lQZW5hbHR5JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZyZXF1ZW5jeVBlbmFsdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmcmVxdWVuY3lQZW5hbHR5J10sIGZyb21GcmVxdWVuY3lQZW5hbHR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSk7XG4gICAgaWYgKGZyb21TZWVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2VlZCddLCBmcm9tU2VlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VNaW1lVHlwZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VNaW1lVHlwZSddLCBmcm9tUmVzcG9uc2VNaW1lVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZVNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VTY2hlbWEnXSwgc2NoZW1hVG9WZXJ0ZXgoYXBpQ2xpZW50LCB0U2NoZW1hKGFwaUNsaWVudCwgZnJvbVJlc3BvbnNlU2NoZW1hKSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUm91dGluZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JvdXRpbmdDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUm91dGluZ0NvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JvdXRpbmdDb25maWcnXSwgZnJvbVJvdXRpbmdDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTW9kZWxTZWxlY3Rpb25Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtb2RlbFNlbGVjdGlvbkNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Nb2RlbFNlbGVjdGlvbkNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGVsQ29uZmlnJ10sIG1vZGVsU2VsZWN0aW9uQ29uZmlnVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tTW9kZWxTZWxlY3Rpb25Db25maWcpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNhZmV0eVNldHRpbmdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2FmZXR5U2V0dGluZ3MnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2FmZXR5U2V0dGluZ3MgIT0gbnVsbCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmcm9tU2FmZXR5U2V0dGluZ3MpKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2FmZXR5U2V0dGluZ3MnXSwgZnJvbVNhZmV0eVNldHRpbmdzLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBzYWZldHlTZXR0aW5nVG9WZXJ0ZXgoYXBpQ2xpZW50LCBpdGVtKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzYWZldHlTZXR0aW5ncyddLCBmcm9tU2FmZXR5U2V0dGluZ3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29scyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub29scyAhPSBudWxsKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZyb21Ub29scykpIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0b29scyddLCB0VG9vbHMoYXBpQ2xpZW50LCB0VG9vbHMoYXBpQ2xpZW50LCBmcm9tVG9vbHMpLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b29sVG9WZXJ0ZXgoYXBpQ2xpZW50LCB0VG9vbChhcGlDbGllbnQsIGl0ZW0pKTtcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndG9vbHMnXSwgdFRvb2xzKGFwaUNsaWVudCwgZnJvbVRvb2xzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rvb2xDb25maWcnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub29sQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3Rvb2xDb25maWcnXSwgdG9vbENvbmZpZ1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbVRvb2xDb25maWcpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhYmVscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFiZWxzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTGFiZWxzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2xhYmVscyddLCBmcm9tTGFiZWxzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhY2hlZENvbnRlbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYWNoZWRDb250ZW50JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUNhY2hlZENvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnY2FjaGVkQ29udGVudCddLCB0Q2FjaGVkQ29udGVudE5hbWUoYXBpQ2xpZW50LCBmcm9tQ2FjaGVkQ29udGVudCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VNb2RhbGl0aWVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlTW9kYWxpdGllcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlTW9kYWxpdGllcyddLCBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1lZGlhUmVzb2x1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21lZGlhUmVzb2x1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NZWRpYVJlc29sdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZWRpYVJlc29sdXRpb24nXSwgZnJvbU1lZGlhUmVzb2x1dGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TcGVlY2hDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NwZWVjaENvbmZpZyddKTtcbiAgICBpZiAoZnJvbVNwZWVjaENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NwZWVjaENvbmZpZyddLCBzcGVlY2hDb25maWdUb1ZlcnRleChhcGlDbGllbnQsIHRTcGVlY2hDb25maWcoYXBpQ2xpZW50LCBmcm9tU3BlZWNoQ29uZmlnKSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXVkaW9UaW1lc3RhbXAgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdhdWRpb1RpbWVzdGFtcCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21BdWRpb1RpbWVzdGFtcCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2F1ZGlvVGltZXN0YW1wJ10sIGZyb21BdWRpb1RpbWVzdGFtcCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaGlua2luZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RoaW5raW5nQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRoaW5raW5nQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhpbmtpbmdDb25maWcnXSwgdGhpbmtpbmdDb25maWdUb1ZlcnRleChhcGlDbGllbnQsIGZyb21UaGlua2luZ0NvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUNvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnRzJ10pO1xuICAgIGlmIChmcm9tQ29udGVudHMgIT0gbnVsbCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmcm9tQ29udGVudHMpKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb250ZW50cyddLCB0Q29udGVudHMoYXBpQ2xpZW50LCB0Q29udGVudHMoYXBpQ2xpZW50LCBmcm9tQ29udGVudHMpLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50VG9WZXJ0ZXgoYXBpQ2xpZW50LCBpdGVtKTtcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb250ZW50cyddLCB0Q29udGVudHMoYXBpQ2xpZW50LCBmcm9tQ29udGVudHMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnZW5lcmF0aW9uQ29uZmlnJ10sIGdlbmVyYXRlQ29udGVudENvbmZpZ1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZW1iZWRDb250ZW50Q29uZmlnVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UYXNrVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGFza1R5cGUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UYXNrVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbXScsICd0YXNrX3R5cGUnXSwgZnJvbVRhc2tUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRpdGxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aXRsZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRpdGxlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1tdJywgJ3RpdGxlJ10sIGZyb21UaXRsZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXREaW1lbnNpb25hbGl0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dERpbWVuc2lvbmFsaXR5JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dERpbWVuc2lvbmFsaXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnb3V0cHV0RGltZW5zaW9uYWxpdHknXSwgZnJvbU91dHB1dERpbWVuc2lvbmFsaXR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1tdJywgJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BdXRvVHJ1bmNhdGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2F1dG9UcnVuY2F0ZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUF1dG9UcnVuY2F0ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2F1dG9UcnVuY2F0ZSddLCBmcm9tQXV0b1RydW5jYXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZW1iZWRDb250ZW50UGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbnRlbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb250ZW50cyddKTtcbiAgICBpZiAoZnJvbUNvbnRlbnRzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5zdGFuY2VzW10nLCAnY29udGVudCddLCB0Q29udGVudHNGb3JFbWJlZChhcGlDbGllbnQsIGZyb21Db250ZW50cykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgZW1iZWRDb250ZW50Q29uZmlnVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tQ29uZmlnLCB0b09iamVjdCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUltYWdlc0NvbmZpZ1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tT3V0cHV0R2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvdXRwdXRHY3NVcmknXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRHY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzdG9yYWdlVXJpJ10sIGZyb21PdXRwdXRHY3NVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmVnYXRpdmVQcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZWdhdGl2ZVByb21wdCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21OZWdhdGl2ZVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ25lZ2F0aXZlUHJvbXB0J10sIGZyb21OZWdhdGl2ZVByb21wdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OdW1iZXJPZkltYWdlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ251bWJlck9mSW1hZ2VzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU51bWJlck9mSW1hZ2VzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2FtcGxlQ291bnQnXSwgZnJvbU51bWJlck9mSW1hZ2VzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFzcGVjdFJhdGlvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhc3BlY3RSYXRpbyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUFzcGVjdFJhdGlvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnYXNwZWN0UmF0aW8nXSwgZnJvbUFzcGVjdFJhdGlvKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUd1aWRhbmNlU2NhbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdndWlkYW5jZVNjYWxlJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUd1aWRhbmNlU2NhbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdndWlkYW5jZVNjYWxlJ10sIGZyb21HdWlkYW5jZVNjYWxlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TZWVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2VlZCddLCBmcm9tU2VlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TYWZldHlGaWx0ZXJMZXZlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eUZpbHRlckxldmVsJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNhZmV0eUZpbHRlckxldmVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2FmZXR5U2V0dGluZyddLCBmcm9tU2FmZXR5RmlsdGVyTGV2ZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGVyc29uR2VuZXJhdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3BlcnNvbkdlbmVyYXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGVyc29uR2VuZXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3BlcnNvbkdlbmVyYXRpb24nXSwgZnJvbVBlcnNvbkdlbmVyYXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbmNsdWRlU2FmZXR5QXR0cmlidXRlcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbmNsdWRlU2FmZXR5QXR0cmlidXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2luY2x1ZGVTYWZldHlBdHRyaWJ1dGVzJ10sIGZyb21JbmNsdWRlU2FmZXR5QXR0cmlidXRlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmNsdWRlUmFpUmVhc29uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5jbHVkZVJhaVJlYXNvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbmNsdWRlUmFpUmVhc29uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnaW5jbHVkZVJhaVJlYXNvbiddLCBmcm9tSW5jbHVkZVJhaVJlYXNvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYW5ndWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFuZ3VhZ2UnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MYW5ndWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2xhbmd1YWdlJ10sIGZyb21MYW5ndWFnZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRNaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dE1pbWVUeXBlJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dE1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnb3V0cHV0T3B0aW9ucycsICdtaW1lVHlwZSddLCBmcm9tT3V0cHV0TWltZVR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ291dHB1dE9wdGlvbnMnLCAnY29tcHJlc3Npb25RdWFsaXR5J10sIGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQWRkV2F0ZXJtYXJrID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhZGRXYXRlcm1hcmsnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21BZGRXYXRlcm1hcmsgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdhZGRXYXRlcm1hcmsnXSwgZnJvbUFkZFdhdGVybWFyayk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmhhbmNlUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZW5oYW5jZVByb21wdCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FbmhhbmNlUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnZW5oYW5jZVByb21wdCddLCBmcm9tRW5oYW5jZVByb21wdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlSW1hZ2VzUGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb21wdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJvbXB0J10pO1xuICAgIGlmIChmcm9tUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ3Byb21wdCddLCBmcm9tUHJvbXB0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGdlbmVyYXRlSW1hZ2VzQ29uZmlnVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tQ29uZmlnLCB0b09iamVjdCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZXRNb2RlbFBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGZyb21Db25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb3VudFRva2Vuc0NvbmZpZ1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzeXN0ZW1JbnN0cnVjdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TeXN0ZW1JbnN0cnVjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzeXN0ZW1JbnN0cnVjdGlvbiddLCBjb250ZW50VG9WZXJ0ZXgoYXBpQ2xpZW50LCB0Q29udGVudChhcGlDbGllbnQsIGZyb21TeXN0ZW1JbnN0cnVjdGlvbikpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29scyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xzICE9IG51bGwpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZnJvbVRvb2xzKSkge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3Rvb2xzJ10sIGZyb21Ub29scy5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9vbFRvVmVydGV4KGFwaUNsaWVudCwgaXRlbSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndG9vbHMnXSwgZnJvbVRvb2xzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmcm9tR2VuZXJhdGlvbkNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dlbmVyYXRpb25Db25maWcnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tR2VuZXJhdGlvbkNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydnZW5lcmF0aW9uQ29uZmlnJ10sIGZyb21HZW5lcmF0aW9uQ29uZmlnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY291bnRUb2tlbnNQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnRzJ10pO1xuICAgIGlmIChmcm9tQ29udGVudHMgIT0gbnVsbCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmcm9tQ29udGVudHMpKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb250ZW50cyddLCB0Q29udGVudHMoYXBpQ2xpZW50LCB0Q29udGVudHMoYXBpQ2xpZW50LCBmcm9tQ29udGVudHMpLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50VG9WZXJ0ZXgoYXBpQ2xpZW50LCBpdGVtKTtcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb250ZW50cyddLCB0Q29udGVudHMoYXBpQ2xpZW50LCBmcm9tQ29udGVudHMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgY291bnRUb2tlbnNDb25maWdUb1ZlcnRleChhcGlDbGllbnQsIGZyb21Db25maWcsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVUb2tlbnNQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnRzJ10pO1xuICAgIGlmIChmcm9tQ29udGVudHMgIT0gbnVsbCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmcm9tQ29udGVudHMpKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb250ZW50cyddLCB0Q29udGVudHMoYXBpQ2xpZW50LCB0Q29udGVudHMoYXBpQ2xpZW50LCBmcm9tQ29udGVudHMpLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50VG9WZXJ0ZXgoYXBpQ2xpZW50LCBpdGVtKTtcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb250ZW50cyddLCB0Q29udGVudHMoYXBpQ2xpZW50LCBmcm9tQ29udGVudHMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgZnJvbUNvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGltYWdlVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnY3NVcmknXSk7XG4gICAgaWYgKGZyb21HY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnY3NVcmknXSwgZnJvbUdjc1VyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZUJ5dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZUJ5dGVzJ10pO1xuICAgIGlmIChmcm9tSW1hZ2VCeXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2J5dGVzQmFzZTY0RW5jb2RlZCddLCB0Qnl0ZXMoYXBpQ2xpZW50LCBmcm9tSW1hZ2VCeXRlcykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc0NvbmZpZ1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTnVtYmVyT2ZWaWRlb3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdudW1iZXJPZlZpZGVvcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21OdW1iZXJPZlZpZGVvcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhbXBsZUNvdW50J10sIGZyb21OdW1iZXJPZlZpZGVvcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRHY3NVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ291dHB1dEdjc1VyaSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dEdjc1VyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3N0b3JhZ2VVcmknXSwgZnJvbU91dHB1dEdjc1VyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GcHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZwcyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUZwcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2ZwcyddLCBmcm9tRnBzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUR1cmF0aW9uU2Vjb25kcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2R1cmF0aW9uU2Vjb25kcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21EdXJhdGlvblNlY29uZHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdkdXJhdGlvblNlY29uZHMnXSwgZnJvbUR1cmF0aW9uU2Vjb25kcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZWVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZWVkJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2VlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NlZWQnXSwgZnJvbVNlZWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXNwZWN0UmF0aW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FzcGVjdFJhdGlvJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQXNwZWN0UmF0aW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdhc3BlY3RSYXRpbyddLCBmcm9tQXNwZWN0UmF0aW8pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzb2x1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzb2x1dGlvbiddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVJlc29sdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdyZXNvbHV0aW9uJ10sIGZyb21SZXNvbHV0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBlcnNvbkdlbmVyYXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwZXJzb25HZW5lcmF0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBlcnNvbkdlbmVyYXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdwZXJzb25HZW5lcmF0aW9uJ10sIGZyb21QZXJzb25HZW5lcmF0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVB1YnN1YlRvcGljID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwdWJzdWJUb3BpYyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVB1YnN1YlRvcGljICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAncHVic3ViVG9waWMnXSwgZnJvbVB1YnN1YlRvcGljKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5lZ2F0aXZlUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmVnYXRpdmVQcm9tcHQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTmVnYXRpdmVQcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICduZWdhdGl2ZVByb21wdCddLCBmcm9tTmVnYXRpdmVQcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5oYW5jZVByb21wdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2VuaGFuY2VQcm9tcHQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRW5oYW5jZVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2VuaGFuY2VQcm9tcHQnXSwgZnJvbUVuaGFuY2VQcm9tcHQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc1BhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Byb21wdCddKTtcbiAgICBpZiAoZnJvbVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdwcm9tcHQnXSwgZnJvbVByb21wdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2UnXSk7XG4gICAgaWYgKGZyb21JbWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdpbWFnZSddLCBpbWFnZVRvVmVydGV4KGFwaUNsaWVudCwgZnJvbUltYWdlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCBnZW5lcmF0ZVZpZGVvc0NvbmZpZ1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcGFydEZyb21NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UaG91Z2h0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aG91Z2h0J10pO1xuICAgIGlmIChmcm9tVGhvdWdodCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHQnXSwgZnJvbVRob3VnaHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb25SZXN1bHQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb25SZXN1bHQnXSwgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhlY3V0YWJsZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdleGVjdXRhYmxlQ29kZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FeGVjdXRhYmxlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4ZWN1dGFibGVDb2RlJ10sIGZyb21FeGVjdXRhYmxlQ29kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZURhdGEnXSk7XG4gICAgaWYgKGZyb21GaWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVEYXRhJ10sIGZyb21GaWxlRGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvbkNhbGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uQ2FsbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddLCBmcm9tRnVuY3Rpb25DYWxsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvblJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvblJlc3BvbnNlJ10sIGZyb21GdW5jdGlvblJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlubGluZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lubGluZURhdGEnXSk7XG4gICAgaWYgKGZyb21JbmxpbmVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5saW5lRGF0YSddLCBmcm9tSW5saW5lRGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZXh0J10pO1xuICAgIGlmIChmcm9tVGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RleHQnXSwgZnJvbVRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb250ZW50RnJvbU1sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhcnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJ0cyddKTtcbiAgICBpZiAoZnJvbVBhcnRzICE9IG51bGwpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZnJvbVBhcnRzKSkge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFydHMnXSwgZnJvbVBhcnRzLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0RnJvbU1sZGV2KGFwaUNsaWVudCwgaXRlbSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJ0cyddLCBmcm9tUGFydHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGZyb21Sb2xlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyb2xlJ10pO1xuICAgIGlmIChmcm9tUm9sZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JvbGUnXSwgZnJvbVJvbGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjaXRhdGlvbk1ldGFkYXRhRnJvbU1sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNpdGF0aW9ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY2l0YXRpb25Tb3VyY2VzJ10pO1xuICAgIGlmIChmcm9tQ2l0YXRpb25zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2l0YXRpb25zJ10sIGZyb21DaXRhdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjYW5kaWRhdGVGcm9tTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ29udGVudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudCddKTtcbiAgICBpZiAoZnJvbUNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb250ZW50J10sIGNvbnRlbnRGcm9tTWxkZXYoYXBpQ2xpZW50LCBmcm9tQ29udGVudCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2l0YXRpb25NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NpdGF0aW9uTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2l0YXRpb25NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NpdGF0aW9uTWV0YWRhdGEnXSwgY2l0YXRpb25NZXRhZGF0YUZyb21NbGRldihhcGlDbGllbnQsIGZyb21DaXRhdGlvbk1ldGFkYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b2tlbkNvdW50J10pO1xuICAgIGlmIChmcm9tVG9rZW5Db3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rva2VuQ291bnQnXSwgZnJvbVRva2VuQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmluaXNoUmVhc29uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaW5pc2hSZWFzb24nXSk7XG4gICAgaWYgKGZyb21GaW5pc2hSZWFzb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaW5pc2hSZWFzb24nXSwgZnJvbUZpbmlzaFJlYXNvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BdmdMb2dwcm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXZnTG9ncHJvYnMnXSk7XG4gICAgaWYgKGZyb21BdmdMb2dwcm9icyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2F2Z0xvZ3Byb2JzJ10sIGZyb21BdmdMb2dwcm9icyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hcm91bmRpbmdNZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dyb3VuZGluZ01ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdyb3VuZGluZ01ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ3JvdW5kaW5nTWV0YWRhdGEnXSwgZnJvbUdyb3VuZGluZ01ldGFkYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUluZGV4ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmRleCddKTtcbiAgICBpZiAoZnJvbUluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5kZXgnXSwgZnJvbUluZGV4KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxvZ3Byb2JzUmVzdWx0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbG9ncHJvYnNSZXN1bHQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTG9ncHJvYnNSZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsb2dwcm9ic1Jlc3VsdCddLCBmcm9tTG9ncHJvYnNSZXN1bHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2FmZXR5UmF0aW5ncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eVJhdGluZ3MnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2FmZXR5UmF0aW5ncyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NhZmV0eVJhdGluZ3MnXSwgZnJvbVNhZmV0eVJhdGluZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUNvbnRlbnRSZXNwb25zZUZyb21NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21DYW5kaWRhdGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjYW5kaWRhdGVzJ10pO1xuICAgIGlmIChmcm9tQ2FuZGlkYXRlcyAhPSBudWxsKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZyb21DYW5kaWRhdGVzKSkge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2FuZGlkYXRlcyddLCBmcm9tQ2FuZGlkYXRlcy5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FuZGlkYXRlRnJvbU1sZGV2KGFwaUNsaWVudCwgaXRlbSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYW5kaWRhdGVzJ10sIGZyb21DYW5kaWRhdGVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmcm9tTW9kZWxWZXJzaW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbFZlcnNpb24nXSk7XG4gICAgaWYgKGZyb21Nb2RlbFZlcnNpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbFZlcnNpb24nXSwgZnJvbU1vZGVsVmVyc2lvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9tcHRGZWVkYmFjayA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Byb21wdEZlZWRiYWNrJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByb21wdEZlZWRiYWNrICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJvbXB0RmVlZGJhY2snXSwgZnJvbVByb21wdEZlZWRiYWNrKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVzYWdlTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd1c2FnZU1ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVVzYWdlTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1c2FnZU1ldGFkYXRhJ10sIGZyb21Vc2FnZU1ldGFkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udGVudEVtYmVkZGluZ0Zyb21NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21WYWx1ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZhbHVlcyddKTtcbiAgICBpZiAoZnJvbVZhbHVlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZhbHVlcyddLCBmcm9tVmFsdWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZW1iZWRDb250ZW50TWV0YWRhdGFGcm9tTWxkZXYoKSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBlbWJlZENvbnRlbnRSZXNwb25zZUZyb21NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21FbWJlZGRpbmdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbWJlZGRpbmdzJ10pO1xuICAgIGlmIChmcm9tRW1iZWRkaW5ncyAhPSBudWxsKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZyb21FbWJlZGRpbmdzKSkge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW1iZWRkaW5ncyddLCBmcm9tRW1iZWRkaW5ncy5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudEVtYmVkZGluZ0Zyb21NbGRldihhcGlDbGllbnQsIGl0ZW0pO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW1iZWRkaW5ncyddLCBmcm9tRW1iZWRkaW5ncyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZnJvbU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRhZGF0YSddKTtcbiAgICBpZiAoZnJvbU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWV0YWRhdGEnXSwgZW1iZWRDb250ZW50TWV0YWRhdGFGcm9tTWxkZXYoKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGltYWdlRnJvbU1sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUltYWdlQnl0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdieXRlc0Jhc2U2NEVuY29kZWQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tSW1hZ2VCeXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ltYWdlQnl0ZXMnXSwgdEJ5dGVzKGFwaUNsaWVudCwgZnJvbUltYWdlQnl0ZXMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc2FmZXR5QXR0cmlidXRlc0Zyb21NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21DYXRlZ29yaWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2FmZXR5QXR0cmlidXRlcycsXG4gICAgICAgICdjYXRlZ29yaWVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNhdGVnb3JpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYXRlZ29yaWVzJ10sIGZyb21DYXRlZ29yaWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNjb3JlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eUF0dHJpYnV0ZXMnLFxuICAgICAgICAnc2NvcmVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNjb3JlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Njb3JlcyddLCBmcm9tU2NvcmVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbnRlbnRUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb250ZW50VHlwZSddKTtcbiAgICBpZiAoZnJvbUNvbnRlbnRUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29udGVudFR5cGUnXSwgZnJvbUNvbnRlbnRUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVkSW1hZ2VGcm9tTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ19zZWxmJ10pO1xuICAgIGlmIChmcm9tSW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbWFnZSddLCBpbWFnZUZyb21NbGRldihhcGlDbGllbnQsIGZyb21JbWFnZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmFpRmlsdGVyZWRSZWFzb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyYWlGaWx0ZXJlZFJlYXNvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SYWlGaWx0ZXJlZFJlYXNvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JhaUZpbHRlcmVkUmVhc29uJ10sIGZyb21SYWlGaWx0ZXJlZFJlYXNvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TYWZldHlBdHRyaWJ1dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydfc2VsZiddKTtcbiAgICBpZiAoZnJvbVNhZmV0eUF0dHJpYnV0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzYWZldHlBdHRyaWJ1dGVzJ10sIHNhZmV0eUF0dHJpYnV0ZXNGcm9tTWxkZXYoYXBpQ2xpZW50LCBmcm9tU2FmZXR5QXR0cmlidXRlcykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUltYWdlc1Jlc3BvbnNlRnJvbU1sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUdlbmVyYXRlZEltYWdlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZWRpY3Rpb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdlbmVyYXRlZEltYWdlcyAhPSBudWxsKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZyb21HZW5lcmF0ZWRJbWFnZXMpKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnZW5lcmF0ZWRJbWFnZXMnXSwgZnJvbUdlbmVyYXRlZEltYWdlcy5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVkSW1hZ2VGcm9tTWxkZXYoYXBpQ2xpZW50LCBpdGVtKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dlbmVyYXRlZEltYWdlcyddLCBmcm9tR2VuZXJhdGVkSW1hZ2VzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmcm9tUG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVBvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Bvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlcyddLCBzYWZldHlBdHRyaWJ1dGVzRnJvbU1sZGV2KGFwaUNsaWVudCwgZnJvbVBvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlcykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0dW5lZE1vZGVsSW5mb0Zyb21NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21CYXNlTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Jhc2VNb2RlbCddKTtcbiAgICBpZiAoZnJvbUJhc2VNb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Jhc2VNb2RlbCddLCBmcm9tQmFzZU1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNyZWF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21DcmVhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY3JlYXRlVGltZSddLCBmcm9tQ3JlYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcGRhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cGRhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tVXBkYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSwgZnJvbVVwZGF0ZVRpbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBtb2RlbEZyb21NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10pO1xuICAgIGlmIChmcm9tRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXNjcmlwdGlvbiddLCBmcm9tRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmVyc2lvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmVyc2lvbiddKTtcbiAgICBpZiAoZnJvbVZlcnNpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2ZXJzaW9uJ10sIGZyb21WZXJzaW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVR1bmVkTW9kZWxJbmZvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydfc2VsZiddKTtcbiAgICBpZiAoZnJvbVR1bmVkTW9kZWxJbmZvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHVuZWRNb2RlbEluZm8nXSwgdHVuZWRNb2RlbEluZm9Gcm9tTWxkZXYoYXBpQ2xpZW50LCBmcm9tVHVuZWRNb2RlbEluZm8pKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlucHV0VG9rZW5MaW1pdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2lucHV0VG9rZW5MaW1pdCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21JbnB1dFRva2VuTGltaXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnB1dFRva2VuTGltaXQnXSwgZnJvbUlucHV0VG9rZW5MaW1pdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRUb2tlbkxpbWl0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0VG9rZW5MaW1pdCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21PdXRwdXRUb2tlbkxpbWl0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnb3V0cHV0VG9rZW5MaW1pdCddLCBmcm9tT3V0cHV0VG9rZW5MaW1pdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdXBwb3J0ZWRBY3Rpb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3VwcG9ydGVkR2VuZXJhdGlvbk1ldGhvZHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU3VwcG9ydGVkQWN0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N1cHBvcnRlZEFjdGlvbnMnXSwgZnJvbVN1cHBvcnRlZEFjdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb3VudFRva2Vuc1Jlc3BvbnNlRnJvbU1sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVRvdGFsVG9rZW5zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3RhbFRva2VucyddKTtcbiAgICBpZiAoZnJvbVRvdGFsVG9rZW5zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG90YWxUb2tlbnMnXSwgZnJvbVRvdGFsVG9rZW5zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhY2hlZENvbnRlbnRUb2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2FjaGVkQ29udGVudFRva2VuQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2FjaGVkQ29udGVudFRva2VuQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYWNoZWRDb250ZW50VG9rZW5Db3VudCddLCBmcm9tQ2FjaGVkQ29udGVudFRva2VuQ291bnQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB2aWRlb0Zyb21NbGRldiQxKGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmlkZW8nLCAndXJpJ10pO1xuICAgIGlmIChmcm9tVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJpJ10sIGZyb21VcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmlkZW9CeXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ZpZGVvJyxcbiAgICAgICAgJ2VuY29kZWRWaWRlbycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21WaWRlb0J5dGVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW9CeXRlcyddLCB0Qnl0ZXMoYXBpQ2xpZW50LCBmcm9tVmlkZW9CeXRlcykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuY29kaW5nJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZWRWaWRlb0Zyb21NbGRldiQxKGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZpZGVvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydfc2VsZiddKTtcbiAgICBpZiAoZnJvbVZpZGVvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW8nXSwgdmlkZW9Gcm9tTWxkZXYkMShhcGlDbGllbnQsIGZyb21WaWRlbykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc1Jlc3BvbnNlRnJvbU1sZGV2JDEoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2VuZXJhdGVkVmlkZW9zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ2VuZXJhdGVkU2FtcGxlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21HZW5lcmF0ZWRWaWRlb3MgIT0gbnVsbCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmcm9tR2VuZXJhdGVkVmlkZW9zKSkge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2VuZXJhdGVkVmlkZW9zJ10sIGZyb21HZW5lcmF0ZWRWaWRlb3MubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlZFZpZGVvRnJvbU1sZGV2JDEoYXBpQ2xpZW50LCBpdGVtKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dlbmVyYXRlZFZpZGVvcyddLCBmcm9tR2VuZXJhdGVkVmlkZW9zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmcm9tUmFpTWVkaWFGaWx0ZXJlZENvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmFpTWVkaWFGaWx0ZXJlZENvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJhaU1lZGlhRmlsdGVyZWRDb3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JhaU1lZGlhRmlsdGVyZWRDb3VudCddLCBmcm9tUmFpTWVkaWFGaWx0ZXJlZENvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJhaU1lZGlhRmlsdGVyZWRSZWFzb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyYWlNZWRpYUZpbHRlcmVkUmVhc29ucyddLCBmcm9tUmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc09wZXJhdGlvbkZyb21NbGRldiQxKGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWV0YWRhdGEnXSk7XG4gICAgaWYgKGZyb21NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21ldGFkYXRhJ10sIGZyb21NZXRhZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Eb25lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkb25lJ10pO1xuICAgIGlmIChmcm9tRG9uZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RvbmUnXSwgZnJvbURvbmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXJyb3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vycm9yJ10pO1xuICAgIGlmIChmcm9tRXJyb3IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlcnJvciddLCBmcm9tRXJyb3IpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZScsXG4gICAgICAgICdnZW5lcmF0ZVZpZGVvUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZSddLCBnZW5lcmF0ZVZpZGVvc1Jlc3BvbnNlRnJvbU1sZGV2JDEoYXBpQ2xpZW50LCBmcm9tUmVzcG9uc2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcGFydEZyb21WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVmlkZW9NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ZpZGVvTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVmlkZW9NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvTWV0YWRhdGEnXSwgZnJvbVZpZGVvTWV0YWRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGhvdWdodCddKTtcbiAgICBpZiAoZnJvbVRob3VnaHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0J10sIGZyb21UaG91Z2h0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uUmVzdWx0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uUmVzdWx0J10sIGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4ZWN1dGFibGVDb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZXhlY3V0YWJsZUNvZGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRXhlY3V0YWJsZUNvZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleGVjdXRhYmxlQ29kZSddLCBmcm9tRXhlY3V0YWJsZUNvZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVEYXRhJ10pO1xuICAgIGlmIChmcm9tRmlsZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlRGF0YSddLCBmcm9tRmlsZURhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25DYWxsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmdW5jdGlvbkNhbGwnXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkNhbGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkNhbGwnXSwgZnJvbUZ1bmN0aW9uQ2FsbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvblJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25SZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvblJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25SZXNwb25zZSddLCBmcm9tRnVuY3Rpb25SZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmxpbmVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmxpbmVEYXRhJ10pO1xuICAgIGlmIChmcm9tSW5saW5lRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lubGluZURhdGEnXSwgZnJvbUlubGluZURhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGV4dCddKTtcbiAgICBpZiAoZnJvbVRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZXh0J10sIGZyb21UZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udGVudEZyb21WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFydHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcnRzJ10pO1xuICAgIGlmIChmcm9tUGFydHMgIT0gbnVsbCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmcm9tUGFydHMpKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJ0cyddLCBmcm9tUGFydHMubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRGcm9tVmVydGV4KGFwaUNsaWVudCwgaXRlbSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJ0cyddLCBmcm9tUGFydHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGZyb21Sb2xlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyb2xlJ10pO1xuICAgIGlmIChmcm9tUm9sZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JvbGUnXSwgZnJvbVJvbGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjaXRhdGlvbk1ldGFkYXRhRnJvbVZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21DaXRhdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NpdGF0aW9ucyddKTtcbiAgICBpZiAoZnJvbUNpdGF0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NpdGF0aW9ucyddLCBmcm9tQ2l0YXRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY2FuZGlkYXRlRnJvbVZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db250ZW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb250ZW50J10pO1xuICAgIGlmIChmcm9tQ29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbnRlbnQnXSwgY29udGVudEZyb21WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tQ29udGVudCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2l0YXRpb25NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NpdGF0aW9uTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2l0YXRpb25NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NpdGF0aW9uTWV0YWRhdGEnXSwgY2l0YXRpb25NZXRhZGF0YUZyb21WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tQ2l0YXRpb25NZXRhZGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmluaXNoTWVzc2FnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2ZpbmlzaE1lc3NhZ2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRmluaXNoTWVzc2FnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbmlzaE1lc3NhZ2UnXSwgZnJvbUZpbmlzaE1lc3NhZ2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmluaXNoUmVhc29uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaW5pc2hSZWFzb24nXSk7XG4gICAgaWYgKGZyb21GaW5pc2hSZWFzb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaW5pc2hSZWFzb24nXSwgZnJvbUZpbmlzaFJlYXNvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BdmdMb2dwcm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXZnTG9ncHJvYnMnXSk7XG4gICAgaWYgKGZyb21BdmdMb2dwcm9icyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2F2Z0xvZ3Byb2JzJ10sIGZyb21BdmdMb2dwcm9icyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hcm91bmRpbmdNZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dyb3VuZGluZ01ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdyb3VuZGluZ01ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ3JvdW5kaW5nTWV0YWRhdGEnXSwgZnJvbUdyb3VuZGluZ01ldGFkYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUluZGV4ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmRleCddKTtcbiAgICBpZiAoZnJvbUluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5kZXgnXSwgZnJvbUluZGV4KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxvZ3Byb2JzUmVzdWx0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbG9ncHJvYnNSZXN1bHQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTG9ncHJvYnNSZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsb2dwcm9ic1Jlc3VsdCddLCBmcm9tTG9ncHJvYnNSZXN1bHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2FmZXR5UmF0aW5ncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eVJhdGluZ3MnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2FmZXR5UmF0aW5ncyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NhZmV0eVJhdGluZ3MnXSwgZnJvbVNhZmV0eVJhdGluZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUNvbnRlbnRSZXNwb25zZUZyb21WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ2FuZGlkYXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY2FuZGlkYXRlcyddKTtcbiAgICBpZiAoZnJvbUNhbmRpZGF0ZXMgIT0gbnVsbCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmcm9tQ2FuZGlkYXRlcykpIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhbmRpZGF0ZXMnXSwgZnJvbUNhbmRpZGF0ZXMubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZUZyb21WZXJ0ZXgoYXBpQ2xpZW50LCBpdGVtKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhbmRpZGF0ZXMnXSwgZnJvbUNhbmRpZGF0ZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGZyb21DcmVhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjcmVhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tQ3JlYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSwgZnJvbUNyZWF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VJZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzcG9uc2VJZCddKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlSWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZUlkJ10sIGZyb21SZXNwb25zZUlkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1vZGVsVmVyc2lvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWxWZXJzaW9uJ10pO1xuICAgIGlmIChmcm9tTW9kZWxWZXJzaW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWxWZXJzaW9uJ10sIGZyb21Nb2RlbFZlcnNpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvbXB0RmVlZGJhY2sgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcm9tcHRGZWVkYmFjaycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Qcm9tcHRGZWVkYmFjayAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Byb21wdEZlZWRiYWNrJ10sIGZyb21Qcm9tcHRGZWVkYmFjayk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Vc2FnZU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndXNhZ2VNZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Vc2FnZU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXNhZ2VNZXRhZGF0YSddLCBmcm9tVXNhZ2VNZXRhZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbnRlbnRFbWJlZGRpbmdTdGF0aXN0aWNzRnJvbVZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UcnVuY2F0ZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RydW5jYXRlZCddKTtcbiAgICBpZiAoZnJvbVRydW5jYXRlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RydW5jYXRlZCddLCBmcm9tVHJ1bmNhdGVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRva2VuQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rva2VuX2NvdW50J10pO1xuICAgIGlmIChmcm9tVG9rZW5Db3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rva2VuQ291bnQnXSwgZnJvbVRva2VuQ291bnQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb250ZW50RW1iZWRkaW5nRnJvbVZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21WYWx1ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZhbHVlcyddKTtcbiAgICBpZiAoZnJvbVZhbHVlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZhbHVlcyddLCBmcm9tVmFsdWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXRpc3RpY3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0YXRpc3RpY3MnXSk7XG4gICAgaWYgKGZyb21TdGF0aXN0aWNzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhdGlzdGljcyddLCBjb250ZW50RW1iZWRkaW5nU3RhdGlzdGljc0Zyb21WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tU3RhdGlzdGljcykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBlbWJlZENvbnRlbnRNZXRhZGF0YUZyb21WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQmlsbGFibGVDaGFyYWN0ZXJDb3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2JpbGxhYmxlQ2hhcmFjdGVyQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQmlsbGFibGVDaGFyYWN0ZXJDb3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2JpbGxhYmxlQ2hhcmFjdGVyQ291bnQnXSwgZnJvbUJpbGxhYmxlQ2hhcmFjdGVyQ291bnQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBlbWJlZENvbnRlbnRSZXNwb25zZUZyb21WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRW1iZWRkaW5ncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZWRpY3Rpb25zW10nLFxuICAgICAgICAnZW1iZWRkaW5ncycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FbWJlZGRpbmdzICE9IG51bGwpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZnJvbUVtYmVkZGluZ3MpKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbWJlZGRpbmdzJ10sIGZyb21FbWJlZGRpbmdzLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50RW1iZWRkaW5nRnJvbVZlcnRleChhcGlDbGllbnQsIGl0ZW0pO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW1iZWRkaW5ncyddLCBmcm9tRW1iZWRkaW5ncyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZnJvbU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRhZGF0YSddKTtcbiAgICBpZiAoZnJvbU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWV0YWRhdGEnXSwgZW1iZWRDb250ZW50TWV0YWRhdGFGcm9tVmVydGV4KGFwaUNsaWVudCwgZnJvbU1ldGFkYXRhKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGltYWdlRnJvbVZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21HY3NVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2djc1VyaSddKTtcbiAgICBpZiAoZnJvbUdjc1VyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2djc1VyaSddLCBmcm9tR2NzVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUltYWdlQnl0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdieXRlc0Jhc2U2NEVuY29kZWQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tSW1hZ2VCeXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ltYWdlQnl0ZXMnXSwgdEJ5dGVzKGFwaUNsaWVudCwgZnJvbUltYWdlQnl0ZXMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc2FmZXR5QXR0cmlidXRlc0Zyb21WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ2F0ZWdvcmllcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eUF0dHJpYnV0ZXMnLFxuICAgICAgICAnY2F0ZWdvcmllcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DYXRlZ29yaWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2F0ZWdvcmllcyddLCBmcm9tQ2F0ZWdvcmllcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TY29yZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzYWZldHlBdHRyaWJ1dGVzJyxcbiAgICAgICAgJ3Njb3JlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TY29yZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzY29yZXMnXSwgZnJvbVNjb3Jlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZW50VHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudFR5cGUnXSk7XG4gICAgaWYgKGZyb21Db250ZW50VHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbnRlbnRUeXBlJ10sIGZyb21Db250ZW50VHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlZEltYWdlRnJvbVZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21JbWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnX3NlbGYnXSk7XG4gICAgaWYgKGZyb21JbWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ltYWdlJ10sIGltYWdlRnJvbVZlcnRleChhcGlDbGllbnQsIGZyb21JbWFnZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmFpRmlsdGVyZWRSZWFzb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyYWlGaWx0ZXJlZFJlYXNvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SYWlGaWx0ZXJlZFJlYXNvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JhaUZpbHRlcmVkUmVhc29uJ10sIGZyb21SYWlGaWx0ZXJlZFJlYXNvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TYWZldHlBdHRyaWJ1dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydfc2VsZiddKTtcbiAgICBpZiAoZnJvbVNhZmV0eUF0dHJpYnV0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzYWZldHlBdHRyaWJ1dGVzJ10sIHNhZmV0eUF0dHJpYnV0ZXNGcm9tVmVydGV4KGFwaUNsaWVudCwgZnJvbVNhZmV0eUF0dHJpYnV0ZXMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuaGFuY2VkUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9tcHQnXSk7XG4gICAgaWYgKGZyb21FbmhhbmNlZFByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuaGFuY2VkUHJvbXB0J10sIGZyb21FbmhhbmNlZFByb21wdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlSW1hZ2VzUmVzcG9uc2VGcm9tVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUdlbmVyYXRlZEltYWdlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZWRpY3Rpb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdlbmVyYXRlZEltYWdlcyAhPSBudWxsKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZyb21HZW5lcmF0ZWRJbWFnZXMpKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnZW5lcmF0ZWRJbWFnZXMnXSwgZnJvbUdlbmVyYXRlZEltYWdlcy5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVkSW1hZ2VGcm9tVmVydGV4KGFwaUNsaWVudCwgaXRlbSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnZW5lcmF0ZWRJbWFnZXMnXSwgZnJvbUdlbmVyYXRlZEltYWdlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZnJvbVBvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Bvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Qb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMnXSwgc2FmZXR5QXR0cmlidXRlc0Zyb21WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tUG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVuZHBvaW50RnJvbVZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmRwb2ludCddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlcGxveWVkTW9kZWxJZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2RlcGxveWVkTW9kZWxJZCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21EZXBsb3llZE1vZGVsSWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXBsb3llZE1vZGVsSWQnXSwgZnJvbURlcGxveWVkTW9kZWxJZCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHR1bmVkTW9kZWxJbmZvRnJvbVZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21CYXNlTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdsYWJlbHMnLFxuICAgICAgICAnZ29vZ2xlLXZlcnRleC1sbG0tdHVuaW5nLWJhc2UtbW9kZWwtaWQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQmFzZU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYmFzZU1vZGVsJ10sIGZyb21CYXNlTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ3JlYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY3JlYXRlVGltZSddKTtcbiAgICBpZiAoZnJvbUNyZWF0ZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjcmVhdGVUaW1lJ10sIGZyb21DcmVhdGVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVwZGF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21VcGRhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXBkYXRlVGltZSddLCBmcm9tVXBkYXRlVGltZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIG1vZGVsRnJvbVZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10pO1xuICAgIGlmIChmcm9tRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXNjcmlwdGlvbiddLCBmcm9tRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmVyc2lvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmVyc2lvbklkJ10pO1xuICAgIGlmIChmcm9tVmVyc2lvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZlcnNpb24nXSwgZnJvbVZlcnNpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kcG9pbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXBsb3llZE1vZGVscyddKTtcbiAgICBpZiAoZnJvbUVuZHBvaW50cyAhPSBudWxsKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZyb21FbmRwb2ludHMpKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRwb2ludHMnXSwgZnJvbUVuZHBvaW50cy5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kcG9pbnRGcm9tVmVydGV4KGFwaUNsaWVudCwgaXRlbSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRwb2ludHMnXSwgZnJvbUVuZHBvaW50cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZnJvbUxhYmVscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFiZWxzJ10pO1xuICAgIGlmIChmcm9tTGFiZWxzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbGFiZWxzJ10sIGZyb21MYWJlbHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHVuZWRNb2RlbEluZm8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ19zZWxmJ10pO1xuICAgIGlmIChmcm9tVHVuZWRNb2RlbEluZm8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0dW5lZE1vZGVsSW5mbyddLCB0dW5lZE1vZGVsSW5mb0Zyb21WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tVHVuZWRNb2RlbEluZm8pKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY291bnRUb2tlbnNSZXNwb25zZUZyb21WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVG90YWxUb2tlbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvdGFsVG9rZW5zJ10pO1xuICAgIGlmIChmcm9tVG90YWxUb2tlbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3RhbFRva2VucyddLCBmcm9tVG90YWxUb2tlbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb21wdXRlVG9rZW5zUmVzcG9uc2VGcm9tVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVRva2Vuc0luZm8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rva2Vuc0luZm8nXSk7XG4gICAgaWYgKGZyb21Ub2tlbnNJbmZvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9rZW5zSW5mbyddLCBmcm9tVG9rZW5zSW5mbyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZpZGVvRnJvbVZlcnRleCQxKGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ2NzVXJpJ10pO1xuICAgIGlmIChmcm9tVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJpJ10sIGZyb21VcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmlkZW9CeXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2J5dGVzQmFzZTY0RW5jb2RlZCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21WaWRlb0J5dGVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW9CeXRlcyddLCB0Qnl0ZXMoYXBpQ2xpZW50LCBmcm9tVmlkZW9CeXRlcykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZWRWaWRlb0Zyb21WZXJ0ZXgkMShhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21WaWRlbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnX3NlbGYnXSk7XG4gICAgaWYgKGZyb21WaWRlbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvJ10sIHZpZGVvRnJvbVZlcnRleCQxKGFwaUNsaWVudCwgZnJvbVZpZGVvKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVmlkZW9zUmVzcG9uc2VGcm9tVmVydGV4JDEoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2VuZXJhdGVkVmlkZW9zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2aWRlb3MnXSk7XG4gICAgaWYgKGZyb21HZW5lcmF0ZWRWaWRlb3MgIT0gbnVsbCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmcm9tR2VuZXJhdGVkVmlkZW9zKSkge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2VuZXJhdGVkVmlkZW9zJ10sIGZyb21HZW5lcmF0ZWRWaWRlb3MubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlZFZpZGVvRnJvbVZlcnRleCQxKGFwaUNsaWVudCwgaXRlbSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnZW5lcmF0ZWRWaWRlb3MnXSwgZnJvbUdlbmVyYXRlZFZpZGVvcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZnJvbVJhaU1lZGlhRmlsdGVyZWRDb3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JhaU1lZGlhRmlsdGVyZWRDb3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SYWlNZWRpYUZpbHRlcmVkQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyYWlNZWRpYUZpbHRlcmVkQ291bnQnXSwgZnJvbVJhaU1lZGlhRmlsdGVyZWRDb3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SYWlNZWRpYUZpbHRlcmVkUmVhc29ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JhaU1lZGlhRmlsdGVyZWRSZWFzb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJhaU1lZGlhRmlsdGVyZWRSZWFzb25zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMnXSwgZnJvbVJhaU1lZGlhRmlsdGVyZWRSZWFzb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVWaWRlb3NPcGVyYXRpb25Gcm9tVmVydGV4JDEoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRhZGF0YSddKTtcbiAgICBpZiAoZnJvbU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWV0YWRhdGEnXSwgZnJvbU1ldGFkYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURvbmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RvbmUnXSk7XG4gICAgaWYgKGZyb21Eb25lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZG9uZSddLCBmcm9tRG9uZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcnJvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXJyb3InXSk7XG4gICAgaWYgKGZyb21FcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vycm9yJ10sIGZyb21FcnJvcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzcG9uc2UnXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlJ10sIGdlbmVyYXRlVmlkZW9zUmVzcG9uc2VGcm9tVmVydGV4JDEoYXBpQ2xpZW50LCBmcm9tUmVzcG9uc2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jb25zdCBGVU5DVElPTl9SRVNQT05TRV9SRVFVSVJFU19JRCA9ICdGdW5jdGlvblJlc3BvbnNlIHJlcXVlc3QgbXVzdCBoYXZlIGFuIGBpZGAgZmllbGQgZnJvbSB0aGUgcmVzcG9uc2Ugb2YgYSBUb29sQ2FsbC5GdW5jdGlvbmFsQ2FsbHMgaW4gR29vZ2xlIEFJLic7XG4vKipcbiAqIEhhbmRsZXMgaW5jb21pbmcgbWVzc2FnZXMgZnJvbSB0aGUgV2ViU29ja2V0LlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHJlc3BvbnNpYmxlIGZvciBwYXJzaW5nIGluY29taW5nIG1lc3NhZ2VzLCB0cmFuc2Zvcm1pbmcgdGhlbVxuICogaW50byBMaXZlU2VydmVyTWVzc2FnZXMsIGFuZCB0aGVuIGNhbGxpbmcgdGhlIG9ubWVzc2FnZSBjYWxsYmFjay4gTm90ZSB0aGF0XG4gKiB0aGUgZmlyc3QgbWVzc2FnZSB3aGljaCBpcyByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXIgaXMgYSBzZXR1cENvbXBsZXRlXG4gKiBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSBhcGlDbGllbnQgVGhlIEFwaUNsaWVudCBpbnN0YW5jZS5cbiAqIEBwYXJhbSBvbm1lc3NhZ2UgVGhlIHVzZXItcHJvdmlkZWQgb25tZXNzYWdlIGNhbGxiYWNrIChpZiBhbnkpLlxuICogQHBhcmFtIGV2ZW50IFRoZSBNZXNzYWdlRXZlbnQgZnJvbSB0aGUgV2ViU29ja2V0LlxuICovXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVXZWJTb2NrZXRNZXNzYWdlKGFwaUNsaWVudCwgb25tZXNzYWdlLCBldmVudCkge1xuICAgIGxldCBzZXJ2ZXJNZXNzYWdlO1xuICAgIGxldCBkYXRhO1xuICAgIGlmIChldmVudC5kYXRhIGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShhd2FpdCBldmVudC5kYXRhLnRleHQoKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShldmVudC5kYXRhKTtcbiAgICB9XG4gICAgaWYgKGFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgc2VydmVyTWVzc2FnZSA9IGxpdmVTZXJ2ZXJNZXNzYWdlRnJvbVZlcnRleChhcGlDbGllbnQsIGRhdGEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2VydmVyTWVzc2FnZSA9IGxpdmVTZXJ2ZXJNZXNzYWdlRnJvbU1sZGV2KGFwaUNsaWVudCwgZGF0YSk7XG4gICAgfVxuICAgIG9ubWVzc2FnZShzZXJ2ZXJNZXNzYWdlKTtcbn1cbi8qKlxuICAgTGl2ZSBjbGFzcyBlbmNhcHN1bGF0ZXMgdGhlIGNvbmZpZ3VyYXRpb24gZm9yIGxpdmUgaW50ZXJhY3Rpb24gd2l0aCB0aGVcbiAgIEdlbmVyYXRpdmUgTGFuZ3VhZ2UgQVBJLiBJdCBlbWJlZHMgQXBpQ2xpZW50IGZvciBnZW5lcmFsIEFQSSBzZXR0aW5ncy5cblxuICAgQGV4cGVyaW1lbnRhbFxuICAqL1xuY2xhc3MgTGl2ZSB7XG4gICAgY29uc3RydWN0b3IoYXBpQ2xpZW50LCBhdXRoLCB3ZWJTb2NrZXRGYWN0b3J5KSB7XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xuICAgICAgICB0aGlzLmF1dGggPSBhdXRoO1xuICAgICAgICB0aGlzLndlYlNvY2tldEZhY3RvcnkgPSB3ZWJTb2NrZXRGYWN0b3J5O1xuICAgIH1cbiAgICAvKipcbiAgICAgICBFc3RhYmxpc2hlcyBhIGNvbm5lY3Rpb24gdG8gdGhlIHNwZWNpZmllZCBtb2RlbCB3aXRoIHRoZSBnaXZlblxuICAgICAgIGNvbmZpZ3VyYXRpb24gYW5kIHJldHVybnMgYSBTZXNzaW9uIG9iamVjdCByZXByZXNlbnRpbmcgdGhhdCBjb25uZWN0aW9uLlxuICBcbiAgICAgICBAZXhwZXJpbWVudGFsXG4gIFxuICAgICAgIEByZW1hcmtzXG4gIFxuICAgICAgIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgZXN0YWJsaXNoaW5nIGEgY29ubmVjdGlvbiB0byB0aGUgbW9kZWwuXG4gICAgICAgQHJldHVybiBBIGxpdmUgc2Vzc2lvbi5cbiAgXG4gICAgICAgQGV4YW1wbGVcbiAgICAgICBgYGB0c1xuICAgICAgIGxldCBtb2RlbDogc3RyaW5nO1xuICAgICAgIGlmIChHT09HTEVfR0VOQUlfVVNFX1ZFUlRFWEFJKSB7XG4gICAgICAgICBtb2RlbCA9ICdnZW1pbmktMi4wLWZsYXNoLWxpdmUtcHJldmlldy0wNC0wOSc7XG4gICAgICAgfSBlbHNlIHtcbiAgICAgICAgIG1vZGVsID0gJ2dlbWluaS0yLjAtZmxhc2gtbGl2ZS0wMDEnO1xuICAgICAgIH1cbiAgICAgICBjb25zdCBzZXNzaW9uID0gYXdhaXQgYWkubGl2ZS5jb25uZWN0KHtcbiAgICAgICAgIG1vZGVsOiBtb2RlbCxcbiAgICAgICAgIGNvbmZpZzoge1xuICAgICAgICAgICByZXNwb25zZU1vZGFsaXRpZXM6IFtNb2RhbGl0eS5BVURJT10sXG4gICAgICAgICB9LFxuICAgICAgICAgY2FsbGJhY2tzOiB7XG4gICAgICAgICAgIG9ub3BlbjogKCkgPT4ge1xuICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDb25uZWN0ZWQgdG8gdGhlIHNvY2tldC4nKTtcbiAgICAgICAgICAgfSxcbiAgICAgICAgICAgb25tZXNzYWdlOiAoZTogTWVzc2FnZUV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgY29uc29sZS5sb2coJ1JlY2VpdmVkIG1lc3NhZ2UgZnJvbSB0aGUgc2VydmVyOiAlc1xcbicsIGRlYnVnKGUuZGF0YSkpO1xuICAgICAgICAgICB9LFxuICAgICAgICAgICBvbmVycm9yOiAoZTogRXJyb3JFdmVudCkgPT4ge1xuICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdFcnJvciBvY2N1cnJlZDogJXNcXG4nLCBkZWJ1ZyhlLmVycm9yKSk7XG4gICAgICAgICAgIH0sXG4gICAgICAgICAgIG9uY2xvc2U6IChlOiBDbG9zZUV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgY29uc29sZS5sb2coJ0Nvbm5lY3Rpb24gY2xvc2VkLicpO1xuICAgICAgICAgICB9LFxuICAgICAgICAgfSxcbiAgICAgICB9KTtcbiAgICAgICBgYGBcbiAgICAgICovXG4gICAgYXN5bmMgY29ubmVjdChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBjb25zdCB3ZWJzb2NrZXRCYXNlVXJsID0gdGhpcy5hcGlDbGllbnQuZ2V0V2Vic29ja2V0QmFzZVVybCgpO1xuICAgICAgICBjb25zdCBhcGlWZXJzaW9uID0gdGhpcy5hcGlDbGllbnQuZ2V0QXBpVmVyc2lvbigpO1xuICAgICAgICBsZXQgdXJsO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gbWFwVG9IZWFkZXJzKHRoaXMuYXBpQ2xpZW50LmdldERlZmF1bHRIZWFkZXJzKCkpO1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB1cmwgPSBgJHt3ZWJzb2NrZXRCYXNlVXJsfS93cy9nb29nbGUuY2xvdWQuYWlwbGF0Zm9ybS4ke2FwaVZlcnNpb259LkxsbUJpZGlTZXJ2aWNlL0JpZGlHZW5lcmF0ZUNvbnRlbnRgO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5hdXRoLmFkZEF1dGhIZWFkZXJzKGhlYWRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYXBpS2V5ID0gdGhpcy5hcGlDbGllbnQuZ2V0QXBpS2V5KCk7XG4gICAgICAgICAgICB1cmwgPSBgJHt3ZWJzb2NrZXRCYXNlVXJsfS93cy9nb29nbGUuYWkuZ2VuZXJhdGl2ZWxhbmd1YWdlLiR7YXBpVmVyc2lvbn0uR2VuZXJhdGl2ZVNlcnZpY2UuQmlkaUdlbmVyYXRlQ29udGVudD9rZXk9JHthcGlLZXl9YDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb25vcGVuUmVzb2x2ZSA9ICgpID0+IHsgfTtcbiAgICAgICAgY29uc3Qgb25vcGVuUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICBvbm9wZW5SZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHBhcmFtcy5jYWxsYmFja3M7XG4gICAgICAgIGNvbnN0IG9ub3BlbkF3YWl0ZWRDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIChfYSA9IGNhbGxiYWNrcyA9PT0gbnVsbCB8fCBjYWxsYmFja3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vbm9wZW4pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGNhbGxiYWNrcyk7XG4gICAgICAgICAgICBvbm9wZW5SZXNvbHZlKHt9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYXBpQ2xpZW50ID0gdGhpcy5hcGlDbGllbnQ7XG4gICAgICAgIGNvbnN0IHdlYnNvY2tldENhbGxiYWNrcyA9IHtcbiAgICAgICAgICAgIG9ub3Blbjogb25vcGVuQXdhaXRlZENhbGxiYWNrLFxuICAgICAgICAgICAgb25tZXNzYWdlOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB2b2lkIGhhbmRsZVdlYlNvY2tldE1lc3NhZ2UoYXBpQ2xpZW50LCBjYWxsYmFja3Mub25tZXNzYWdlLCBldmVudCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25lcnJvcjogKF9hID0gY2FsbGJhY2tzID09PSBudWxsIHx8IGNhbGxiYWNrcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uZXJyb3IpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25jbG9zZTogKF9iID0gY2FsbGJhY2tzID09PSBudWxsIHx8IGNhbGxiYWNrcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uY2xvc2UpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjb25uID0gdGhpcy53ZWJTb2NrZXRGYWN0b3J5LmNyZWF0ZSh1cmwsIGhlYWRlcnNUb01hcChoZWFkZXJzKSwgd2Vic29ja2V0Q2FsbGJhY2tzKTtcbiAgICAgICAgY29ubi5jb25uZWN0KCk7XG4gICAgICAgIC8vIFdhaXQgZm9yIHRoZSB3ZWJzb2NrZXQgdG8gb3BlbiBiZWZvcmUgc2VuZGluZyByZXF1ZXN0cy5cbiAgICAgICAgYXdhaXQgb25vcGVuUHJvbWlzZTtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTW9kZWwgPSB0TW9kZWwodGhpcy5hcGlDbGllbnQsIHBhcmFtcy5tb2RlbCk7XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkgJiZcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTW9kZWwuc3RhcnRzV2l0aCgncHVibGlzaGVycy8nKSkge1xuICAgICAgICAgICAgY29uc3QgcHJvamVjdCA9IHRoaXMuYXBpQ2xpZW50LmdldFByb2plY3QoKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gdGhpcy5hcGlDbGllbnQuZ2V0TG9jYXRpb24oKTtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTW9kZWwgPVxuICAgICAgICAgICAgICAgIGBwcm9qZWN0cy8ke3Byb2plY3R9L2xvY2F0aW9ucy8ke2xvY2F0aW9ufS9gICsgdHJhbnNmb3JtZWRNb2RlbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2xpZW50TWVzc2FnZSA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpICYmXG4gICAgICAgICAgICAoKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnJlc3BvbnNlTW9kYWxpdGllcykgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gU2V0IGRlZmF1bHQgdG8gQVVESU8gdG8gYWxpZ24gd2l0aCBNTERldiBBUEkuXG4gICAgICAgICAgICBpZiAocGFyYW1zLmNvbmZpZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmNvbmZpZyA9IHsgcmVzcG9uc2VNb2RhbGl0aWVzOiBbZXhwb3J0cy5Nb2RhbGl0eS5BVURJT10gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5jb25maWcucmVzcG9uc2VNb2RhbGl0aWVzID0gW2V4cG9ydHMuTW9kYWxpdHkuQVVESU9dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuZ2VuZXJhdGlvbkNvbmZpZykge1xuICAgICAgICAgICAgLy8gUmFpc2UgZGVwcmVjYXRpb24gd2FybmluZyBmb3IgZ2VuZXJhdGlvbkNvbmZpZy5cbiAgICAgICAgICAgIGNvbnNvbGUud2FybignU2V0dGluZyBgTGl2ZUNvbm5lY3RDb25maWcuZ2VuZXJhdGlvbl9jb25maWdgIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSBzZXQgdGhlIGZpZWxkcyBvbiBgTGl2ZUNvbm5lY3RDb25maWdgIGRpcmVjdGx5LiBUaGlzIHdpbGwgYmVjb21lIGFuIGVycm9yIGluIGEgZnV0dXJlIHZlcnNpb24gKG5vdCBiZWZvcmUgUTMgMjAyNSkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGl2ZUNvbm5lY3RQYXJhbWV0ZXJzID0ge1xuICAgICAgICAgICAgbW9kZWw6IHRyYW5zZm9ybWVkTW9kZWwsXG4gICAgICAgICAgICBjb25maWc6IHBhcmFtcy5jb25maWcsXG4gICAgICAgICAgICBjYWxsYmFja3M6IHBhcmFtcy5jYWxsYmFja3MsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNsaWVudE1lc3NhZ2UgPSBsaXZlQ29ubmVjdFBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgbGl2ZUNvbm5lY3RQYXJhbWV0ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNsaWVudE1lc3NhZ2UgPSBsaXZlQ29ubmVjdFBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBsaXZlQ29ubmVjdFBhcmFtZXRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBjbGllbnRNZXNzYWdlWydjb25maWcnXTtcbiAgICAgICAgY29ubi5zZW5kKEpTT04uc3RyaW5naWZ5KGNsaWVudE1lc3NhZ2UpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTZXNzaW9uKGNvbm4sIHRoaXMuYXBpQ2xpZW50KTtcbiAgICB9XG59XG5jb25zdCBkZWZhdWx0TGl2ZVNlbmRDbGllbnRDb250ZW50UGFyYW1lcnRlcnMgPSB7XG4gICAgdHVybkNvbXBsZXRlOiB0cnVlLFxufTtcbi8qKlxuICAgUmVwcmVzZW50cyBhIGNvbm5lY3Rpb24gdG8gdGhlIEFQSS5cblxuICAgQGV4cGVyaW1lbnRhbFxuICAqL1xuY2xhc3MgU2Vzc2lvbiB7XG4gICAgY29uc3RydWN0b3IoY29ubiwgYXBpQ2xpZW50KSB7XG4gICAgICAgIHRoaXMuY29ubiA9IGNvbm47XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xuICAgIH1cbiAgICB0TGl2ZUNsaWVudENvbnRlbnQoYXBpQ2xpZW50LCBwYXJhbXMpIHtcbiAgICAgICAgaWYgKHBhcmFtcy50dXJucyAhPT0gbnVsbCAmJiBwYXJhbXMudHVybnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IGNvbnRlbnRzID0gW107XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRzID0gdENvbnRlbnRzKGFwaUNsaWVudCwgcGFyYW1zLnR1cm5zKTtcbiAgICAgICAgICAgICAgICBpZiAoYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50cyA9IGNvbnRlbnRzLm1hcCgoaXRlbSkgPT4gY29udGVudFRvVmVydGV4KGFwaUNsaWVudCwgaXRlbSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudHMgPSBjb250ZW50cy5tYXAoKGl0ZW0pID0+IGNvbnRlbnRUb01sZGV2KGFwaUNsaWVudCwgaXRlbSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIGNsaWVudCBjb250ZW50IFwidHVybnNcIiwgdHlwZTogJyR7dHlwZW9mIHBhcmFtcy50dXJuc30nYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNsaWVudENvbnRlbnQ6IHsgdHVybnM6IGNvbnRlbnRzLCB0dXJuQ29tcGxldGU6IHBhcmFtcy50dXJuQ29tcGxldGUgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNsaWVudENvbnRlbnQ6IHsgdHVybkNvbXBsZXRlOiBwYXJhbXMudHVybkNvbXBsZXRlIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIHRMaXZlQ2xpZW50dFRvb2xSZXNwb25zZShhcGlDbGllbnQsIHBhcmFtcykge1xuICAgICAgICBsZXQgZnVuY3Rpb25SZXNwb25zZXMgPSBbXTtcbiAgICAgICAgaWYgKHBhcmFtcy5mdW5jdGlvblJlc3BvbnNlcyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Z1bmN0aW9uUmVzcG9uc2VzIGlzIHJlcXVpcmVkLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShwYXJhbXMuZnVuY3Rpb25SZXNwb25zZXMpKSB7XG4gICAgICAgICAgICBmdW5jdGlvblJlc3BvbnNlcyA9IFtwYXJhbXMuZnVuY3Rpb25SZXNwb25zZXNdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZnVuY3Rpb25SZXNwb25zZXMgPSBwYXJhbXMuZnVuY3Rpb25SZXNwb25zZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZ1bmN0aW9uUmVzcG9uc2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmdW5jdGlvblJlc3BvbnNlcyBpcyByZXF1aXJlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGZ1bmN0aW9uUmVzcG9uc2Ugb2YgZnVuY3Rpb25SZXNwb25zZXMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZnVuY3Rpb25SZXNwb25zZSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAgICAgICBmdW5jdGlvblJlc3BvbnNlID09PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgISgnbmFtZScgaW4gZnVuY3Rpb25SZXNwb25zZSkgfHxcbiAgICAgICAgICAgICAgICAhKCdyZXNwb25zZScgaW4gZnVuY3Rpb25SZXNwb25zZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBwYXJzZSBmdW5jdGlvbiByZXNwb25zZSwgdHlwZSAnJHt0eXBlb2YgZnVuY3Rpb25SZXNwb25zZX0nLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhcGlDbGllbnQuaXNWZXJ0ZXhBSSgpICYmICEoJ2lkJyBpbiBmdW5jdGlvblJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihGVU5DVElPTl9SRVNQT05TRV9SRVFVSVJFU19JRCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2xpZW50TWVzc2FnZSA9IHtcbiAgICAgICAgICAgIHRvb2xSZXNwb25zZTogeyBmdW5jdGlvblJlc3BvbnNlczogZnVuY3Rpb25SZXNwb25zZXMgfSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNsaWVudE1lc3NhZ2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAgU2VuZCBhIG1lc3NhZ2Ugb3ZlciB0aGUgZXN0YWJsaXNoZWQgY29ubmVjdGlvbi5cbiAgXG4gICAgICBAcGFyYW0gcGFyYW1zIC0gQ29udGFpbnMgdHdvICoqb3B0aW9uYWwqKiBwcm9wZXJ0aWVzLCBgdHVybnNgIGFuZFxuICAgICAgICAgIGB0dXJuQ29tcGxldGVgLlxuICBcbiAgICAgICAgLSBgdHVybnNgIHdpbGwgYmUgY29udmVydGVkIHRvIGEgYENvbnRlbnRbXWBcbiAgICAgICAgLSBgdHVybkNvbXBsZXRlOiB0cnVlYCBbZGVmYXVsdF0gaW5kaWNhdGVzIHRoYXQgeW91IGFyZSBkb25lIHNlbmRpbmdcbiAgICAgICAgICBjb250ZW50IGFuZCBleHBlY3QgYSByZXNwb25zZS4gSWYgYHR1cm5Db21wbGV0ZTogZmFsc2VgLCB0aGUgc2VydmVyXG4gICAgICAgICAgd2lsbCB3YWl0IGZvciBhZGRpdGlvbmFsIG1lc3NhZ2VzIGJlZm9yZSBzdGFydGluZyBnZW5lcmF0aW9uLlxuICBcbiAgICAgIEBleHBlcmltZW50YWxcbiAgXG4gICAgICBAcmVtYXJrc1xuICAgICAgVGhlcmUgYXJlIHR3byB3YXlzIHRvIHNlbmQgbWVzc2FnZXMgdG8gdGhlIGxpdmUgQVBJOlxuICAgICAgYHNlbmRDbGllbnRDb250ZW50YCBhbmQgYHNlbmRSZWFsdGltZUlucHV0YC5cbiAgXG4gICAgICBgc2VuZENsaWVudENvbnRlbnRgIG1lc3NhZ2VzIGFyZSBhZGRlZCB0byB0aGUgbW9kZWwgY29udGV4dCAqKmluIG9yZGVyKiouXG4gICAgICBIYXZpbmcgYSBjb252ZXJzYXRpb24gdXNpbmcgYHNlbmRDbGllbnRDb250ZW50YCBtZXNzYWdlcyBpcyByb3VnaGx5XG4gICAgICBlcXVpdmFsZW50IHRvIHVzaW5nIHRoZSBgQ2hhdC5zZW5kTWVzc2FnZVN0cmVhbWAsIGV4Y2VwdCB0aGF0IHRoZSBzdGF0ZSBvZlxuICAgICAgdGhlIGBjaGF0YCBoaXN0b3J5IGlzIHN0b3JlZCBvbiB0aGUgQVBJIHNlcnZlciBpbnN0ZWFkIG9mIGxvY2FsbHkuXG4gIFxuICAgICAgQmVjYXVzZSBvZiBgc2VuZENsaWVudENvbnRlbnRgJ3Mgb3JkZXIgZ3VhcmFudGVlLCB0aGUgbW9kZWwgY2Fubm90IHJlc3BvbnNcbiAgICAgIGFzIHF1aWNrbHkgdG8gYHNlbmRDbGllbnRDb250ZW50YCBtZXNzYWdlcyBhcyB0byBgc2VuZFJlYWx0aW1lSW5wdXRgXG4gICAgICBtZXNzYWdlcy4gVGhpcyBtYWtlcyB0aGUgYmlnZ2VzdCBkaWZmZXJlbmNlIHdoZW4gc2VuZGluZyBvYmplY3RzIHRoYXQgaGF2ZVxuICAgICAgc2lnbmlmaWNhbnQgcHJlcHJvY2Vzc2luZyB0aW1lICh0eXBpY2FsbHkgaW1hZ2VzKS5cbiAgXG4gICAgICBUaGUgYHNlbmRDbGllbnRDb250ZW50YCBtZXNzYWdlIHNlbmRzIGEgYENvbnRlbnRbXWBcbiAgICAgIHdoaWNoIGhhcyBtb3JlIG9wdGlvbnMgdGhhbiB0aGUgYEJsb2JgIHNlbnQgYnkgYHNlbmRSZWFsdGltZUlucHV0YC5cbiAgXG4gICAgICBTbyB0aGUgbWFpbiB1c2UtY2FzZXMgZm9yIGBzZW5kQ2xpZW50Q29udGVudGAgb3ZlciBgc2VuZFJlYWx0aW1lSW5wdXRgIGFyZTpcbiAgXG4gICAgICAtIFNlbmRpbmcgYW55dGhpbmcgdGhhdCBjYW4ndCBiZSByZXByZXNlbnRlZCBhcyBhIGBCbG9iYCAodGV4dCxcbiAgICAgIGBzZW5kQ2xpZW50Q29udGVudCh7dHVybnM9XCJIZWxsbz9cIn1gKSkuXG4gICAgICAtIE1hbmFnaW5nIHR1cm5zIHdoZW4gbm90IHVzaW5nIGF1ZGlvIGlucHV0IGFuZCB2b2ljZSBhY3Rpdml0eSBkZXRlY3Rpb24uXG4gICAgICAgIChgc2VuZENsaWVudENvbnRlbnQoe3R1cm5Db21wbGV0ZTp0cnVlfSlgIG9yIHRoZSBzaG9ydCBmb3JtXG4gICAgICBgc2VuZENsaWVudENvbnRlbnQoKWApXG4gICAgICAtIFByZWZpbGxpbmcgYSBjb252ZXJzYXRpb24gY29udGV4dFxuICAgICAgICBgYGBcbiAgICAgICAgc2VuZENsaWVudENvbnRlbnQoe1xuICAgICAgICAgICAgdHVybnM6IFtcbiAgICAgICAgICAgICAgQ29udGVudCh7cm9sZTp1c2VyLCBwYXJ0czouLi59KSxcbiAgICAgICAgICAgICAgQ29udGVudCh7cm9sZTp1c2VyLCBwYXJ0czouLi59KSxcbiAgICAgICAgICAgICAgLi4uXG4gICAgICAgICAgICBdXG4gICAgICAgIH0pXG4gICAgICAgIGBgYFxuICAgICAgQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHNlbmRDbGllbnRDb250ZW50KHBhcmFtcykge1xuICAgICAgICBwYXJhbXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRMaXZlU2VuZENsaWVudENvbnRlbnRQYXJhbWVydGVycyksIHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IGNsaWVudE1lc3NhZ2UgPSB0aGlzLnRMaXZlQ2xpZW50Q29udGVudCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgdGhpcy5jb25uLnNlbmQoSlNPTi5zdHJpbmdpZnkoY2xpZW50TWVzc2FnZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgIFNlbmQgYSByZWFsdGltZSBtZXNzYWdlIG92ZXIgdGhlIGVzdGFibGlzaGVkIGNvbm5lY3Rpb24uXG4gIFxuICAgICAgQHBhcmFtIHBhcmFtcyAtIENvbnRhaW5zIG9uZSBwcm9wZXJ0eSwgYG1lZGlhYC5cbiAgXG4gICAgICAgIC0gYG1lZGlhYCB3aWxsIGJlIGNvbnZlcnRlZCB0byBhIGBCbG9iYFxuICBcbiAgICAgIEBleHBlcmltZW50YWxcbiAgXG4gICAgICBAcmVtYXJrc1xuICAgICAgVXNlIGBzZW5kUmVhbHRpbWVJbnB1dGAgZm9yIHJlYWx0aW1lIGF1ZGlvIGNodW5rcyBhbmQgdmlkZW8gZnJhbWVzIChpbWFnZXMpLlxuICBcbiAgICAgIFdpdGggYHNlbmRSZWFsdGltZUlucHV0YCB0aGUgYXBpIHdpbGwgcmVzcG9uZCB0byBhdWRpbyBhdXRvbWF0aWNhbGx5XG4gICAgICBiYXNlZCBvbiB2b2ljZSBhY3Rpdml0eSBkZXRlY3Rpb24gKFZBRCkuXG4gIFxuICAgICAgYHNlbmRSZWFsdGltZUlucHV0YCBpcyBvcHRpbWl6ZWQgZm9yIHJlc3BvbnNpdm5lc3MgYXQgdGhlIGV4cGVuc2Ugb2ZcbiAgICAgIGRldGVybWluaXN0aWMgb3JkZXJpbmcgZ3VhcmFudGVlcy4gQXVkaW8gYW5kIHZpZGVvIHRva2VucyBhcmUgdG8gdGhlXG4gICAgICBjb250ZXh0IHdoZW4gdGhleSBiZWNvbWUgYXZhaWxhYmxlLlxuICBcbiAgICAgIE5vdGU6IFRoZSBDYWxsIHNpZ25hdHVyZSBleHBlY3RzIGEgYEJsb2JgIG9iamVjdCwgYnV0IG9ubHkgYSBzdWJzZXRcbiAgICAgIG9mIGF1ZGlvIGFuZCBpbWFnZSBtaW1ldHlwZXMgYXJlIGFsbG93ZWQuXG4gICAgICovXG4gICAgc2VuZFJlYWx0aW1lSW5wdXQocGFyYW1zKSB7XG4gICAgICAgIGxldCBjbGllbnRNZXNzYWdlID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNsaWVudE1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAgJ3JlYWx0aW1lSW5wdXQnOiBsaXZlU2VuZFJlYWx0aW1lSW5wdXRQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2xpZW50TWVzc2FnZSA9IHtcbiAgICAgICAgICAgICAgICAncmVhbHRpbWVJbnB1dCc6IGxpdmVTZW5kUmVhbHRpbWVJbnB1dFBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbm4uc2VuZChKU09OLnN0cmluZ2lmeShjbGllbnRNZXNzYWdlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAgU2VuZCBhIGZ1bmN0aW9uIHJlc3BvbnNlIG1lc3NhZ2Ugb3ZlciB0aGUgZXN0YWJsaXNoZWQgY29ubmVjdGlvbi5cbiAgXG4gICAgICBAcGFyYW0gcGFyYW1zIC0gQ29udGFpbnMgcHJvcGVydHkgYGZ1bmN0aW9uUmVzcG9uc2VzYC5cbiAgXG4gICAgICAgIC0gYGZ1bmN0aW9uUmVzcG9uc2VzYCB3aWxsIGJlIGNvbnZlcnRlZCB0byBhIGBmdW5jdGlvblJlc3BvbnNlc1tdYFxuICBcbiAgICAgIEByZW1hcmtzXG4gICAgICBVc2UgYHNlbmRGdW5jdGlvblJlc3BvbnNlYCB0byByZXBseSB0byBgTGl2ZVNlcnZlclRvb2xDYWxsYCBmcm9tIHRoZSBzZXJ2ZXIuXG4gIFxuICAgICAgVXNlIHtAbGluayB0eXBlcy5MaXZlQ29ubmVjdENvbmZpZyN0b29sc30gdG8gY29uZmlndXJlIHRoZSBjYWxsYWJsZSBmdW5jdGlvbnMuXG4gIFxuICAgICAgQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHNlbmRUb29sUmVzcG9uc2UocGFyYW1zKSB7XG4gICAgICAgIGlmIChwYXJhbXMuZnVuY3Rpb25SZXNwb25zZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb29sIHJlc3BvbnNlIHBhcmFtZXRlcnMgYXJlIHJlcXVpcmVkLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsaWVudE1lc3NhZ2UgPSB0aGlzLnRMaXZlQ2xpZW50dFRvb2xSZXNwb25zZSh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgdGhpcy5jb25uLnNlbmQoSlNPTi5zdHJpbmdpZnkoY2xpZW50TWVzc2FnZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgICBUZXJtaW5hdGVzIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbi5cbiAgXG4gICAgICAgQGV4cGVyaW1lbnRhbFxuICBcbiAgICAgICBAZXhhbXBsZVxuICAgICAgIGBgYHRzXG4gICAgICAgbGV0IG1vZGVsOiBzdHJpbmc7XG4gICAgICAgaWYgKEdPT0dMRV9HRU5BSV9VU0VfVkVSVEVYQUkpIHtcbiAgICAgICAgIG1vZGVsID0gJ2dlbWluaS0yLjAtZmxhc2gtbGl2ZS1wcmV2aWV3LTA0LTA5JztcbiAgICAgICB9IGVsc2Uge1xuICAgICAgICAgbW9kZWwgPSAnZ2VtaW5pLTIuMC1mbGFzaC1saXZlLTAwMSc7XG4gICAgICAgfVxuICAgICAgIGNvbnN0IHNlc3Npb24gPSBhd2FpdCBhaS5saXZlLmNvbm5lY3Qoe1xuICAgICAgICAgbW9kZWw6IG1vZGVsLFxuICAgICAgICAgY29uZmlnOiB7XG4gICAgICAgICAgIHJlc3BvbnNlTW9kYWxpdGllczogW01vZGFsaXR5LkFVRElPXSxcbiAgICAgICAgIH1cbiAgICAgICB9KTtcbiAgXG4gICAgICAgc2Vzc2lvbi5jbG9zZSgpO1xuICAgICAgIGBgYFxuICAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLmNvbm4uY2xvc2UoKTtcbiAgICB9XG59XG4vLyBDb252ZXJ0cyBhbiBoZWFkZXJzIG9iamVjdCB0byBhIFwibWFwXCIgb2JqZWN0IGFzIGV4cGVjdGVkIGJ5IHRoZSBXZWJTb2NrZXRcbi8vIGNvbnN0cnVjdG9yLiBXZSB1c2UgdGhpcyBhcyB0aGUgQXV0aCBpbnRlcmZhY2Ugd29ya3Mgd2l0aCBIZWFkZXJzIG9iamVjdHNcbi8vIHdoaWxlIHRoZSBXZWJTb2NrZXQgY29uc3RydWN0b3IgdGFrZXMgYSBtYXAuXG5mdW5jdGlvbiBoZWFkZXJzVG9NYXAoaGVhZGVycykge1xuICAgIGNvbnN0IGhlYWRlck1hcCA9IHt9O1xuICAgIGhlYWRlcnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICBoZWFkZXJNYXBba2V5XSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiBoZWFkZXJNYXA7XG59XG4vLyBDb252ZXJ0cyBhIFwibWFwXCIgb2JqZWN0IHRvIGEgaGVhZGVycyBvYmplY3QuIFdlIHVzZSB0aGlzIGFzIHRoZSBBdXRoXG4vLyBpbnRlcmZhY2Ugd29ya3Mgd2l0aCBIZWFkZXJzIG9iamVjdHMgd2hpbGUgdGhlIEFQSSBjbGllbnQgZGVmYXVsdCBoZWFkZXJzXG4vLyByZXR1cm5zIGEgbWFwLlxuZnVuY3Rpb24gbWFwVG9IZWFkZXJzKG1hcCkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG1hcCkpIHtcbiAgICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBoZWFkZXJzO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jbGFzcyBNb2RlbHMgZXh0ZW5kcyBCYXNlTW9kdWxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcGlDbGllbnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBhcGlDbGllbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYWtlcyBhbiBBUEkgcmVxdWVzdCB0byBnZW5lcmF0ZSBjb250ZW50IHdpdGggYSBnaXZlbiBtb2RlbC5cbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIHRoZSBgbW9kZWxgIHBhcmFtZXRlciwgc3VwcG9ydGVkIGZvcm1hdHMgZm9yIFZlcnRleCBBSSBBUEkgaW5jbHVkZTpcbiAgICAgICAgICogLSBUaGUgR2VtaW5pIG1vZGVsIElELCBmb3IgZXhhbXBsZTogJ2dlbWluaS0yLjAtZmxhc2gnXG4gICAgICAgICAqIC0gVGhlIGZ1bGwgcmVzb3VyY2UgbmFtZSBzdGFydHMgd2l0aCAncHJvamVjdHMvJywgZm9yIGV4YW1wbGU6XG4gICAgICAgICAqICAncHJvamVjdHMvbXktcHJvamVjdC1pZC9sb2NhdGlvbnMvdXMtY2VudHJhbDEvcHVibGlzaGVycy9nb29nbGUvbW9kZWxzL2dlbWluaS0yLjAtZmxhc2gnXG4gICAgICAgICAqIC0gVGhlIHBhcnRpYWwgcmVzb3VyY2UgbmFtZSB3aXRoICdwdWJsaXNoZXJzLycsIGZvciBleGFtcGxlOlxuICAgICAgICAgKiAgJ3B1Ymxpc2hlcnMvZ29vZ2xlL21vZGVscy9nZW1pbmktMi4wLWZsYXNoJyBvclxuICAgICAgICAgKiAgJ3B1Ymxpc2hlcnMvbWV0YS9tb2RlbHMvbGxhbWEtMy4xLTQwNWItaW5zdHJ1Y3QtbWFhcydcbiAgICAgICAgICogLSBgL2Agc2VwYXJhdGVkIHB1Ymxpc2hlciBhbmQgbW9kZWwgbmFtZSwgZm9yIGV4YW1wbGU6XG4gICAgICAgICAqICdnb29nbGUvZ2VtaW5pLTIuMC1mbGFzaCcgb3IgJ21ldGEvbGxhbWEtMy4xLTQwNWItaW5zdHJ1Y3QtbWFhcydcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIHRoZSBgbW9kZWxgIHBhcmFtZXRlciwgc3VwcG9ydGVkIGZvcm1hdHMgZm9yIEdlbWluaSBBUEkgaW5jbHVkZTpcbiAgICAgICAgICogLSBUaGUgR2VtaW5pIG1vZGVsIElELCBmb3IgZXhhbXBsZTogJ2dlbWluaS0yLjAtZmxhc2gnXG4gICAgICAgICAqIC0gVGhlIG1vZGVsIG5hbWUgc3RhcnRzIHdpdGggJ21vZGVscy8nLCBmb3IgZXhhbXBsZTpcbiAgICAgICAgICogICdtb2RlbHMvZ2VtaW5pLTIuMC1mbGFzaCdcbiAgICAgICAgICogLSBGb3IgdHVuZWQgbW9kZWxzLCB0aGUgbW9kZWwgbmFtZSBzdGFydHMgd2l0aCAndHVuZWRNb2RlbHMvJyxcbiAgICAgICAgICogZm9yIGV4YW1wbGU6XG4gICAgICAgICAqICd0dW5lZE1vZGVscy8xMjM0NTY3ODkwMTIzNDU2Nzg5J1xuICAgICAgICAgKlxuICAgICAgICAgKiBTb21lIG1vZGVscyBzdXBwb3J0IG11bHRpbW9kYWwgaW5wdXQgYW5kIG91dHB1dC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBnZW5lcmF0aW5nIGNvbnRlbnQuXG4gICAgICAgICAqIEByZXR1cm4gVGhlIHJlc3BvbnNlIGZyb20gZ2VuZXJhdGluZyBjb250ZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLm1vZGVscy5nZW5lcmF0ZUNvbnRlbnQoe1xuICAgICAgICAgKiAgIG1vZGVsOiAnZ2VtaW5pLTIuMC1mbGFzaCcsXG4gICAgICAgICAqICAgY29udGVudHM6ICd3aHkgaXMgdGhlIHNreSBibHVlPycsXG4gICAgICAgICAqICAgY29uZmlnOiB7XG4gICAgICAgICAqICAgICBjYW5kaWRhdGVDb3VudDogMixcbiAgICAgICAgICogICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZSk7XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZW5lcmF0ZUNvbnRlbnQgPSBhc3luYyAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZW5lcmF0ZUNvbnRlbnRJbnRlcm5hbChwYXJhbXMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTWFrZXMgYW4gQVBJIHJlcXVlc3QgdG8gZ2VuZXJhdGUgY29udGVudCB3aXRoIGEgZ2l2ZW4gbW9kZWwgYW5kIHlpZWxkcyB0aGVcbiAgICAgICAgICogcmVzcG9uc2UgaW4gY2h1bmtzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgdGhlIGBtb2RlbGAgcGFyYW1ldGVyLCBzdXBwb3J0ZWQgZm9ybWF0cyBmb3IgVmVydGV4IEFJIEFQSSBpbmNsdWRlOlxuICAgICAgICAgKiAtIFRoZSBHZW1pbmkgbW9kZWwgSUQsIGZvciBleGFtcGxlOiAnZ2VtaW5pLTIuMC1mbGFzaCdcbiAgICAgICAgICogLSBUaGUgZnVsbCByZXNvdXJjZSBuYW1lIHN0YXJ0cyB3aXRoICdwcm9qZWN0cy8nLCBmb3IgZXhhbXBsZTpcbiAgICAgICAgICogICdwcm9qZWN0cy9teS1wcm9qZWN0LWlkL2xvY2F0aW9ucy91cy1jZW50cmFsMS9wdWJsaXNoZXJzL2dvb2dsZS9tb2RlbHMvZ2VtaW5pLTIuMC1mbGFzaCdcbiAgICAgICAgICogLSBUaGUgcGFydGlhbCByZXNvdXJjZSBuYW1lIHdpdGggJ3B1Ymxpc2hlcnMvJywgZm9yIGV4YW1wbGU6XG4gICAgICAgICAqICAncHVibGlzaGVycy9nb29nbGUvbW9kZWxzL2dlbWluaS0yLjAtZmxhc2gnIG9yXG4gICAgICAgICAqICAncHVibGlzaGVycy9tZXRhL21vZGVscy9sbGFtYS0zLjEtNDA1Yi1pbnN0cnVjdC1tYWFzJ1xuICAgICAgICAgKiAtIGAvYCBzZXBhcmF0ZWQgcHVibGlzaGVyIGFuZCBtb2RlbCBuYW1lLCBmb3IgZXhhbXBsZTpcbiAgICAgICAgICogJ2dvb2dsZS9nZW1pbmktMi4wLWZsYXNoJyBvciAnbWV0YS9sbGFtYS0zLjEtNDA1Yi1pbnN0cnVjdC1tYWFzJ1xuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgdGhlIGBtb2RlbGAgcGFyYW1ldGVyLCBzdXBwb3J0ZWQgZm9ybWF0cyBmb3IgR2VtaW5pIEFQSSBpbmNsdWRlOlxuICAgICAgICAgKiAtIFRoZSBHZW1pbmkgbW9kZWwgSUQsIGZvciBleGFtcGxlOiAnZ2VtaW5pLTIuMC1mbGFzaCdcbiAgICAgICAgICogLSBUaGUgbW9kZWwgbmFtZSBzdGFydHMgd2l0aCAnbW9kZWxzLycsIGZvciBleGFtcGxlOlxuICAgICAgICAgKiAgJ21vZGVscy9nZW1pbmktMi4wLWZsYXNoJ1xuICAgICAgICAgKiAtIEZvciB0dW5lZCBtb2RlbHMsIHRoZSBtb2RlbCBuYW1lIHN0YXJ0cyB3aXRoICd0dW5lZE1vZGVscy8nLFxuICAgICAgICAgKiBmb3IgZXhhbXBsZTpcbiAgICAgICAgICogICd0dW5lZE1vZGVscy8xMjM0NTY3ODkwMTIzNDU2Nzg5J1xuICAgICAgICAgKlxuICAgICAgICAgKiBTb21lIG1vZGVscyBzdXBwb3J0IG11bHRpbW9kYWwgaW5wdXQgYW5kIG91dHB1dC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBnZW5lcmF0aW5nIGNvbnRlbnQgd2l0aCBzdHJlYW1pbmcgcmVzcG9uc2UuXG4gICAgICAgICAqIEByZXR1cm4gVGhlIHJlc3BvbnNlIGZyb20gZ2VuZXJhdGluZyBjb250ZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLm1vZGVscy5nZW5lcmF0ZUNvbnRlbnRTdHJlYW0oe1xuICAgICAgICAgKiAgIG1vZGVsOiAnZ2VtaW5pLTIuMC1mbGFzaCcsXG4gICAgICAgICAqICAgY29udGVudHM6ICd3aHkgaXMgdGhlIHNreSBibHVlPycsXG4gICAgICAgICAqICAgY29uZmlnOiB7XG4gICAgICAgICAqICAgICBtYXhPdXRwdXRUb2tlbnM6IDIwMCxcbiAgICAgICAgICogICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKiBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHJlc3BvbnNlKSB7XG4gICAgICAgICAqICAgY29uc29sZS5sb2coY2h1bmspO1xuICAgICAgICAgKiB9XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZW5lcmF0ZUNvbnRlbnRTdHJlYW0gPSBhc3luYyAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZW5lcmF0ZUNvbnRlbnRTdHJlYW1JbnRlcm5hbChwYXJhbXMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2VuZXJhdGVzIGFuIGltYWdlIGJhc2VkIG9uIGEgdGV4dCBkZXNjcmlwdGlvbiBhbmQgY29uZmlndXJhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG1vZGVsIC0gVGhlIG1vZGVsIHRvIHVzZS5cbiAgICAgICAgICogQHBhcmFtIHByb21wdCAtIEEgdGV4dCBkZXNjcmlwdGlvbiBvZiB0aGUgaW1hZ2UgdG8gZ2VuZXJhdGUuXG4gICAgICAgICAqIEBwYXJhbSBbY29uZmlnXSAtIFRoZSBjb25maWcgZm9yIGltYWdlIGdlbmVyYXRpb24uXG4gICAgICAgICAqIEByZXR1cm4gVGhlIHJlc3BvbnNlIGZyb20gdGhlIEFQSS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjbGllbnQubW9kZWxzLmdlbmVyYXRlSW1hZ2VzKHtcbiAgICAgICAgICogIG1vZGVsOiAnaW1hZ2VuLTMuMC1nZW5lcmF0ZS0wMDInLFxuICAgICAgICAgKiAgcHJvbXB0OiAnUm9ib3QgaG9sZGluZyBhIHJlZCBza2F0ZWJvYXJkJyxcbiAgICAgICAgICogIGNvbmZpZzoge1xuICAgICAgICAgKiAgICBudW1iZXJPZkltYWdlczogMSxcbiAgICAgICAgICogICAgaW5jbHVkZVJhaVJlYXNvbjogdHJ1ZSxcbiAgICAgICAgICogIH0sXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZT8uZ2VuZXJhdGVkSW1hZ2VzPy5bMF0/LmltYWdlPy5pbWFnZUJ5dGVzKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdlbmVyYXRlSW1hZ2VzID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2VuZXJhdGVJbWFnZXNJbnRlcm5hbChwYXJhbXMpLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGxldCBwb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXM7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2VuZXJhdGVkSW1hZ2VzID0gW107XG4gICAgICAgICAgICAgICAgaWYgKGFwaVJlc3BvbnNlID09PSBudWxsIHx8IGFwaVJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcGlSZXNwb25zZS5nZW5lcmF0ZWRJbWFnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBnZW5lcmF0ZWRJbWFnZSBvZiBhcGlSZXNwb25zZS5nZW5lcmF0ZWRJbWFnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnZW5lcmF0ZWRJbWFnZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChnZW5lcmF0ZWRJbWFnZSA9PT0gbnVsbCB8fCBnZW5lcmF0ZWRJbWFnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ2VuZXJhdGVkSW1hZ2Uuc2FmZXR5QXR0cmlidXRlcykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKF9hID0gZ2VuZXJhdGVkSW1hZ2UgPT09IG51bGwgfHwgZ2VuZXJhdGVkSW1hZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdlbmVyYXRlZEltYWdlLnNhZmV0eUF0dHJpYnV0ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250ZW50VHlwZSkgPT09ICdQb3NpdGl2ZSBQcm9tcHQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzID0gZ2VuZXJhdGVkSW1hZ2UgPT09IG51bGwgfHwgZ2VuZXJhdGVkSW1hZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdlbmVyYXRlZEltYWdlLnNhZmV0eUF0dHJpYnV0ZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZWRJbWFnZXMucHVzaChnZW5lcmF0ZWRJbWFnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIGlmIChwb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZWRJbWFnZXM6IGdlbmVyYXRlZEltYWdlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlczogcG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZWRJbWFnZXM6IGdlbmVyYXRlZEltYWdlcyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIGdlbmVyYXRlQ29udGVudEludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZW5lcmF0ZUNvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OmdlbmVyYXRlQ29udGVudCcsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZ2VuZXJhdGVDb250ZW50UmVzcG9uc2VGcm9tVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IEdlbmVyYXRlQ29udGVudFJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZW5lcmF0ZUNvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06Z2VuZXJhdGVDb250ZW50JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnY29uZmlnJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBnZW5lcmF0ZUNvbnRlbnRSZXNwb25zZUZyb21NbGRldih0aGlzLmFwaUNsaWVudCwgYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2VuZXJhdGVDb250ZW50U3RyZWFtSW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdlbmVyYXRlQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06c3RyZWFtR2VuZXJhdGVDb250ZW50P2FsdD1zc2UnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBjb25zdCBhcGlDbGllbnQgPSB0aGlzLmFwaUNsaWVudDtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXBpQ2xpZW50LnJlcXVlc3RTdHJlYW0oe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKGZ1bmN0aW9uIChhcGlSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBlXzEsIF9iLCBfYztcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9kID0gdHJ1ZSwgYXBpUmVzcG9uc2VfMSA9IF9fYXN5bmNWYWx1ZXMoYXBpUmVzcG9uc2UpLCBhcGlSZXNwb25zZV8xXzE7IGFwaVJlc3BvbnNlXzFfMSA9IHlpZWxkIF9fYXdhaXQoYXBpUmVzcG9uc2VfMS5uZXh0KCkpLCBfYSA9IGFwaVJlc3BvbnNlXzFfMS5kb25lLCAhX2E7IF9kID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jID0gYXBpUmVzcG9uc2VfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBfYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZ2VuZXJhdGVDb250ZW50UmVzcG9uc2VGcm9tVmVydGV4KGFwaUNsaWVudCwgKHlpZWxkIF9fYXdhaXQoY2h1bmsuanNvbigpKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KHR5cGVkUmVzcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2QgJiYgIV9hICYmIChfYiA9IGFwaVJlc3BvbnNlXzEucmV0dXJuKSkgeWllbGQgX19hd2FpdChfYi5jYWxsKGFwaVJlc3BvbnNlXzEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2VuZXJhdGVDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OnN0cmVhbUdlbmVyYXRlQ29udGVudD9hbHQ9c3NlJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnY29uZmlnJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgY29uc3QgYXBpQ2xpZW50ID0gdGhpcy5hcGlDbGllbnQ7XG4gICAgICAgICAgICByZXNwb25zZSA9IGFwaUNsaWVudC5yZXF1ZXN0U3RyZWFtKHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbihmdW5jdGlvbiAoYXBpUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYSwgZV8yLCBfYiwgX2M7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfZCA9IHRydWUsIGFwaVJlc3BvbnNlXzIgPSBfX2FzeW5jVmFsdWVzKGFwaVJlc3BvbnNlKSwgYXBpUmVzcG9uc2VfMl8xOyBhcGlSZXNwb25zZV8yXzEgPSB5aWVsZCBfX2F3YWl0KGFwaVJlc3BvbnNlXzIubmV4dCgpKSwgX2EgPSBhcGlSZXNwb25zZV8yXzEuZG9uZSwgIV9hOyBfZCA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYyA9IGFwaVJlc3BvbnNlXzJfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gX2M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGdlbmVyYXRlQ29udGVudFJlc3BvbnNlRnJvbU1sZGV2KGFwaUNsaWVudCwgKHlpZWxkIF9fYXdhaXQoY2h1bmsuanNvbigpKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KHR5cGVkUmVzcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2QgJiYgIV9hICYmIChfYiA9IGFwaVJlc3BvbnNlXzIucmV0dXJuKSkgeWllbGQgX19hd2FpdChfYi5jYWxsKGFwaVJlc3BvbnNlXzIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyBlbWJlZGRpbmdzIGZvciB0aGUgZ2l2ZW4gY29udGVudHMuIE9ubHkgdGV4dCBpcyBzdXBwb3J0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGVtYmVkZGluZyBjb250ZW50cy5cbiAgICAgKiBAcmV0dXJuIFRoZSByZXNwb25zZSBmcm9tIHRoZSBBUEkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaS5tb2RlbHMuZW1iZWRDb250ZW50KHtcbiAgICAgKiAgbW9kZWw6ICd0ZXh0LWVtYmVkZGluZy0wMDQnLFxuICAgICAqICBjb250ZW50czogW1xuICAgICAqICAgICdXaGF0IGlzIHlvdXIgbmFtZT8nLFxuICAgICAqICAgICdXaGF0IGlzIHlvdXIgZmF2b3JpdGUgY29sb3I/JyxcbiAgICAgKiAgXSxcbiAgICAgKiAgY29uZmlnOiB7XG4gICAgICogICAgb3V0cHV0RGltZW5zaW9uYWxpdHk6IDY0LFxuICAgICAqICB9LFxuICAgICAqIH0pO1xuICAgICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBlbWJlZENvbnRlbnQocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGVtYmVkQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06cHJlZGljdCcsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZW1iZWRDb250ZW50UmVzcG9uc2VGcm9tVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IEVtYmVkQ29udGVudFJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBlbWJlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06YmF0Y2hFbWJlZENvbnRlbnRzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnY29uZmlnJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBlbWJlZENvbnRlbnRSZXNwb25zZUZyb21NbGRldih0aGlzLmFwaUNsaWVudCwgYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBFbWJlZENvbnRlbnRSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGFuIGltYWdlIGJhc2VkIG9uIGEgdGV4dCBkZXNjcmlwdGlvbiBhbmQgY29uZmlndXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgZ2VuZXJhdGluZyBpbWFnZXMuXG4gICAgICogQHJldHVybiBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgQVBJLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkubW9kZWxzLmdlbmVyYXRlSW1hZ2VzKHtcbiAgICAgKiAgbW9kZWw6ICdpbWFnZW4tMy4wLWdlbmVyYXRlLTAwMicsXG4gICAgICogIHByb21wdDogJ1JvYm90IGhvbGRpbmcgYSByZWQgc2thdGVib2FyZCcsXG4gICAgICogIGNvbmZpZzoge1xuICAgICAqICAgIG51bWJlck9mSW1hZ2VzOiAxLFxuICAgICAqICAgIGluY2x1ZGVSYWlSZWFzb246IHRydWUsXG4gICAgICogIH0sXG4gICAgICogfSk7XG4gICAgICogY29uc29sZS5sb2cocmVzcG9uc2U/LmdlbmVyYXRlZEltYWdlcz8uWzBdPy5pbWFnZT8uaW1hZ2VCeXRlcyk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgZ2VuZXJhdGVJbWFnZXNJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2VuZXJhdGVJbWFnZXNQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OnByZWRpY3QnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGdlbmVyYXRlSW1hZ2VzUmVzcG9uc2VGcm9tVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IEdlbmVyYXRlSW1hZ2VzUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdlbmVyYXRlSW1hZ2VzUGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OnByZWRpY3QnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGdlbmVyYXRlSW1hZ2VzUmVzcG9uc2VGcm9tTWxkZXYodGhpcy5hcGlDbGllbnQsIGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgR2VuZXJhdGVJbWFnZXNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBpbmZvcm1hdGlvbiBhYm91dCBhIG1vZGVsIGJ5IG5hbWUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgbW9kZWxJbmZvID0gYXdhaXQgYWkubW9kZWxzLmdldCh7bW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJ30pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGdldChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2V0TW9kZWxQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gbW9kZWxGcm9tVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZXRNb2RlbFBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnY29uZmlnJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IG1vZGVsRnJvbU1sZGV2KHRoaXMuYXBpQ2xpZW50LCBhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb3VudHMgdGhlIG51bWJlciBvZiB0b2tlbnMgaW4gdGhlIGdpdmVuIGNvbnRlbnRzLiBNdWx0aW1vZGFsIGlucHV0IGlzXG4gICAgICogc3VwcG9ydGVkIGZvciBHZW1pbmkgbW9kZWxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBjb3VudGluZyB0b2tlbnMuXG4gICAgICogQHJldHVybiBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgQVBJLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkubW9kZWxzLmNvdW50VG9rZW5zKHtcbiAgICAgKiAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJyxcbiAgICAgKiAgY29udGVudHM6ICdUaGUgcXVpY2sgYnJvd24gZm94IGp1bXBzIG92ZXIgdGhlIGxhenkgZG9nLidcbiAgICAgKiB9KTtcbiAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgY291bnRUb2tlbnMocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNvdW50VG9rZW5zUGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpjb3VudFRva2VucycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gY291bnRUb2tlbnNSZXNwb25zZUZyb21WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgQ291bnRUb2tlbnNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY291bnRUb2tlbnNQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06Y291bnRUb2tlbnMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGNvdW50VG9rZW5zUmVzcG9uc2VGcm9tTWxkZXYodGhpcy5hcGlDbGllbnQsIGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgQ291bnRUb2tlbnNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBsaXN0IG9mIGNvbnRlbnRzLCByZXR1cm5zIGEgY29ycmVzcG9uZGluZyBUb2tlbnNJbmZvIGNvbnRhaW5pbmdcbiAgICAgKiB0aGUgbGlzdCBvZiB0b2tlbnMgYW5kIGxpc3Qgb2YgdG9rZW4gaWRzLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgR2VtaW5pIERldmVsb3BlciBBUEkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGNvbXB1dGluZyB0b2tlbnMuXG4gICAgICogQHJldHVybiBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgQVBJLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkubW9kZWxzLmNvbXB1dGVUb2tlbnMoe1xuICAgICAqICBtb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gnLFxuICAgICAqICBjb250ZW50czogJ1doYXQgaXMgeW91ciBuYW1lPydcbiAgICAgKiB9KTtcbiAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgY29tcHV0ZVRva2VucyhwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNvbXB1dGVUb2tlbnNQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OmNvbXB1dGVUb2tlbnMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGNvbXB1dGVUb2tlbnNSZXNwb25zZUZyb21WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgQ29tcHV0ZVRva2Vuc1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIFZlcnRleCBBSS4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2VuZXJhdGVzIHZpZGVvcyBiYXNlZCBvbiBhIHRleHQgZGVzY3JpcHRpb24gYW5kIGNvbmZpZ3VyYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGdlbmVyYXRpbmcgdmlkZW9zLlxuICAgICAqIEByZXR1cm4gQSBQcm9taXNlPEdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uPiB3aGljaCBhbGxvd3MgeW91IHRvIHRyYWNrIHRoZSBwcm9ncmVzcyBhbmQgZXZlbnR1YWxseSByZXRyaWV2ZSB0aGUgZ2VuZXJhdGVkIHZpZGVvcyB1c2luZyB0aGUgb3BlcmF0aW9ucy5nZXQgbWV0aG9kLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IG9wZXJhdGlvbiA9IGF3YWl0IGFpLm1vZGVscy5nZW5lcmF0ZVZpZGVvcyh7XG4gICAgICogIG1vZGVsOiAndmVvLTIuMC1nZW5lcmF0ZS0wMDEnLFxuICAgICAqICBwcm9tcHQ6ICdBIG5lb24gaG9sb2dyYW0gb2YgYSBjYXQgZHJpdmluZyBhdCB0b3Agc3BlZWQnLFxuICAgICAqICBjb25maWc6IHtcbiAgICAgKiAgICBudW1iZXJPZlZpZGVvczogMVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogd2hpbGUgKCFvcGVyYXRpb24uZG9uZSkge1xuICAgICAqICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDAwKSk7XG4gICAgICogICBvcGVyYXRpb24gPSBhd2FpdCBhaS5vcGVyYXRpb25zLmdldFZpZGVvc09wZXJhdGlvbih7b3BlcmF0aW9uOiBvcGVyYXRpb259KTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvcGVyYXRpb24ucmVzcG9uc2U/LmdlbmVyYXRlZFZpZGVvcz8uWzBdPy52aWRlbz8udXJpKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBnZW5lcmF0ZVZpZGVvcyhwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2VuZXJhdGVWaWRlb3NQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OnByZWRpY3RMb25nUnVubmluZycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZ2VuZXJhdGVWaWRlb3NPcGVyYXRpb25Gcm9tVmVydGV4JDEodGhpcy5hcGlDbGllbnQsIGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdlbmVyYXRlVmlkZW9zUGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OnByZWRpY3RMb25nUnVubmluZycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZ2VuZXJhdGVWaWRlb3NPcGVyYXRpb25Gcm9tTWxkZXYkMSh0aGlzLmFwaUNsaWVudCwgYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmZ1bmN0aW9uIGdldE9wZXJhdGlvblBhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU9wZXJhdGlvbk5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvcGVyYXRpb25OYW1lJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU9wZXJhdGlvbk5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ29wZXJhdGlvbk5hbWUnXSwgZnJvbU9wZXJhdGlvbk5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgZnJvbUNvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdldE9wZXJhdGlvblBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21PcGVyYXRpb25OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3BlcmF0aW9uTmFtZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21PcGVyYXRpb25OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdvcGVyYXRpb25OYW1lJ10sIGZyb21PcGVyYXRpb25OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGZyb21Db25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmZXRjaFByZWRpY3RPcGVyYXRpb25QYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tT3BlcmF0aW9uTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ29wZXJhdGlvbk5hbWUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tT3BlcmF0aW9uTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ29wZXJhdGlvbk5hbWUnXSwgZnJvbU9wZXJhdGlvbk5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzb3VyY2VOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNvdXJjZU5hbWUnXSk7XG4gICAgaWYgKGZyb21SZXNvdXJjZU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ3Jlc291cmNlTmFtZSddLCBmcm9tUmVzb3VyY2VOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGZyb21Db25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB2aWRlb0Zyb21NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21VcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZpZGVvJywgJ3VyaSddKTtcbiAgICBpZiAoZnJvbVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VyaSddLCBmcm9tVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvQnl0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd2aWRlbycsXG4gICAgICAgICdlbmNvZGVkVmlkZW8nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVmlkZW9CeXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvQnl0ZXMnXSwgdEJ5dGVzKGFwaUNsaWVudCwgZnJvbVZpZGVvQnl0ZXMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmNvZGluZyddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVkVmlkZW9Gcm9tTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVmlkZW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ19zZWxmJ10pO1xuICAgIGlmIChmcm9tVmlkZW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlbyddLCB2aWRlb0Zyb21NbGRldihhcGlDbGllbnQsIGZyb21WaWRlbykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc1Jlc3BvbnNlRnJvbU1sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUdlbmVyYXRlZFZpZGVvcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dlbmVyYXRlZFNhbXBsZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR2VuZXJhdGVkVmlkZW9zICE9IG51bGwpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZnJvbUdlbmVyYXRlZFZpZGVvcykpIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dlbmVyYXRlZFZpZGVvcyddLCBmcm9tR2VuZXJhdGVkVmlkZW9zLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZWRWaWRlb0Zyb21NbGRldihhcGlDbGllbnQsIGl0ZW0pO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2VuZXJhdGVkVmlkZW9zJ10sIGZyb21HZW5lcmF0ZWRWaWRlb3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGZyb21SYWlNZWRpYUZpbHRlcmVkQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyYWlNZWRpYUZpbHRlcmVkQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmFpTWVkaWFGaWx0ZXJlZENvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmFpTWVkaWFGaWx0ZXJlZENvdW50J10sIGZyb21SYWlNZWRpYUZpbHRlcmVkQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyYWlNZWRpYUZpbHRlcmVkUmVhc29ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SYWlNZWRpYUZpbHRlcmVkUmVhc29ucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JhaU1lZGlhRmlsdGVyZWRSZWFzb25zJ10sIGZyb21SYWlNZWRpYUZpbHRlcmVkUmVhc29ucyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uRnJvbU1sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWV0YWRhdGEnXSk7XG4gICAgaWYgKGZyb21NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21ldGFkYXRhJ10sIGZyb21NZXRhZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Eb25lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkb25lJ10pO1xuICAgIGlmIChmcm9tRG9uZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RvbmUnXSwgZnJvbURvbmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXJyb3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vycm9yJ10pO1xuICAgIGlmIChmcm9tRXJyb3IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlcnJvciddLCBmcm9tRXJyb3IpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZScsXG4gICAgICAgICdnZW5lcmF0ZVZpZGVvUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZSddLCBnZW5lcmF0ZVZpZGVvc1Jlc3BvbnNlRnJvbU1sZGV2KGFwaUNsaWVudCwgZnJvbVJlc3BvbnNlKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZpZGVvRnJvbVZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21VcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2djc1VyaSddKTtcbiAgICBpZiAoZnJvbVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VyaSddLCBmcm9tVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvQnl0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdieXRlc0Jhc2U2NEVuY29kZWQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVmlkZW9CeXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvQnl0ZXMnXSwgdEJ5dGVzKGFwaUNsaWVudCwgZnJvbVZpZGVvQnl0ZXMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVkVmlkZW9Gcm9tVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZpZGVvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydfc2VsZiddKTtcbiAgICBpZiAoZnJvbVZpZGVvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW8nXSwgdmlkZW9Gcm9tVmVydGV4KGFwaUNsaWVudCwgZnJvbVZpZGVvKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVmlkZW9zUmVzcG9uc2VGcm9tVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUdlbmVyYXRlZFZpZGVvcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmlkZW9zJ10pO1xuICAgIGlmIChmcm9tR2VuZXJhdGVkVmlkZW9zICE9IG51bGwpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZnJvbUdlbmVyYXRlZFZpZGVvcykpIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dlbmVyYXRlZFZpZGVvcyddLCBmcm9tR2VuZXJhdGVkVmlkZW9zLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZWRWaWRlb0Zyb21WZXJ0ZXgoYXBpQ2xpZW50LCBpdGVtKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dlbmVyYXRlZFZpZGVvcyddLCBmcm9tR2VuZXJhdGVkVmlkZW9zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmcm9tUmFpTWVkaWFGaWx0ZXJlZENvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmFpTWVkaWFGaWx0ZXJlZENvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJhaU1lZGlhRmlsdGVyZWRDb3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JhaU1lZGlhRmlsdGVyZWRDb3VudCddLCBmcm9tUmFpTWVkaWFGaWx0ZXJlZENvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJhaU1lZGlhRmlsdGVyZWRSZWFzb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyYWlNZWRpYUZpbHRlcmVkUmVhc29ucyddLCBmcm9tUmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc09wZXJhdGlvbkZyb21WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRhZGF0YSddKTtcbiAgICBpZiAoZnJvbU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWV0YWRhdGEnXSwgZnJvbU1ldGFkYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURvbmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RvbmUnXSk7XG4gICAgaWYgKGZyb21Eb25lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZG9uZSddLCBmcm9tRG9uZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcnJvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXJyb3InXSk7XG4gICAgaWYgKGZyb21FcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vycm9yJ10sIGZyb21FcnJvcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzcG9uc2UnXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlJ10sIGdlbmVyYXRlVmlkZW9zUmVzcG9uc2VGcm9tVmVydGV4KGFwaUNsaWVudCwgZnJvbVJlc3BvbnNlKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY2xhc3MgT3BlcmF0aW9ucyBleHRlbmRzIEJhc2VNb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKGFwaUNsaWVudCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc3RhdHVzIG9mIGEgbG9uZy1ydW5uaW5nIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbWV0ZXJzIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgZ2V0IG9wZXJhdGlvbiByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gVGhlIHVwZGF0ZWQgT3BlcmF0aW9uIG9iamVjdCwgd2l0aCB0aGUgbGF0ZXN0IHN0YXR1cyBvciByZXN1bHQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VmlkZW9zT3BlcmF0aW9uKHBhcmFtZXRlcnMpIHtcbiAgICAgICAgY29uc3Qgb3BlcmF0aW9uID0gcGFyYW1ldGVycy5vcGVyYXRpb247XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHBhcmFtZXRlcnMuY29uZmlnO1xuICAgICAgICBpZiAob3BlcmF0aW9uLm5hbWUgPT09IHVuZGVmaW5lZCB8fCBvcGVyYXRpb24ubmFtZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT3BlcmF0aW9uIG5hbWUgaXMgcmVxdWlyZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgcmVzb3VyY2VOYW1lID0gb3BlcmF0aW9uLm5hbWUuc3BsaXQoJy9vcGVyYXRpb25zLycpWzBdO1xuICAgICAgICAgICAgbGV0IGh0dHBPcHRpb25zID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGNvbmZpZyAmJiAnaHR0cE9wdGlvbnMnIGluIGNvbmZpZykge1xuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zID0gY29uZmlnLmh0dHBPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hQcmVkaWN0VmlkZW9zT3BlcmF0aW9uSW50ZXJuYWwoe1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbk5hbWU6IG9wZXJhdGlvbi5uYW1lLFxuICAgICAgICAgICAgICAgIHJlc291cmNlTmFtZTogcmVzb3VyY2VOYW1lLFxuICAgICAgICAgICAgICAgIGNvbmZpZzogeyBodHRwT3B0aW9uczogaHR0cE9wdGlvbnMgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmlkZW9zT3BlcmF0aW9uSW50ZXJuYWwoe1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbk5hbWU6IG9wZXJhdGlvbi5uYW1lLFxuICAgICAgICAgICAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0VmlkZW9zT3BlcmF0aW9uSW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdldE9wZXJhdGlvblBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tvcGVyYXRpb25OYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBnZW5lcmF0ZVZpZGVvc09wZXJhdGlvbkZyb21WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdldE9wZXJhdGlvblBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne29wZXJhdGlvbk5hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnY29uZmlnJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uRnJvbU1sZGV2KHRoaXMuYXBpQ2xpZW50LCBhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBmZXRjaFByZWRpY3RWaWRlb3NPcGVyYXRpb25JbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGZldGNoUHJlZGljdE9wZXJhdGlvblBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tyZXNvdXJjZU5hbWV9OmZldGNoUHJlZGljdE9wZXJhdGlvbicsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZ2VuZXJhdGVWaWRlb3NPcGVyYXRpb25Gcm9tVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIFZlcnRleCBBSS4nKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY29uc3QgQ09OVEVOVF9UWVBFX0hFQURFUiA9ICdDb250ZW50LVR5cGUnO1xuY29uc3QgU0VSVkVSX1RJTUVPVVRfSEVBREVSID0gJ1gtU2VydmVyLVRpbWVvdXQnO1xuY29uc3QgVVNFUl9BR0VOVF9IRUFERVIgPSAnVXNlci1BZ2VudCc7XG5jb25zdCBHT09HTEVfQVBJX0NMSUVOVF9IRUFERVIgPSAneC1nb29nLWFwaS1jbGllbnQnO1xuY29uc3QgU0RLX1ZFUlNJT04gPSAnMC4xMC4wJzsgLy8geC1yZWxlYXNlLXBsZWFzZS12ZXJzaW9uXG5jb25zdCBMSUJSQVJZX0xBQkVMID0gYGdvb2dsZS1nZW5haS1zZGsvJHtTREtfVkVSU0lPTn1gO1xuY29uc3QgVkVSVEVYX0FJX0FQSV9ERUZBVUxUX1ZFUlNJT04gPSAndjFiZXRhMSc7XG5jb25zdCBHT09HTEVfQUlfQVBJX0RFRkFVTFRfVkVSU0lPTiA9ICd2MWJldGEnO1xuY29uc3QgcmVzcG9uc2VMaW5lUkUgPSAvXmRhdGE6ICguKikoPzpcXG5cXG58XFxyXFxyfFxcclxcblxcclxcbikvO1xuLyoqXG4gKiBDbGllbnQgZXJyb3JzIHJhaXNlZCBieSB0aGUgR2VuQUkgQVBJLlxuICovXG5jbGFzcyBDbGllbnRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGFja1RyYWNlKSB7XG4gICAgICAgIGlmIChzdGFja1RyYWNlKSB7XG4gICAgICAgICAgICBzdXBlcihtZXNzYWdlLCB7IGNhdXNlOiBzdGFja1RyYWNlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3VwZXIobWVzc2FnZSwgeyBjYXVzZTogbmV3IEVycm9yKCkuc3RhY2sgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0NsaWVudEVycm9yJztcbiAgICB9XG59XG4vKipcbiAqIFNlcnZlciBlcnJvcnMgcmFpc2VkIGJ5IHRoZSBHZW5BSSBBUEkuXG4gKi9cbmNsYXNzIFNlcnZlckVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YWNrVHJhY2UpIHtcbiAgICAgICAgaWYgKHN0YWNrVHJhY2UpIHtcbiAgICAgICAgICAgIHN1cGVyKG1lc3NhZ2UsIHsgY2F1c2U6IHN0YWNrVHJhY2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdXBlcihtZXNzYWdlLCB7IGNhdXNlOiBuZXcgRXJyb3IoKS5zdGFjayB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB0aGlzLm5hbWUgPSAnU2VydmVyRXJyb3InO1xuICAgIH1cbn1cbi8qKlxuICogVGhlIEFwaUNsaWVudCBjbGFzcyBpcyB1c2VkIHRvIHNlbmQgcmVxdWVzdHMgdG8gdGhlIEdlbWluaSBBUEkgb3IgVmVydGV4IEFJXG4gKiBlbmRwb2ludHMuXG4gKi9cbmNsYXNzIEFwaUNsaWVudCB7XG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdHMpLCB7IHByb2plY3Q6IG9wdHMucHJvamVjdCwgbG9jYXRpb246IG9wdHMubG9jYXRpb24sIGFwaUtleTogb3B0cy5hcGlLZXksIHZlcnRleGFpOiBvcHRzLnZlcnRleGFpIH0pO1xuICAgICAgICBjb25zdCBpbml0SHR0cE9wdGlvbnMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuY2xpZW50T3B0aW9ucy52ZXJ0ZXhhaSkge1xuICAgICAgICAgICAgaW5pdEh0dHBPcHRpb25zLmFwaVZlcnNpb24gPVxuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuY2xpZW50T3B0aW9ucy5hcGlWZXJzaW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBWRVJURVhfQUlfQVBJX0RFRkFVTFRfVkVSU0lPTjtcbiAgICAgICAgICAgIC8vIEFzc3VtZSB0aGF0IHByb2ovYXBpIGtleSB2YWxpZGF0aW9uIG9jY3VycyBiZWZvcmUgdGhleSBhcmUgcGFzc2VkIGluLlxuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0UHJvamVjdCgpIHx8IHRoaXMuZ2V0TG9jYXRpb24oKSkge1xuICAgICAgICAgICAgICAgIGluaXRIdHRwT3B0aW9ucy5iYXNlVXJsID0gYGh0dHBzOi8vJHt0aGlzLmNsaWVudE9wdGlvbnMubG9jYXRpb259LWFpcGxhdGZvcm0uZ29vZ2xlYXBpcy5jb20vYDtcbiAgICAgICAgICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMuYXBpS2V5ID0gdW5kZWZpbmVkOyAvLyB1bnNldCBBUEkga2V5LlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5pdEh0dHBPcHRpb25zLmJhc2VVcmwgPSBgaHR0cHM6Ly9haXBsYXRmb3JtLmdvb2dsZWFwaXMuY29tL2A7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGllbnRPcHRpb25zLnByb2plY3QgPSB1bmRlZmluZWQ7IC8vIHVuc2V0IHByb2plY3QuXG4gICAgICAgICAgICAgICAgdGhpcy5jbGllbnRPcHRpb25zLmxvY2F0aW9uID0gdW5kZWZpbmVkOyAvLyB1bnNldCBsb2NhdGlvbi5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGluaXRIdHRwT3B0aW9ucy5hcGlWZXJzaW9uID1cbiAgICAgICAgICAgICAgICAoX2IgPSB0aGlzLmNsaWVudE9wdGlvbnMuYXBpVmVyc2lvbikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogR09PR0xFX0FJX0FQSV9ERUZBVUxUX1ZFUlNJT047XG4gICAgICAgICAgICBpbml0SHR0cE9wdGlvbnMuYmFzZVVybCA9IGBodHRwczovL2dlbmVyYXRpdmVsYW5ndWFnZS5nb29nbGVhcGlzLmNvbS9gO1xuICAgICAgICB9XG4gICAgICAgIGluaXRIdHRwT3B0aW9ucy5oZWFkZXJzID0gdGhpcy5nZXREZWZhdWx0SGVhZGVycygpO1xuICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMgPSBpbml0SHR0cE9wdGlvbnM7XG4gICAgICAgIGlmIChvcHRzLmh0dHBPcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMgPSB0aGlzLnBhdGNoSHR0cE9wdGlvbnMoaW5pdEh0dHBPcHRpb25zLCBvcHRzLmh0dHBPcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc1ZlcnRleEFJKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLmNsaWVudE9wdGlvbnMudmVydGV4YWkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlO1xuICAgIH1cbiAgICBnZXRQcm9qZWN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnRPcHRpb25zLnByb2plY3Q7XG4gICAgfVxuICAgIGdldExvY2F0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnRPcHRpb25zLmxvY2F0aW9uO1xuICAgIH1cbiAgICBnZXRBcGlWZXJzaW9uKCkge1xuICAgICAgICBpZiAodGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zICYmXG4gICAgICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMuYXBpVmVyc2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zLmFwaVZlcnNpb247XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBUEkgdmVyc2lvbiBpcyBub3Qgc2V0LicpO1xuICAgIH1cbiAgICBnZXRCYXNlVXJsKCkge1xuICAgICAgICBpZiAodGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zICYmXG4gICAgICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMuYmFzZVVybCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zLmJhc2VVcmw7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCYXNlIFVSTCBpcyBub3Qgc2V0LicpO1xuICAgIH1cbiAgICBnZXRSZXF1ZXN0VXJsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRSZXF1ZXN0VXJsSW50ZXJuYWwodGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zKTtcbiAgICB9XG4gICAgZ2V0SGVhZGVycygpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucyAmJlxuICAgICAgICAgICAgdGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zLmhlYWRlcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucy5oZWFkZXJzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIZWFkZXJzIGFyZSBub3Qgc2V0LicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFJlcXVlc3RVcmxJbnRlcm5hbChodHRwT3B0aW9ucykge1xuICAgICAgICBpZiAoIWh0dHBPcHRpb25zIHx8XG4gICAgICAgICAgICBodHRwT3B0aW9ucy5iYXNlVXJsID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIGh0dHBPcHRpb25zLmFwaVZlcnNpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIVFRQIG9wdGlvbnMgYXJlIG5vdCBjb3JyZWN0bHkgc2V0LicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJhc2VVcmwgPSBodHRwT3B0aW9ucy5iYXNlVXJsLmVuZHNXaXRoKCcvJylcbiAgICAgICAgICAgID8gaHR0cE9wdGlvbnMuYmFzZVVybC5zbGljZSgwLCAtMSlcbiAgICAgICAgICAgIDogaHR0cE9wdGlvbnMuYmFzZVVybDtcbiAgICAgICAgY29uc3QgdXJsRWxlbWVudCA9IFtiYXNlVXJsXTtcbiAgICAgICAgaWYgKGh0dHBPcHRpb25zLmFwaVZlcnNpb24gJiYgaHR0cE9wdGlvbnMuYXBpVmVyc2lvbiAhPT0gJycpIHtcbiAgICAgICAgICAgIHVybEVsZW1lbnQucHVzaChodHRwT3B0aW9ucy5hcGlWZXJzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJsRWxlbWVudC5qb2luKCcvJyk7XG4gICAgfVxuICAgIGdldEJhc2VSZXNvdXJjZVBhdGgoKSB7XG4gICAgICAgIHJldHVybiBgcHJvamVjdHMvJHt0aGlzLmNsaWVudE9wdGlvbnMucHJvamVjdH0vbG9jYXRpb25zLyR7dGhpcy5jbGllbnRPcHRpb25zLmxvY2F0aW9ufWA7XG4gICAgfVxuICAgIGdldEFwaUtleSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50T3B0aW9ucy5hcGlLZXk7XG4gICAgfVxuICAgIGdldFdlYnNvY2tldEJhc2VVcmwoKSB7XG4gICAgICAgIGNvbnN0IGJhc2VVcmwgPSB0aGlzLmdldEJhc2VVcmwoKTtcbiAgICAgICAgY29uc3QgdXJsUGFydHMgPSBuZXcgVVJMKGJhc2VVcmwpO1xuICAgICAgICB1cmxQYXJ0cy5wcm90b2NvbCA9IHVybFBhcnRzLnByb3RvY29sID09ICdodHRwOicgPyAnd3MnIDogJ3dzcyc7XG4gICAgICAgIHJldHVybiB1cmxQYXJ0cy50b1N0cmluZygpO1xuICAgIH1cbiAgICBzZXRCYXNlVXJsKHVybCkge1xuICAgICAgICBpZiAodGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMuYmFzZVVybCA9IHVybDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSFRUUCBvcHRpb25zIGFyZSBub3QgY29ycmVjdGx5IHNldC4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdHJ1Y3RVcmwocGF0aCwgaHR0cE9wdGlvbnMsIHByZXBlbmRQcm9qZWN0TG9jYXRpb24pIHtcbiAgICAgICAgY29uc3QgdXJsRWxlbWVudCA9IFt0aGlzLmdldFJlcXVlc3RVcmxJbnRlcm5hbChodHRwT3B0aW9ucyldO1xuICAgICAgICBpZiAocHJlcGVuZFByb2plY3RMb2NhdGlvbikge1xuICAgICAgICAgICAgdXJsRWxlbWVudC5wdXNoKHRoaXMuZ2V0QmFzZVJlc291cmNlUGF0aCgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aCAhPT0gJycpIHtcbiAgICAgICAgICAgIHVybEVsZW1lbnQucHVzaChwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGAke3VybEVsZW1lbnQuam9pbignLycpfWApO1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cbiAgICBzaG91bGRQcmVwZW5kVmVydGV4UHJvamVjdFBhdGgocmVxdWVzdCkge1xuICAgICAgICBpZiAodGhpcy5jbGllbnRPcHRpb25zLmFwaUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5jbGllbnRPcHRpb25zLnZlcnRleGFpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcXVlc3QucGF0aC5zdGFydHNXaXRoKCdwcm9qZWN0cy8nKSkge1xuICAgICAgICAgICAgLy8gQXNzdW1lIHRoZSBwYXRoIGFscmVhZHkgc3RhcnRzIHdpdGhcbiAgICAgICAgICAgIC8vIGBwcm9qZWN0cy88cHJvamVjdD4vbG9jYXRpb24vPGxvY2F0aW9uPmAuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcXVlc3QuaHR0cE1ldGhvZCA9PT0gJ0dFVCcgJiZcbiAgICAgICAgICAgIHJlcXVlc3QucGF0aC5zdGFydHNXaXRoKCdwdWJsaXNoZXJzL2dvb2dsZS9tb2RlbHMnKSkge1xuICAgICAgICAgICAgLy8gVGhlc2UgcGF0aHMgYXJlIHVzZWQgYnkgVmVydGV4J3MgbW9kZWxzLmdldCBhbmQgbW9kZWxzLmxpc3RcbiAgICAgICAgICAgIC8vIGNhbGxzLiBGb3IgYmFzZSBtb2RlbHMgVmVydGV4IGRvZXMgbm90IGFjY2VwdCBhIHByb2plY3QvbG9jYXRpb25cbiAgICAgICAgICAgIC8vIHByZWZpeCAoZm9yIHR1bmVkIG1vZGVsIHRoZSBwcmVmaXggaXMgcmVxdWlyZWQpLlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBhc3luYyByZXF1ZXN0KHJlcXVlc3QpIHtcbiAgICAgICAgbGV0IHBhdGNoZWRIdHRwT3B0aW9ucyA9IHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucztcbiAgICAgICAgaWYgKHJlcXVlc3QuaHR0cE9wdGlvbnMpIHtcbiAgICAgICAgICAgIHBhdGNoZWRIdHRwT3B0aW9ucyA9IHRoaXMucGF0Y2hIdHRwT3B0aW9ucyh0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMsIHJlcXVlc3QuaHR0cE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZXBlbmRQcm9qZWN0TG9jYXRpb24gPSB0aGlzLnNob3VsZFByZXBlbmRWZXJ0ZXhQcm9qZWN0UGF0aChyZXF1ZXN0KTtcbiAgICAgICAgY29uc3QgdXJsID0gdGhpcy5jb25zdHJ1Y3RVcmwocmVxdWVzdC5wYXRoLCBwYXRjaGVkSHR0cE9wdGlvbnMsIHByZXBlbmRQcm9qZWN0TG9jYXRpb24pO1xuICAgICAgICBpZiAocmVxdWVzdC5xdWVyeVBhcmFtcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocmVxdWVzdC5xdWVyeVBhcmFtcykpIHtcbiAgICAgICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIFN0cmluZyh2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCByZXF1ZXN0SW5pdCA9IHt9O1xuICAgICAgICBpZiAocmVxdWVzdC5odHRwTWV0aG9kID09PSAnR0VUJykge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3QuYm9keSAmJiByZXF1ZXN0LmJvZHkgIT09ICd7fScpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVlc3QgYm9keSBzaG91bGQgYmUgZW1wdHkgZm9yIEdFVCByZXF1ZXN0LCBidXQgZ290IG5vbiBlbXB0eSByZXF1ZXN0IGJvZHknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcXVlc3RJbml0LmJvZHkgPSByZXF1ZXN0LmJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdEluaXQgPSBhd2FpdCB0aGlzLmluY2x1ZGVFeHRyYUh0dHBPcHRpb25zVG9SZXF1ZXN0SW5pdChyZXF1ZXN0SW5pdCwgcGF0Y2hlZEh0dHBPcHRpb25zLCByZXF1ZXN0LmFib3J0U2lnbmFsKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5hcnlBcGlDYWxsKHVybCwgcmVxdWVzdEluaXQsIHJlcXVlc3QuaHR0cE1ldGhvZCk7XG4gICAgfVxuICAgIHBhdGNoSHR0cE9wdGlvbnMoYmFzZUh0dHBPcHRpb25zLCByZXF1ZXN0SHR0cE9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcGF0Y2hlZEh0dHBPcHRpb25zID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShiYXNlSHR0cE9wdGlvbnMpKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocmVxdWVzdEh0dHBPcHRpb25zKSkge1xuICAgICAgICAgICAgLy8gUmVjb3JkcyBjb21waWxlIHRvIG9iamVjdHMuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVFMyMzQ1VFM3MDUzOiBFbGVtZW50IGltcGxpY2l0bHkgaGFzIGFuICdhbnknIHR5cGVcbiAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIGV4cHJlc3Npb24gb2YgdHlwZSAnc3RyaW5nJyBjYW4ndCBiZSB1c2VkIHRvIGluZGV4IHR5cGVcbiAgICAgICAgICAgICAgICAvLyAnSHR0cE9wdGlvbnMnLlxuICAgICAgICAgICAgICAgIHBhdGNoZWRIdHRwT3B0aW9uc1trZXldID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXRjaGVkSHR0cE9wdGlvbnNba2V5XSksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRTMjM0NVRTNzA1MzogRWxlbWVudCBpbXBsaWNpdGx5IGhhcyBhbiAnYW55JyB0eXBlXG4gICAgICAgICAgICAgICAgLy8gYmVjYXVzZSBleHByZXNzaW9uIG9mIHR5cGUgJ3N0cmluZycgY2FuJ3QgYmUgdXNlZCB0byBpbmRleCB0eXBlXG4gICAgICAgICAgICAgICAgLy8gJ0h0dHBPcHRpb25zJy5cbiAgICAgICAgICAgICAgICBwYXRjaGVkSHR0cE9wdGlvbnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRjaGVkSHR0cE9wdGlvbnM7XG4gICAgfVxuICAgIGFzeW5jIHJlcXVlc3RTdHJlYW0ocmVxdWVzdCkge1xuICAgICAgICBsZXQgcGF0Y2hlZEh0dHBPcHRpb25zID0gdGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zO1xuICAgICAgICBpZiAocmVxdWVzdC5odHRwT3B0aW9ucykge1xuICAgICAgICAgICAgcGF0Y2hlZEh0dHBPcHRpb25zID0gdGhpcy5wYXRjaEh0dHBPcHRpb25zKHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucywgcmVxdWVzdC5odHRwT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJlcGVuZFByb2plY3RMb2NhdGlvbiA9IHRoaXMuc2hvdWxkUHJlcGVuZFZlcnRleFByb2plY3RQYXRoKHJlcXVlc3QpO1xuICAgICAgICBjb25zdCB1cmwgPSB0aGlzLmNvbnN0cnVjdFVybChyZXF1ZXN0LnBhdGgsIHBhdGNoZWRIdHRwT3B0aW9ucywgcHJlcGVuZFByb2plY3RMb2NhdGlvbik7XG4gICAgICAgIGlmICghdXJsLnNlYXJjaFBhcmFtcy5oYXMoJ2FsdCcpIHx8IHVybC5zZWFyY2hQYXJhbXMuZ2V0KCdhbHQnKSAhPT0gJ3NzZScpIHtcbiAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdhbHQnLCAnc3NlJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlcXVlc3RJbml0ID0ge307XG4gICAgICAgIHJlcXVlc3RJbml0LmJvZHkgPSByZXF1ZXN0LmJvZHk7XG4gICAgICAgIHJlcXVlc3RJbml0ID0gYXdhaXQgdGhpcy5pbmNsdWRlRXh0cmFIdHRwT3B0aW9uc1RvUmVxdWVzdEluaXQocmVxdWVzdEluaXQsIHBhdGNoZWRIdHRwT3B0aW9ucywgcmVxdWVzdC5hYm9ydFNpZ25hbCk7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUFwaUNhbGwodXJsLCByZXF1ZXN0SW5pdCwgcmVxdWVzdC5odHRwTWV0aG9kKTtcbiAgICB9XG4gICAgYXN5bmMgaW5jbHVkZUV4dHJhSHR0cE9wdGlvbnNUb1JlcXVlc3RJbml0KHJlcXVlc3RJbml0LCBodHRwT3B0aW9ucywgYWJvcnRTaWduYWwpIHtcbiAgICAgICAgaWYgKChodHRwT3B0aW9ucyAmJiBodHRwT3B0aW9ucy50aW1lb3V0KSB8fCBhYm9ydFNpZ25hbCkge1xuICAgICAgICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbmFsID0gYWJvcnRDb250cm9sbGVyLnNpZ25hbDtcbiAgICAgICAgICAgIGlmIChodHRwT3B0aW9ucy50aW1lb3V0ICYmIChodHRwT3B0aW9ucyA9PT0gbnVsbCB8fCBodHRwT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaHR0cE9wdGlvbnMudGltZW91dCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKSwgaHR0cE9wdGlvbnMudGltZW91dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWJvcnRTaWduYWwpIHtcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXF1ZXN0SW5pdC5zaWduYWwgPSBzaWduYWw7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdEluaXQuaGVhZGVycyA9IGF3YWl0IHRoaXMuZ2V0SGVhZGVyc0ludGVybmFsKGh0dHBPcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHJlcXVlc3RJbml0O1xuICAgIH1cbiAgICBhc3luYyB1bmFyeUFwaUNhbGwodXJsLCByZXF1ZXN0SW5pdCwgaHR0cE1ldGhvZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcGlDYWxsKHVybC50b1N0cmluZygpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlcXVlc3RJbml0KSwgeyBtZXRob2Q6IGh0dHBNZXRob2QgfSkpXG4gICAgICAgICAgICAudGhlbihhc3luYyAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHRocm93RXJyb3JJZk5vdE9LKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSHR0cFJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSlNPTi5zdHJpbmdpZnkoZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgc3RyZWFtQXBpQ2FsbCh1cmwsIHJlcXVlc3RJbml0LCBodHRwTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwaUNhbGwodXJsLnRvU3RyaW5nKCksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdEluaXQpLCB7IG1ldGhvZDogaHR0cE1ldGhvZCB9KSlcbiAgICAgICAgICAgIC50aGVuKGFzeW5jIChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgdGhyb3dFcnJvcklmTm90T0socmVzcG9uc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1N0cmVhbVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSlNPTi5zdHJpbmdpZnkoZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcHJvY2Vzc1N0cmVhbVJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogcHJvY2Vzc1N0cmVhbVJlc3BvbnNlXzEoKSB7XG4gICAgICAgICAgICBjb25zdCByZWFkZXIgPSAoX2EgPSByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UuYm9keSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFJlYWRlcigpO1xuICAgICAgICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigndXRmLTgnKTtcbiAgICAgICAgICAgIGlmICghcmVhZGVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXNwb25zZSBib2R5IGlzIGVtcHR5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCBidWZmZXIgPSAnJztcbiAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSB5aWVsZCBfX2F3YWl0KHJlYWRlci5yZWFkKCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ1ZmZlci50cmltKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb21wbGV0ZSBKU09OIHNlZ21lbnQgYXQgdGhlIGVuZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmtTdHJpbmcgPSBkZWNvZGVyLmRlY29kZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIGFuZCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgY2h1bmsgY29udGFpbnMgYW4gZXJyb3IuXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVua0pzb24gPSBKU09OLnBhcnNlKGNodW5rU3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgnZXJyb3InIGluIGNodW5rSnNvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9ySnNvbiA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoY2h1bmtKc29uWydlcnJvciddKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gZXJyb3JKc29uWydzdGF0dXMnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2RlID0gZXJyb3JKc29uWydjb2RlJ107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gYGdvdCBzdGF0dXM6ICR7c3RhdHVzfS4gJHtKU09OLnN0cmluZ2lmeShjaHVua0pzb24pfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgPj0gNDAwICYmIGNvZGUgPCA1MDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xpZW50RXJyb3IgPSBuZXcgQ2xpZW50RXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgY2xpZW50RXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvZGUgPj0gNTAwICYmIGNvZGUgPCA2MDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VydmVyRXJyb3IgPSBuZXcgU2VydmVyRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgc2VydmVyRXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ0NsaWVudEVycm9yJyB8fCBlcnJvci5uYW1lID09PSAnU2VydmVyRXJyb3InKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBidWZmZXIgKz0gY2h1bmtTdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtYXRjaCA9IGJ1ZmZlci5tYXRjaChyZXNwb25zZUxpbmVSRSk7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkQ2h1bmtTdHJpbmcgPSBtYXRjaFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFydGlhbFJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKHByb2Nlc3NlZENodW5rU3RyaW5nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQobmV3IEh0dHBSZXNwb25zZShwYXJ0aWFsUmVzcG9uc2UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UobWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IGJ1ZmZlci5tYXRjaChyZXNwb25zZUxpbmVSRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhjZXB0aW9uIHBhcnNpbmcgc3RyZWFtIGNodW5rICR7cHJvY2Vzc2VkQ2h1bmtTdHJpbmd9LiAke2V9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGFwaUNhbGwodXJsLCByZXF1ZXN0SW5pdCkge1xuICAgICAgICByZXR1cm4gZmV0Y2godXJsLCByZXF1ZXN0SW5pdCkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhjZXB0aW9uICR7ZX0gc2VuZGluZyByZXF1ZXN0YCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXREZWZhdWx0SGVhZGVycygpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgICAgICBjb25zdCB2ZXJzaW9uSGVhZGVyVmFsdWUgPSBMSUJSQVJZX0xBQkVMICsgJyAnICsgdGhpcy5jbGllbnRPcHRpb25zLnVzZXJBZ2VudEV4dHJhO1xuICAgICAgICBoZWFkZXJzW1VTRVJfQUdFTlRfSEVBREVSXSA9IHZlcnNpb25IZWFkZXJWYWx1ZTtcbiAgICAgICAgaGVhZGVyc1tHT09HTEVfQVBJX0NMSUVOVF9IRUFERVJdID0gdmVyc2lvbkhlYWRlclZhbHVlO1xuICAgICAgICBoZWFkZXJzW0NPTlRFTlRfVFlQRV9IRUFERVJdID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICByZXR1cm4gaGVhZGVycztcbiAgICB9XG4gICAgYXN5bmMgZ2V0SGVhZGVyc0ludGVybmFsKGh0dHBPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICAgICAgICBpZiAoaHR0cE9wdGlvbnMgJiYgaHR0cE9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaHR0cE9wdGlvbnMuaGVhZGVycykpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFwcGVuZCBhIHRpbWVvdXQgaGVhZGVyIGlmIGl0IGlzIHNldCwgbm90ZSB0aGF0IHRoZSB0aW1lb3V0IG9wdGlvbiBpc1xuICAgICAgICAgICAgLy8gaW4gbWlsbGlzZWNvbmRzIGJ1dCB0aGUgaGVhZGVyIGlzIGluIHNlY29uZHMuXG4gICAgICAgICAgICBpZiAoaHR0cE9wdGlvbnMudGltZW91dCAmJiBodHRwT3B0aW9ucy50aW1lb3V0ID4gMCkge1xuICAgICAgICAgICAgICAgIGhlYWRlcnMuYXBwZW5kKFNFUlZFUl9USU1FT1VUX0hFQURFUiwgU3RyaW5nKE1hdGguY2VpbChodHRwT3B0aW9ucy50aW1lb3V0IC8gMTAwMCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLmNsaWVudE9wdGlvbnMuYXV0aC5hZGRBdXRoSGVhZGVycyhoZWFkZXJzKTtcbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwbG9hZHMgYSBmaWxlIGFzeW5jaHJvbm91c2x5IHVzaW5nIEdlbWluaSBBUEkgb25seSwgdGhpcyBpcyBub3Qgc3VwcG9ydGVkXG4gICAgICogaW4gVmVydGV4IEFJLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZpbGUgVGhlIHN0cmluZyBwYXRoIHRvIHRoZSBmaWxlIHRvIGJlIHVwbG9hZGVkIG9yIGEgQmxvYiBvYmplY3QuXG4gICAgICogQHBhcmFtIGNvbmZpZyBPcHRpb25hbCBwYXJhbWV0ZXJzIHNwZWNpZmllZCBpbiB0aGUgYFVwbG9hZEZpbGVDb25maWdgXG4gICAgICogICAgIGludGVyZmFjZS4gQHNlZSB7QGxpbmsgVXBsb2FkRmlsZUNvbmZpZ31cbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZpbGVgIG9iamVjdC5cbiAgICAgKiBAdGhyb3dzIEFuIGVycm9yIGlmIGNhbGxlZCBvbiBhIFZlcnRleCBBSSBjbGllbnQuXG4gICAgICogQHRocm93cyBBbiBlcnJvciBpZiB0aGUgYG1pbWVUeXBlYCBpcyBub3QgcHJvdmlkZWQgYW5kIGNhbiBub3QgYmUgaW5mZXJyZWQsXG4gICAgICovXG4gICAgYXN5bmMgdXBsb2FkRmlsZShmaWxlLCBjb25maWcpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBmaWxlVG9VcGxvYWQgPSB7fTtcbiAgICAgICAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgICAgICBmaWxlVG9VcGxvYWQubWltZVR5cGUgPSBjb25maWcubWltZVR5cGU7XG4gICAgICAgICAgICBmaWxlVG9VcGxvYWQubmFtZSA9IGNvbmZpZy5uYW1lO1xuICAgICAgICAgICAgZmlsZVRvVXBsb2FkLmRpc3BsYXlOYW1lID0gY29uZmlnLmRpc3BsYXlOYW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWxlVG9VcGxvYWQubmFtZSAmJiAhZmlsZVRvVXBsb2FkLm5hbWUuc3RhcnRzV2l0aCgnZmlsZXMvJykpIHtcbiAgICAgICAgICAgIGZpbGVUb1VwbG9hZC5uYW1lID0gYGZpbGVzLyR7ZmlsZVRvVXBsb2FkLm5hbWV9YDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cGxvYWRlciA9IHRoaXMuY2xpZW50T3B0aW9ucy51cGxvYWRlcjtcbiAgICAgICAgY29uc3QgZmlsZVN0YXQgPSBhd2FpdCB1cGxvYWRlci5zdGF0KGZpbGUpO1xuICAgICAgICBmaWxlVG9VcGxvYWQuc2l6ZUJ5dGVzID0gU3RyaW5nKGZpbGVTdGF0LnNpemUpO1xuICAgICAgICBjb25zdCBtaW1lVHlwZSA9IChfYSA9IGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5taW1lVHlwZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmlsZVN0YXQudHlwZTtcbiAgICAgICAgaWYgKG1pbWVUeXBlID09PSB1bmRlZmluZWQgfHwgbWltZVR5cGUgPT09ICcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgZGV0ZXJtaW5lIG1pbWVUeXBlLiBQbGVhc2UgcHJvdmlkZSBtaW1lVHlwZSBpbiB0aGUgY29uZmlnLicpO1xuICAgICAgICB9XG4gICAgICAgIGZpbGVUb1VwbG9hZC5taW1lVHlwZSA9IG1pbWVUeXBlO1xuICAgICAgICBjb25zdCB1cGxvYWRVcmwgPSBhd2FpdCB0aGlzLmZldGNoVXBsb2FkVXJsKGZpbGVUb1VwbG9hZCwgY29uZmlnKTtcbiAgICAgICAgcmV0dXJuIHVwbG9hZGVyLnVwbG9hZChmaWxlLCB1cGxvYWRVcmwsIHRoaXMpO1xuICAgIH1cbiAgICBhc3luYyBmZXRjaFVwbG9hZFVybChmaWxlLCBjb25maWcpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgaHR0cE9wdGlvbnMgPSB7fTtcbiAgICAgICAgaWYgKGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5odHRwT3B0aW9ucykge1xuICAgICAgICAgICAgaHR0cE9wdGlvbnMgPSBjb25maWcuaHR0cE9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBodHRwT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBhcGlWZXJzaW9uOiAnJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgICAgICdYLUdvb2ctVXBsb2FkLVByb3RvY29sJzogJ3Jlc3VtYWJsZScsXG4gICAgICAgICAgICAgICAgICAgICdYLUdvb2ctVXBsb2FkLUNvbW1hbmQnOiAnc3RhcnQnLFxuICAgICAgICAgICAgICAgICAgICAnWC1Hb29nLVVwbG9hZC1IZWFkZXItQ29udGVudC1MZW5ndGgnOiBgJHtmaWxlLnNpemVCeXRlc31gLFxuICAgICAgICAgICAgICAgICAgICAnWC1Hb29nLVVwbG9hZC1IZWFkZXItQ29udGVudC1UeXBlJzogYCR7ZmlsZS5taW1lVHlwZX1gLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICAnZmlsZSc6IGZpbGUsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGh0dHBSZXNwb25zZSA9IGF3YWl0IHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICBwYXRoOiBmb3JtYXRNYXAoJ3VwbG9hZC92MWJldGEvZmlsZXMnLCBib2R5WydfdXJsJ10pLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBodHRwT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghaHR0cFJlc3BvbnNlIHx8ICEoaHR0cFJlc3BvbnNlID09PSBudWxsIHx8IGh0dHBSZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaHR0cFJlc3BvbnNlLmhlYWRlcnMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlcnZlciBkaWQgbm90IHJldHVybiBhbiBIdHRwUmVzcG9uc2Ugb3IgdGhlIHJldHVybmVkIEh0dHBSZXNwb25zZSBkaWQgbm90IGhhdmUgaGVhZGVycy4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cGxvYWRVcmwgPSAoX2EgPSBodHRwUmVzcG9uc2UgPT09IG51bGwgfHwgaHR0cFJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBodHRwUmVzcG9uc2UuaGVhZGVycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWyd4LWdvb2ctdXBsb2FkLXVybCddO1xuICAgICAgICBpZiAodXBsb2FkVXJsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCB1cGxvYWQgdXJsLiBTZXJ2ZXIgZGlkIG5vdCByZXR1cm4gdGhlIHgtZ29vZ2xlLXVwbG9hZC11cmwgaW4gdGhlIGhlYWRlcnMnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXBsb2FkVXJsO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHRocm93RXJyb3JJZk5vdE9LKHJlc3BvbnNlKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChyZXNwb25zZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBTZXJ2ZXJFcnJvcigncmVzcG9uc2UgaXMgdW5kZWZpbmVkJyk7XG4gICAgfVxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzO1xuICAgICAgICBjb25zdCBzdGF0dXNUZXh0ID0gcmVzcG9uc2Uuc3RhdHVzVGV4dDtcbiAgICAgICAgbGV0IGVycm9yQm9keTtcbiAgICAgICAgaWYgKChfYSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmluY2x1ZGVzKCdhcHBsaWNhdGlvbi9qc29uJykpIHtcbiAgICAgICAgICAgIGVycm9yQm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yQm9keSA9IHtcbiAgICAgICAgICAgICAgICBlcnJvcjoge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBhd2FpdCByZXNwb25zZS50ZXh0KCksXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGBnb3Qgc3RhdHVzOiAke3N0YXR1c30gJHtzdGF0dXNUZXh0fS4gJHtKU09OLnN0cmluZ2lmeShlcnJvckJvZHkpfWA7XG4gICAgICAgIGlmIChzdGF0dXMgPj0gNDAwICYmIHN0YXR1cyA8IDUwMCkge1xuICAgICAgICAgICAgY29uc3QgY2xpZW50RXJyb3IgPSBuZXcgQ2xpZW50RXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgIHRocm93IGNsaWVudEVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXR1cyA+PSA1MDAgJiYgc3RhdHVzIDwgNjAwKSB7XG4gICAgICAgICAgICBjb25zdCBzZXJ2ZXJFcnJvciA9IG5ldyBTZXJ2ZXJFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgICAgICAgdGhyb3cgc2VydmVyRXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jb25zdCBHT09HTEVfQVBJX0tFWV9IRUFERVIgPSAneC1nb29nLWFwaS1rZXknO1xuY29uc3QgUkVRVUlSRURfVkVSVEVYX0FJX1NDT1BFID0gJ2h0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvY2xvdWQtcGxhdGZvcm0nO1xuY2xhc3MgTm9kZUF1dGgge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMuYXBpS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYXBpS2V5ID0gb3B0cy5hcGlLZXk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmVydGV4QXV0aE9wdGlvbnMgPSBidWlsZEdvb2dsZUF1dGhPcHRpb25zKG9wdHMuZ29vZ2xlQXV0aE9wdGlvbnMpO1xuICAgICAgICB0aGlzLmdvb2dsZUF1dGggPSBuZXcgZ29vZ2xlQXV0aExpYnJhcnkuR29vZ2xlQXV0aCh2ZXJ0ZXhBdXRoT3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGFkZEF1dGhIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICAgICAgaWYgKHRoaXMuYXBpS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkS2V5SGVhZGVyKGhlYWRlcnMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFkZEdvb2dsZUF1dGhIZWFkZXJzKGhlYWRlcnMpO1xuICAgIH1cbiAgICBhZGRLZXlIZWFkZXIoaGVhZGVycykge1xuICAgICAgICBpZiAoaGVhZGVycy5nZXQoR09PR0xFX0FQSV9LRVlfSEVBREVSKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFwaUtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4sIHRoaXMgbWV0aG9kIGlzIG9ubHkgY2FsbGVkXG4gICAgICAgICAgICAvLyB3aGVuIGFwaUtleSBpcyBzZXQuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyeWluZyB0byBzZXQgQVBJIGtleSBoZWFkZXIgYnV0IGFwaUtleSBpcyBub3Qgc2V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaGVhZGVycy5hcHBlbmQoR09PR0xFX0FQSV9LRVlfSEVBREVSLCB0aGlzLmFwaUtleSk7XG4gICAgfVxuICAgIGFzeW5jIGFkZEdvb2dsZUF1dGhIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICAgICAgaWYgKHRoaXMuZ29vZ2xlQXV0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4sIGFkZEdvb2dsZUF1dGhIZWFkZXJzIHNob3VsZCBvbmx5IGJlXG4gICAgICAgICAgICAvLyBjYWxsZWQgd2hlbiB0aGVyZSBpcyBubyBhcGlLZXkgc2V0IGFuZCBpbiB0aGVzZSBjYXNlcyBnb29nbGVBdXRoXG4gICAgICAgICAgICAvLyBpcyBzZXQuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyeWluZyB0byBzZXQgZ29vZ2xlLWF1dGggaGVhZGVycyBidXQgZ29vZ2xlQXV0aCBpcyB1bnNldCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGF1dGhIZWFkZXJzID0gYXdhaXQgdGhpcy5nb29nbGVBdXRoLmdldFJlcXVlc3RIZWFkZXJzKCk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGF1dGhIZWFkZXJzKSB7XG4gICAgICAgICAgICBpZiAoaGVhZGVycy5nZXQoa2V5KSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCBhdXRoSGVhZGVyc1trZXldKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkR29vZ2xlQXV0aE9wdGlvbnMoZ29vZ2xlQXV0aE9wdGlvbnMpIHtcbiAgICBsZXQgYXV0aE9wdGlvbnM7XG4gICAgaWYgKCFnb29nbGVBdXRoT3B0aW9ucykge1xuICAgICAgICBhdXRoT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHNjb3BlczogW1JFUVVJUkVEX1ZFUlRFWF9BSV9TQ09QRV0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhdXRoT3B0aW9ucztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGF1dGhPcHRpb25zID0gZ29vZ2xlQXV0aE9wdGlvbnM7XG4gICAgICAgIGlmICghYXV0aE9wdGlvbnMuc2NvcGVzKSB7XG4gICAgICAgICAgICBhdXRoT3B0aW9ucy5zY29wZXMgPSBbUkVRVUlSRURfVkVSVEVYX0FJX1NDT1BFXTtcbiAgICAgICAgICAgIHJldHVybiBhdXRoT3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgodHlwZW9mIGF1dGhPcHRpb25zLnNjb3BlcyA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgIGF1dGhPcHRpb25zLnNjb3BlcyAhPT0gUkVRVUlSRURfVkVSVEVYX0FJX1NDT1BFKSB8fFxuICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkoYXV0aE9wdGlvbnMuc2NvcGVzKSAmJlxuICAgICAgICAgICAgICAgIGF1dGhPcHRpb25zLnNjb3Blcy5pbmRleE9mKFJFUVVJUkVEX1ZFUlRFWF9BSV9TQ09QRSkgPCAwKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGF1dGggc2NvcGVzLiBTY29wZXMgbXVzdCBpbmNsdWRlOiAke1JFUVVJUkVEX1ZFUlRFWF9BSV9TQ09QRX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXV0aE9wdGlvbnM7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jbGFzcyBOb2RlV2ViU29ja2V0RmFjdG9yeSB7XG4gICAgY3JlYXRlKHVybCwgaGVhZGVycywgY2FsbGJhY2tzKSB7XG4gICAgICAgIHJldHVybiBuZXcgTm9kZVdlYlNvY2tldCh1cmwsIGhlYWRlcnMsIGNhbGxiYWNrcyk7XG4gICAgfVxufVxuY2xhc3MgTm9kZVdlYlNvY2tldCB7XG4gICAgY29uc3RydWN0b3IodXJsLCBoZWFkZXJzLCBjYWxsYmFja3MpIHtcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzID0gY2FsbGJhY2tzO1xuICAgIH1cbiAgICBjb25uZWN0KCkge1xuICAgICAgICB0aGlzLndzID0gbmV3IE5vZGVXc19fbmFtZXNwYWNlLldlYlNvY2tldCh0aGlzLnVybCwgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfSk7XG4gICAgICAgIHRoaXMud3Mub25vcGVuID0gdGhpcy5jYWxsYmFja3Mub25vcGVuO1xuICAgICAgICB0aGlzLndzLm9uZXJyb3IgPSB0aGlzLmNhbGxiYWNrcy5vbmVycm9yO1xuICAgICAgICB0aGlzLndzLm9uY2xvc2UgPSB0aGlzLmNhbGxiYWNrcy5vbmNsb3NlO1xuICAgICAgICB0aGlzLndzLm9ubWVzc2FnZSA9IHRoaXMuY2FsbGJhY2tzLm9ubWVzc2FnZTtcbiAgICB9XG4gICAgc2VuZChtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0aGlzLndzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2ViU29ja2V0IGlzIG5vdCBjb25uZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndzLnNlbmQobWVzc2FnZSk7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy53cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYlNvY2tldCBpcyBub3QgY29ubmVjdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cy5jbG9zZSgpO1xuICAgIH1cbn1cblxuY29uc3QgTUFYX0NIVU5LX1NJWkUgPSAxMDI0ICogMTAyNCAqIDg7IC8vIGJ5dGVzXG5hc3luYyBmdW5jdGlvbiB1cGxvYWRCbG9iKGZpbGUsIHVwbG9hZFVybCwgYXBpQ2xpZW50KSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBsZXQgZmlsZVNpemUgPSAwO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGxldCByZXNwb25zZSA9IG5ldyBIdHRwUmVzcG9uc2UobmV3IFJlc3BvbnNlKCkpO1xuICAgIGxldCB1cGxvYWRDb21tYW5kID0gJ3VwbG9hZCc7XG4gICAgZmlsZVNpemUgPSBmaWxlLnNpemU7XG4gICAgd2hpbGUgKG9mZnNldCA8IGZpbGVTaXplKSB7XG4gICAgICAgIGNvbnN0IGNodW5rU2l6ZSA9IE1hdGgubWluKE1BWF9DSFVOS19TSVpFLCBmaWxlU2l6ZSAtIG9mZnNldCk7XG4gICAgICAgIGNvbnN0IGNodW5rID0gZmlsZS5zbGljZShvZmZzZXQsIG9mZnNldCArIGNodW5rU2l6ZSk7XG4gICAgICAgIGlmIChvZmZzZXQgKyBjaHVua1NpemUgPj0gZmlsZVNpemUpIHtcbiAgICAgICAgICAgIHVwbG9hZENvbW1hbmQgKz0gJywgZmluYWxpemUnO1xuICAgICAgICB9XG4gICAgICAgIHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LnJlcXVlc3Qoe1xuICAgICAgICAgICAgcGF0aDogJycsXG4gICAgICAgICAgICBib2R5OiBjaHVuayxcbiAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGh0dHBPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgYXBpVmVyc2lvbjogJycsXG4gICAgICAgICAgICAgICAgYmFzZVVybDogdXBsb2FkVXJsLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgJ1gtR29vZy1VcGxvYWQtQ29tbWFuZCc6IHVwbG9hZENvbW1hbmQsXG4gICAgICAgICAgICAgICAgICAgICdYLUdvb2ctVXBsb2FkLU9mZnNldCc6IFN0cmluZyhvZmZzZXQpLFxuICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1MZW5ndGgnOiBTdHJpbmcoY2h1bmtTaXplKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIG9mZnNldCArPSBjaHVua1NpemU7XG4gICAgICAgIC8vIFRoZSBgeC1nb29nLXVwbG9hZC1zdGF0dXNgIGhlYWRlciBmaWVsZCBjYW4gYmUgYGFjdGl2ZWAsIGBmaW5hbGAgYW5kXG4gICAgICAgIC8vYGNhbmNlbGxlZGAgaW4gcmVzcG9zbmUuXG4gICAgICAgIGlmICgoKF9hID0gcmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLmhlYWRlcnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVsneC1nb29nLXVwbG9hZC1zdGF0dXMnXSkgIT09ICdhY3RpdmUnKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPKGIvNDAxMzkxNDMwKSBJbnZlc3RpZ2F0ZSB3aHkgdGhlIHVwbG9hZCBzdGF0dXMgaXMgbm90IGZpbmFsaXplZFxuICAgICAgICAvLyBldmVuIHRob3VnaCBhbGwgY29udGVudCBoYXMgYmVlbiB1cGxvYWRlZC5cbiAgICAgICAgaWYgKGZpbGVTaXplIDw9IG9mZnNldCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbGwgY29udGVudCBoYXMgYmVlbiB1cGxvYWRlZCwgYnV0IHRoZSB1cGxvYWQgc3RhdHVzIGlzIG5vdCBmaW5hbGl6ZWQuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2VKc29uID0gKGF3YWl0IChyZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UuanNvbigpKSk7XG4gICAgaWYgKCgoX2IgPSByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UuaGVhZGVycykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iWyd4LWdvb2ctdXBsb2FkLXN0YXR1cyddKSAhPT0gJ2ZpbmFsJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byB1cGxvYWQgZmlsZTogVXBsb2FkIHN0YXR1cyBpcyBub3QgZmluYWxpemVkLicpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2VKc29uWydmaWxlJ107XG59XG5hc3luYyBmdW5jdGlvbiBnZXRCbG9iU3RhdChmaWxlKSB7XG4gICAgY29uc3QgZmlsZVN0YXQgPSB7IHNpemU6IGZpbGUuc2l6ZSwgdHlwZTogZmlsZS50eXBlIH07XG4gICAgcmV0dXJuIGZpbGVTdGF0O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jbGFzcyBOb2RlVXBsb2FkZXIge1xuICAgIGFzeW5jIHN0YXQoZmlsZSkge1xuICAgICAgICBjb25zdCBmaWxlU3RhdCA9IHsgc2l6ZTogMCwgdHlwZTogdW5kZWZpbmVkIH07XG4gICAgICAgIGlmICh0eXBlb2YgZmlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsU3RhdCA9IGF3YWl0IGZzX19uYW1lc3BhY2Uuc3RhdChmaWxlKTtcbiAgICAgICAgICAgIGZpbGVTdGF0LnNpemUgPSBvcmlnaW5hbFN0YXQuc2l6ZTtcbiAgICAgICAgICAgIGZpbGVTdGF0LnR5cGUgPSB0aGlzLmluZmVyTWltZVR5cGUoZmlsZSk7XG4gICAgICAgICAgICByZXR1cm4gZmlsZVN0YXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgZ2V0QmxvYlN0YXQoZmlsZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgdXBsb2FkKGZpbGUsIHVwbG9hZFVybCwgYXBpQ2xpZW50KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZmlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnVwbG9hZEZpbGVGcm9tUGF0aChmaWxlLCB1cGxvYWRVcmwsIGFwaUNsaWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdXBsb2FkQmxvYihmaWxlLCB1cGxvYWRVcmwsIGFwaUNsaWVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5mZXJzIHRoZSBNSU1FIHR5cGUgb2YgYSBmaWxlIGJhc2VkIG9uIGl0cyBleHRlbnNpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmlsZVBhdGggVGhlIHBhdGggdG8gdGhlIGZpbGUuXG4gICAgICogQHJldHVybnMgVGhlIE1JTUUgdHlwZSBvZiB0aGUgZmlsZSwgb3IgdW5kZWZpbmVkIGlmIGl0IGNhbm5vdCBiZSBpbmZlcnJlZC5cbiAgICAgKi9cbiAgICBpbmZlck1pbWVUeXBlKGZpbGVQYXRoKSB7XG4gICAgICAgIC8vIEdldCB0aGUgZmlsZSBleHRlbnNpb24uXG4gICAgICAgIGNvbnN0IGZpbGVFeHRlbnNpb24gPSBmaWxlUGF0aC5zbGljZShmaWxlUGF0aC5sYXN0SW5kZXhPZignLicpICsgMSk7XG4gICAgICAgIC8vIENyZWF0ZSBhIG1hcCBvZiBmaWxlIGV4dGVuc2lvbnMgdG8gTUlNRSB0eXBlcy5cbiAgICAgICAgY29uc3QgbWltZVR5cGVzID0ge1xuICAgICAgICAgICAgJ2FhYyc6ICdhdWRpby9hYWMnLFxuICAgICAgICAgICAgJ2Fidyc6ICdhcHBsaWNhdGlvbi94LWFiaXdvcmQnLFxuICAgICAgICAgICAgJ2FyYyc6ICdhcHBsaWNhdGlvbi94LWZyZWVhcmMnLFxuICAgICAgICAgICAgJ2F2aSc6ICd2aWRlby94LW1zdmlkZW8nLFxuICAgICAgICAgICAgJ2F6dyc6ICdhcHBsaWNhdGlvbi92bmQuYW1hem9uLmVib29rJyxcbiAgICAgICAgICAgICdiaW4nOiAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyxcbiAgICAgICAgICAgICdibXAnOiAnaW1hZ2UvYm1wJyxcbiAgICAgICAgICAgICdieic6ICdhcHBsaWNhdGlvbi94LWJ6aXAnLFxuICAgICAgICAgICAgJ2J6Mic6ICdhcHBsaWNhdGlvbi94LWJ6aXAyJyxcbiAgICAgICAgICAgICdjc2gnOiAnYXBwbGljYXRpb24veC1jc2gnLFxuICAgICAgICAgICAgJ2Nzcyc6ICd0ZXh0L2NzcycsXG4gICAgICAgICAgICAnY3N2JzogJ3RleHQvY3N2JyxcbiAgICAgICAgICAgICdkb2MnOiAnYXBwbGljYXRpb24vbXN3b3JkJyxcbiAgICAgICAgICAgICdkb2N4JzogJ2FwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLmRvY3VtZW50JyxcbiAgICAgICAgICAgICdlb3QnOiAnYXBwbGljYXRpb24vdm5kLm1zLWZvbnRvYmplY3QnLFxuICAgICAgICAgICAgJ2VwdWInOiAnYXBwbGljYXRpb24vZXB1Yit6aXAnLFxuICAgICAgICAgICAgJ2d6JzogJ2FwcGxpY2F0aW9uL2d6aXAnLFxuICAgICAgICAgICAgJ2dpZic6ICdpbWFnZS9naWYnLFxuICAgICAgICAgICAgJ2h0bSc6ICd0ZXh0L2h0bWwnLFxuICAgICAgICAgICAgJ2h0bWwnOiAndGV4dC9odG1sJyxcbiAgICAgICAgICAgICdpY28nOiAnaW1hZ2Uvdm5kLm1pY3Jvc29mdC5pY29uJyxcbiAgICAgICAgICAgICdpY3MnOiAndGV4dC9jYWxlbmRhcicsXG4gICAgICAgICAgICAnamFyJzogJ2FwcGxpY2F0aW9uL2phdmEtYXJjaGl2ZScsXG4gICAgICAgICAgICAnanBlZyc6ICdpbWFnZS9qcGVnJyxcbiAgICAgICAgICAgICdqcGcnOiAnaW1hZ2UvanBlZycsXG4gICAgICAgICAgICAnanMnOiAndGV4dC9qYXZhc2NyaXB0JyxcbiAgICAgICAgICAgICdqc29uJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgJ2pzb25sZCc6ICdhcHBsaWNhdGlvbi9sZCtqc29uJyxcbiAgICAgICAgICAgICdrbWwnOiAnYXBwbGljYXRpb24vdm5kLmdvb2dsZS1lYXJ0aC5rbWwreG1sJyxcbiAgICAgICAgICAgICdrbXonOiAnYXBwbGljYXRpb24vdm5kLmdvb2dsZS1lYXJ0aC5rbXoreG1sJyxcbiAgICAgICAgICAgICdtanMnOiAndGV4dC9qYXZhc2NyaXB0JyxcbiAgICAgICAgICAgICdtcDMnOiAnYXVkaW8vbXBlZycsXG4gICAgICAgICAgICAnbXA0JzogJ3ZpZGVvL21wNCcsXG4gICAgICAgICAgICAnbXBlZyc6ICd2aWRlby9tcGVnJyxcbiAgICAgICAgICAgICdtcGtnJzogJ2FwcGxpY2F0aW9uL3ZuZC5hcHBsZS5pbnN0YWxsZXIreG1sJyxcbiAgICAgICAgICAgICdvZHQnOiAnYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC50ZXh0JyxcbiAgICAgICAgICAgICdvZ2EnOiAnYXVkaW8vb2dnJyxcbiAgICAgICAgICAgICdvZ3YnOiAndmlkZW8vb2dnJyxcbiAgICAgICAgICAgICdvZ3gnOiAnYXBwbGljYXRpb24vb2dnJyxcbiAgICAgICAgICAgICdvcHVzJzogJ2F1ZGlvL29wdXMnLFxuICAgICAgICAgICAgJ290Zic6ICdmb250L290ZicsXG4gICAgICAgICAgICAncG5nJzogJ2ltYWdlL3BuZycsXG4gICAgICAgICAgICAncGRmJzogJ2FwcGxpY2F0aW9uL3BkZicsXG4gICAgICAgICAgICAncGhwJzogJ2FwcGxpY2F0aW9uL3gtaHR0cGQtcGhwJyxcbiAgICAgICAgICAgICdwcHQnOiAnYXBwbGljYXRpb24vdm5kLm1zLXBvd2VycG9pbnQnLFxuICAgICAgICAgICAgJ3BwdHgnOiAnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnByZXNlbnRhdGlvbm1sLnByZXNlbnRhdGlvbicsXG4gICAgICAgICAgICAncmFyJzogJ2FwcGxpY2F0aW9uL3ZuZC5yYXInLFxuICAgICAgICAgICAgJ3J0Zic6ICdhcHBsaWNhdGlvbi9ydGYnLFxuICAgICAgICAgICAgJ3NoJzogJ2FwcGxpY2F0aW9uL3gtc2gnLFxuICAgICAgICAgICAgJ3N2Zyc6ICdpbWFnZS9zdmcreG1sJyxcbiAgICAgICAgICAgICdzd2YnOiAnYXBwbGljYXRpb24veC1zaG9ja3dhdmUtZmxhc2gnLFxuICAgICAgICAgICAgJ3Rhcic6ICdhcHBsaWNhdGlvbi94LXRhcicsXG4gICAgICAgICAgICAndGlmJzogJ2ltYWdlL3RpZmYnLFxuICAgICAgICAgICAgJ3RpZmYnOiAnaW1hZ2UvdGlmZicsXG4gICAgICAgICAgICAndHMnOiAndmlkZW8vbXAydCcsXG4gICAgICAgICAgICAndHRmJzogJ2ZvbnQvdHRmJyxcbiAgICAgICAgICAgICd0eHQnOiAndGV4dC9wbGFpbicsXG4gICAgICAgICAgICAndnNkJzogJ2FwcGxpY2F0aW9uL3ZuZC52aXNpbycsXG4gICAgICAgICAgICAnd2F2JzogJ2F1ZGlvL3dhdicsXG4gICAgICAgICAgICAnd2ViYSc6ICdhdWRpby93ZWJtJyxcbiAgICAgICAgICAgICd3ZWJtJzogJ3ZpZGVvL3dlYm0nLFxuICAgICAgICAgICAgJ3dlYnAnOiAnaW1hZ2Uvd2VicCcsXG4gICAgICAgICAgICAnd29mZic6ICdmb250L3dvZmYnLFxuICAgICAgICAgICAgJ3dvZmYyJzogJ2ZvbnQvd29mZjInLFxuICAgICAgICAgICAgJ3hodG1sJzogJ2FwcGxpY2F0aW9uL3hodG1sK3htbCcsXG4gICAgICAgICAgICAneGxzJzogJ2FwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbCcsXG4gICAgICAgICAgICAneGxzeCc6ICdhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC5zaGVldCcsXG4gICAgICAgICAgICAneG1sJzogJ2FwcGxpY2F0aW9uL3htbCcsXG4gICAgICAgICAgICAneHVsJzogJ2FwcGxpY2F0aW9uL3ZuZC5tb3ppbGxhLnh1bCt4bWwnLFxuICAgICAgICAgICAgJ3ppcCc6ICdhcHBsaWNhdGlvbi96aXAnLFxuICAgICAgICAgICAgJzNncCc6ICd2aWRlby8zZ3BwJyxcbiAgICAgICAgICAgICczZzInOiAndmlkZW8vM2dwcDInLFxuICAgICAgICAgICAgJzd6JzogJ2FwcGxpY2F0aW9uL3gtN3otY29tcHJlc3NlZCcsXG4gICAgICAgIH07XG4gICAgICAgIC8vIExvb2sgdXAgdGhlIE1JTUUgdHlwZSBiYXNlZCBvbiB0aGUgZmlsZSBleHRlbnNpb24uXG4gICAgICAgIGNvbnN0IG1pbWVUeXBlID0gbWltZVR5cGVzW2ZpbGVFeHRlbnNpb24udG9Mb3dlckNhc2UoKV07XG4gICAgICAgIC8vIFJldHVybiB0aGUgTUlNRSB0eXBlLlxuICAgICAgICByZXR1cm4gbWltZVR5cGU7XG4gICAgfVxuICAgIGFzeW5jIHVwbG9hZEZpbGVGcm9tUGF0aChmaWxlLCB1cGxvYWRVcmwsIGFwaUNsaWVudCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgZmlsZVNpemUgPSAwO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gbmV3IEh0dHBSZXNwb25zZShuZXcgUmVzcG9uc2UoKSk7XG4gICAgICAgIGxldCB1cGxvYWRDb21tYW5kID0gJ3VwbG9hZCc7XG4gICAgICAgIGxldCBmaWxlSGFuZGxlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZmlsZUhhbmRsZSA9IGF3YWl0IGZzX19uYW1lc3BhY2Uub3BlbihmaWxlLCAncicpO1xuICAgICAgICAgICAgaWYgKCFmaWxlSGFuZGxlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gb3BlbiBmaWxlYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWxlU2l6ZSA9IChhd2FpdCBmaWxlSGFuZGxlLnN0YXQoKSkuc2l6ZTtcbiAgICAgICAgICAgIHdoaWxlIChvZmZzZXQgPCBmaWxlU2l6ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rU2l6ZSA9IE1hdGgubWluKE1BWF9DSFVOS19TSVpFLCBmaWxlU2l6ZSAtIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCArIGNodW5rU2l6ZSA+PSBmaWxlU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICB1cGxvYWRDb21tYW5kICs9ICcsIGZpbmFsaXplJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmtTaXplKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGJ5dGVzUmVhZDogYnl0ZXNSZWFkIH0gPSBhd2FpdCBmaWxlSGFuZGxlLnJlYWQoYnVmZmVyLCAwLCBjaHVua1NpemUsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgaWYgKGJ5dGVzUmVhZCAhPT0gY2h1bmtTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHJlYWQgJHtjaHVua1NpemV9IGJ5dGVzIGZyb20gZmlsZSBhdCBvZmZzZXQgJHtvZmZzZXR9LiBieXRlcyBhY3R1YWxseSByZWFkOiAke2J5dGVzUmVhZH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBuZXcgQmxvYihbYnVmZmVyXSk7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgIHBhdGg6ICcnLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiBjaHVuayxcbiAgICAgICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgICAgICBodHRwT3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBpVmVyc2lvbjogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlVXJsOiB1cGxvYWRVcmwsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1gtR29vZy1VcGxvYWQtQ29tbWFuZCc6IHVwbG9hZENvbW1hbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1gtR29vZy1VcGxvYWQtT2Zmc2V0JzogU3RyaW5nKG9mZnNldCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtTGVuZ3RoJzogU3RyaW5nKGJ5dGVzUmVhZCksXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSBieXRlc1JlYWQ7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGB4LWdvb2ctdXBsb2FkLXN0YXR1c2AgaGVhZGVyIGZpZWxkIGNhbiBiZSBgYWN0aXZlYCwgYGZpbmFsYCBhbmRcbiAgICAgICAgICAgICAgICAvL2BjYW5jZWxsZWRgIGluIHJlc3Bvc25lLlxuICAgICAgICAgICAgICAgIGlmICgoKF9hID0gcmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLmhlYWRlcnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVsneC1nb29nLXVwbG9hZC1zdGF0dXMnXSkgIT09ICdhY3RpdmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZmlsZVNpemUgPD0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQWxsIGNvbnRlbnQgaGFzIGJlZW4gdXBsb2FkZWQsIGJ1dCB0aGUgdXBsb2FkIHN0YXR1cyBpcyBub3QgZmluYWxpemVkLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlSnNvbiA9IChhd2FpdCAocmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLmpzb24oKSkpO1xuICAgICAgICAgICAgaWYgKCgoX2IgPSByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UuaGVhZGVycykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iWyd4LWdvb2ctdXBsb2FkLXN0YXR1cyddKSAhPT0gJ2ZpbmFsJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHVwbG9hZCBmaWxlOiBVcGxvYWQgc3RhdHVzIGlzIG5vdCBmaW5hbGl6ZWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2VKc29uWydmaWxlJ107XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAvLyBFbnN1cmUgdGhlIGZpbGUgaGFuZGxlIGlzIGFsd2F5cyBjbG9zZWRcbiAgICAgICAgICAgIGlmIChmaWxlSGFuZGxlKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZmlsZUhhbmRsZS5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jb25zdCBMQU5HVUFHRV9MQUJFTF9QUkVGSVggPSAnZ2wtbm9kZS8nO1xuLyoqXG4gKiBUaGUgR29vZ2xlIEdlbkFJIFNESy5cbiAqXG4gKiBAcmVtYXJrc1xuICogUHJvdmlkZXMgYWNjZXNzIHRvIHRoZSBHZW5BSSBmZWF0dXJlcyB0aHJvdWdoIGVpdGhlciB0aGUge0BsaW5rXG4gKiBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vdmVydGV4LWFpL2RvY3MvcmVmZXJlbmNlL3Jlc3QgfCBHZW1pbmkgQVBJfSBvclxuICogdGhlIHtAbGluayBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vdmVydGV4LWFpL2RvY3MvcmVmZXJlbmNlL3Jlc3QgfCBWZXJ0ZXggQUlcbiAqIEFQSX0uXG4gKlxuICogVGhlIHtAbGluayBHb29nbGVHZW5BSU9wdGlvbnMudmVydGV4YWl9IHZhbHVlIGRldGVybWluZXMgd2hpY2ggb2YgdGhlIEFQSVxuICogc2VydmljZXMgdG8gdXNlLlxuICpcbiAqIFdoZW4gdXNpbmcgdGhlIEdlbWluaSBBUEksIGEge0BsaW5rIEdvb2dsZUdlbkFJT3B0aW9ucy5hcGlLZXl9IG11c3QgYWxzbyBiZVxuICogc2V0LiBXaGVuIHVzaW5nIFZlcnRleCBBSSwgYm90aCB7QGxpbmsgR29vZ2xlR2VuQUlPcHRpb25zLnByb2plY3R9IGFuZCB7QGxpbmtcbiAqIEdvb2dsZUdlbkFJT3B0aW9ucy5sb2NhdGlvbn0gbXVzdCBiZSBzZXQsIG9yIGEge0BsaW5rXG4gKiBHb29nbGVHZW5BSU9wdGlvbnMuYXBpS2V5fSBtdXN0IGJlIHNldCB3aGVuIHVzaW5nIEV4cHJlc3MgTW9kZS5cbiAqXG4gKiBFeHBsaWNpdGx5IHBhc3NlZCBpbiB2YWx1ZXMgaW4ge0BsaW5rIEdvb2dsZUdlbkFJT3B0aW9uc30gd2lsbCBhbHdheXMgdGFrZVxuICogcHJlY2VkZW5jZSBvdmVyIGVudmlyb25tZW50IHZhcmlhYmxlcy4gSWYgYm90aCBwcm9qZWN0L2xvY2F0aW9uIGFuZCBhcGlfa2V5XG4gKiBleGlzdCBpbiB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVzLCB0aGUgcHJvamVjdC9sb2NhdGlvbiB3aWxsIGJlIHVzZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIEluaXRpYWxpemluZyB0aGUgU0RLIGZvciB1c2luZyB0aGUgR2VtaW5pIEFQSTpcbiAqIGBgYHRzXG4gKiBpbXBvcnQge0dvb2dsZUdlbkFJfSBmcm9tICdAZ29vZ2xlL2dlbmFpJztcbiAqIGNvbnN0IGFpID0gbmV3IEdvb2dsZUdlbkFJKHthcGlLZXk6ICdHRU1JTklfQVBJX0tFWSd9KTtcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBJbml0aWFsaXppbmcgdGhlIFNESyBmb3IgdXNpbmcgdGhlIFZlcnRleCBBSSBBUEk6XG4gKiBgYGB0c1xuICogaW1wb3J0IHtHb29nbGVHZW5BSX0gZnJvbSAnQGdvb2dsZS9nZW5haSc7XG4gKiBjb25zdCBhaSA9IG5ldyBHb29nbGVHZW5BSSh7XG4gKiAgIHZlcnRleGFpOiB0cnVlLFxuICogICBwcm9qZWN0OiAnUFJPSkVDVF9JRCcsXG4gKiAgIGxvY2F0aW9uOiAnUFJPSkVDVF9MT0NBVElPTidcbiAqIH0pO1xuICogYGBgXG4gKlxuICovXG5jbGFzcyBHb29nbGVHZW5BSSB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgICAgICAvLyBWYWxpZGF0ZSBleHBsaWNpdGx5IHNldCBpbml0aWFsaXplciB2YWx1ZXMuXG4gICAgICAgIGlmICgob3B0aW9ucy5wcm9qZWN0IHx8IG9wdGlvbnMubG9jYXRpb24pICYmIG9wdGlvbnMuYXBpS2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2plY3QvbG9jYXRpb24gYW5kIEFQSSBrZXkgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZSBpbiB0aGUgY2xpZW50IGluaXRpYWxpemVyLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmVydGV4YWkgPVxuICAgICAgICAgICAgKF9iID0gKF9hID0gb3B0aW9ucy52ZXJ0ZXhhaSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZ2V0Qm9vbGVhbkVudignR09PR0xFX0dFTkFJX1VTRV9WRVJURVhBSScpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxzZTtcbiAgICAgICAgY29uc3QgZW52QXBpS2V5ID0gZ2V0RW52KCdHT09HTEVfQVBJX0tFWScpO1xuICAgICAgICBjb25zdCBlbnZQcm9qZWN0ID0gZ2V0RW52KCdHT09HTEVfQ0xPVURfUFJPSkVDVCcpO1xuICAgICAgICBjb25zdCBlbnZMb2NhdGlvbiA9IGdldEVudignR09PR0xFX0NMT1VEX0xPQ0FUSU9OJyk7XG4gICAgICAgIHRoaXMuYXBpS2V5ID0gKF9jID0gb3B0aW9ucy5hcGlLZXkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGVudkFwaUtleTtcbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gKF9kID0gb3B0aW9ucy5wcm9qZWN0KSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBlbnZQcm9qZWN0O1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gKF9lID0gb3B0aW9ucy5sb2NhdGlvbikgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogZW52TG9jYXRpb247XG4gICAgICAgIC8vIEhhbmRsZSB3aGVuIHRvIHVzZSBWZXJ0ZXggQUkgaW4gZXhwcmVzcyBtb2RlIChhcGkga2V5KVxuICAgICAgICBpZiAob3B0aW9ucy52ZXJ0ZXhhaSkge1xuICAgICAgICAgICAgLy8gRXhwbGljaXQgYXBpX2tleSBhbmQgZXhwbGljaXQgcHJvamVjdC9sb2NhdGlvbiBhbHJlYWR5IGhhbmRsZWQgYWJvdmUuXG4gICAgICAgICAgICBpZiAoKGVudlByb2plY3QgfHwgZW52TG9jYXRpb24pICYmIG9wdGlvbnMuYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgLy8gRXhwbGljaXQgYXBpX2tleSB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgaW1wbGljaXQgcHJvamVjdC9sb2NhdGlvbi5cbiAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKCdUaGUgdXNlciBwcm92aWRlZCBWZXJ0ZXggQUkgQVBJIGtleSB3aWxsIHRha2UgcHJlY2VkZW5jZSBvdmVyJyArXG4gICAgICAgICAgICAgICAgICAgICcgdGhlIHByb2plY3QvbG9jYXRpb24gZnJvbSB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVzLicpO1xuICAgICAgICAgICAgICAgIHRoaXMucHJvamVjdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2F0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKG9wdGlvbnMucHJvamVjdCB8fCBvcHRpb25zLmxvY2F0aW9uKSAmJiBlbnZBcGlLZXkpIHtcbiAgICAgICAgICAgICAgICAvLyBFeHBsaWNpdCBwcm9qZWN0L2xvY2F0aW9uIHRha2VzIHByZWNlZGVuY2Ugb3ZlciBpbXBsaWNpdCBhcGlfa2V5LlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ1RoZSB1c2VyIHByb3ZpZGVkIHByb2plY3QvbG9jYXRpb24gd2lsbCB0YWtlIHByZWNlZGVuY2Ugb3ZlcicgK1xuICAgICAgICAgICAgICAgICAgICAnIHRoZSBBUEkga2V5IGZyb20gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlcy4nKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFwaUtleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKChlbnZQcm9qZWN0IHx8IGVudkxvY2F0aW9uKSAmJiBlbnZBcGlLZXkpIHtcbiAgICAgICAgICAgICAgICAvLyBJbXBsaWNpdCBwcm9qZWN0L2xvY2F0aW9uIHRha2VzIHByZWNlZGVuY2Ugb3ZlciBpbXBsaWNpdCBhcGlfa2V5LlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ1RoZSBwcm9qZWN0L2xvY2F0aW9uIGZyb20gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlcyB3aWxsIHRha2UnICtcbiAgICAgICAgICAgICAgICAgICAgJyBwcmVjZWRlbmNlIG92ZXIgdGhlIEFQSSBrZXkgZnJvbSB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVzLicpO1xuICAgICAgICAgICAgICAgIHRoaXMuYXBpS2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJhc2VVcmwgPSBnZXRCYXNlVXJsKG9wdGlvbnMsIGdldEVudignR09PR0xFX1ZFUlRFWF9CQVNFX1VSTCcpLCBnZXRFbnYoJ0dPT0dMRV9HRU1JTklfQkFTRV9VUkwnKSk7XG4gICAgICAgIGlmIChiYXNlVXJsKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5odHRwT3B0aW9ucykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuaHR0cE9wdGlvbnMuYmFzZVVybCA9IGJhc2VVcmw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmh0dHBPcHRpb25zID0geyBiYXNlVXJsOiBiYXNlVXJsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hcGlWZXJzaW9uID0gb3B0aW9ucy5hcGlWZXJzaW9uO1xuICAgICAgICBjb25zdCBhdXRoID0gbmV3IE5vZGVBdXRoKHtcbiAgICAgICAgICAgIGFwaUtleTogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICBnb29nbGVBdXRoT3B0aW9uczogb3B0aW9ucy5nb29nbGVBdXRoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gbmV3IEFwaUNsaWVudCh7XG4gICAgICAgICAgICBhdXRoOiBhdXRoLFxuICAgICAgICAgICAgcHJvamVjdDogdGhpcy5wcm9qZWN0LFxuICAgICAgICAgICAgbG9jYXRpb246IHRoaXMubG9jYXRpb24sXG4gICAgICAgICAgICBhcGlWZXJzaW9uOiB0aGlzLmFwaVZlcnNpb24sXG4gICAgICAgICAgICBhcGlLZXk6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgdmVydGV4YWk6IHRoaXMudmVydGV4YWksXG4gICAgICAgICAgICBodHRwT3B0aW9uczogb3B0aW9ucy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgIHVzZXJBZ2VudEV4dHJhOiBMQU5HVUFHRV9MQUJFTF9QUkVGSVggKyBwcm9jZXNzLnZlcnNpb24sXG4gICAgICAgICAgICB1cGxvYWRlcjogbmV3IE5vZGVVcGxvYWRlcigpLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tb2RlbHMgPSBuZXcgTW9kZWxzKHRoaXMuYXBpQ2xpZW50KTtcbiAgICAgICAgdGhpcy5saXZlID0gbmV3IExpdmUodGhpcy5hcGlDbGllbnQsIGF1dGgsIG5ldyBOb2RlV2ViU29ja2V0RmFjdG9yeSgpKTtcbiAgICAgICAgdGhpcy5jaGF0cyA9IG5ldyBDaGF0cyh0aGlzLm1vZGVscywgdGhpcy5hcGlDbGllbnQpO1xuICAgICAgICB0aGlzLmNhY2hlcyA9IG5ldyBDYWNoZXModGhpcy5hcGlDbGllbnQpO1xuICAgICAgICB0aGlzLmZpbGVzID0gbmV3IEZpbGVzKHRoaXMuYXBpQ2xpZW50KTtcbiAgICAgICAgdGhpcy5vcGVyYXRpb25zID0gbmV3IE9wZXJhdGlvbnModGhpcy5hcGlDbGllbnQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEVudihlbnYpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICByZXR1cm4gKF9jID0gKF9iID0gKF9hID0gcHJvY2VzcyA9PT0gbnVsbCB8fCBwcm9jZXNzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9jZXNzLmVudikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2Vudl0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50cmltKCkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGdldEJvb2xlYW5FbnYoZW52KSB7XG4gICAgcmV0dXJuIHN0cmluZ1RvQm9vbGVhbihnZXRFbnYoZW52KSk7XG59XG5mdW5jdGlvbiBzdHJpbmdUb0Jvb2xlYW4oc3RyKSB7XG4gICAgaWYgKHN0ciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHN0ci50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG59XG5cbmV4cG9ydHMuQ2FjaGVzID0gQ2FjaGVzO1xuZXhwb3J0cy5DaGF0ID0gQ2hhdDtcbmV4cG9ydHMuQ2hhdHMgPSBDaGF0cztcbmV4cG9ydHMuQ29tcHV0ZVRva2Vuc1Jlc3BvbnNlID0gQ29tcHV0ZVRva2Vuc1Jlc3BvbnNlO1xuZXhwb3J0cy5Db3VudFRva2Vuc1Jlc3BvbnNlID0gQ291bnRUb2tlbnNSZXNwb25zZTtcbmV4cG9ydHMuQ3JlYXRlRmlsZVJlc3BvbnNlID0gQ3JlYXRlRmlsZVJlc3BvbnNlO1xuZXhwb3J0cy5EZWxldGVDYWNoZWRDb250ZW50UmVzcG9uc2UgPSBEZWxldGVDYWNoZWRDb250ZW50UmVzcG9uc2U7XG5leHBvcnRzLkRlbGV0ZUZpbGVSZXNwb25zZSA9IERlbGV0ZUZpbGVSZXNwb25zZTtcbmV4cG9ydHMuRW1iZWRDb250ZW50UmVzcG9uc2UgPSBFbWJlZENvbnRlbnRSZXNwb25zZTtcbmV4cG9ydHMuRmlsZXMgPSBGaWxlcztcbmV4cG9ydHMuRnVuY3Rpb25SZXNwb25zZSA9IEZ1bmN0aW9uUmVzcG9uc2U7XG5leHBvcnRzLkdlbmVyYXRlQ29udGVudFJlc3BvbnNlID0gR2VuZXJhdGVDb250ZW50UmVzcG9uc2U7XG5leHBvcnRzLkdlbmVyYXRlQ29udGVudFJlc3BvbnNlUHJvbXB0RmVlZGJhY2sgPSBHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZVByb21wdEZlZWRiYWNrO1xuZXhwb3J0cy5HZW5lcmF0ZUNvbnRlbnRSZXNwb25zZVVzYWdlTWV0YWRhdGEgPSBHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZVVzYWdlTWV0YWRhdGE7XG5leHBvcnRzLkdlbmVyYXRlSW1hZ2VzUmVzcG9uc2UgPSBHZW5lcmF0ZUltYWdlc1Jlc3BvbnNlO1xuZXhwb3J0cy5HZW5lcmF0ZVZpZGVvc1Jlc3BvbnNlID0gR2VuZXJhdGVWaWRlb3NSZXNwb25zZTtcbmV4cG9ydHMuR29vZ2xlR2VuQUkgPSBHb29nbGVHZW5BSTtcbmV4cG9ydHMuSHR0cFJlc3BvbnNlID0gSHR0cFJlc3BvbnNlO1xuZXhwb3J0cy5MaXN0Q2FjaGVkQ29udGVudHNSZXNwb25zZSA9IExpc3RDYWNoZWRDb250ZW50c1Jlc3BvbnNlO1xuZXhwb3J0cy5MaXN0RmlsZXNSZXNwb25zZSA9IExpc3RGaWxlc1Jlc3BvbnNlO1xuZXhwb3J0cy5MaXZlID0gTGl2ZTtcbmV4cG9ydHMuTGl2ZUNsaWVudFRvb2xSZXNwb25zZSA9IExpdmVDbGllbnRUb29sUmVzcG9uc2U7XG5leHBvcnRzLkxpdmVTZW5kVG9vbFJlc3BvbnNlUGFyYW1ldGVycyA9IExpdmVTZW5kVG9vbFJlc3BvbnNlUGFyYW1ldGVycztcbmV4cG9ydHMuTW9kZWxzID0gTW9kZWxzO1xuZXhwb3J0cy5PcGVyYXRpb25zID0gT3BlcmF0aW9ucztcbmV4cG9ydHMuUGFnZXIgPSBQYWdlcjtcbmV4cG9ydHMuUmVwbGF5UmVzcG9uc2UgPSBSZXBsYXlSZXNwb25zZTtcbmV4cG9ydHMuU2Vzc2lvbiA9IFNlc3Npb247XG5leHBvcnRzLmNyZWF0ZU1vZGVsQ29udGVudCA9IGNyZWF0ZU1vZGVsQ29udGVudDtcbmV4cG9ydHMuY3JlYXRlUGFydEZyb21CYXNlNjQgPSBjcmVhdGVQYXJ0RnJvbUJhc2U2NDtcbmV4cG9ydHMuY3JlYXRlUGFydEZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ID0gY3JlYXRlUGFydEZyb21Db2RlRXhlY3V0aW9uUmVzdWx0O1xuZXhwb3J0cy5jcmVhdGVQYXJ0RnJvbUV4ZWN1dGFibGVDb2RlID0gY3JlYXRlUGFydEZyb21FeGVjdXRhYmxlQ29kZTtcbmV4cG9ydHMuY3JlYXRlUGFydEZyb21GdW5jdGlvbkNhbGwgPSBjcmVhdGVQYXJ0RnJvbUZ1bmN0aW9uQ2FsbDtcbmV4cG9ydHMuY3JlYXRlUGFydEZyb21GdW5jdGlvblJlc3BvbnNlID0gY3JlYXRlUGFydEZyb21GdW5jdGlvblJlc3BvbnNlO1xuZXhwb3J0cy5jcmVhdGVQYXJ0RnJvbVRleHQgPSBjcmVhdGVQYXJ0RnJvbVRleHQ7XG5leHBvcnRzLmNyZWF0ZVBhcnRGcm9tVXJpID0gY3JlYXRlUGFydEZyb21Vcmk7XG5leHBvcnRzLmNyZWF0ZVVzZXJDb250ZW50ID0gY3JlYXRlVXNlckNvbnRlbnQ7XG5leHBvcnRzLnNldERlZmF1bHRCYXNlVXJscyA9IHNldERlZmF1bHRCYXNlVXJscztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbImdvb2dsZUF1dGhMaWJyYXJ5IiwicmVxdWlyZSIsIk5vZGVXcyIsImZzIiwiX2ludGVyb3BOYW1lc3BhY2VEZWZhdWx0IiwiZSIsIm4iLCJPYmplY3QiLCJjcmVhdGUiLCJrZXlzIiwiZm9yRWFjaCIsImsiLCJkIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZGVmaW5lUHJvcGVydHkiLCJnZXQiLCJlbnVtZXJhYmxlIiwiZGVmYXVsdCIsImZyZWV6ZSIsIk5vZGVXc19fbmFtZXNwYWNlIiwiZnNfX25hbWVzcGFjZSIsIl9kZWZhdWx0QmFzZUdlbWluaVVybCIsInVuZGVmaW5lZCIsIl9kZWZhdWx0QmFzZVZlcnRleFVybCIsInNldERlZmF1bHRCYXNlVXJscyIsImJhc2VVcmxQYXJhbXMiLCJnZW1pbmlVcmwiLCJ2ZXJ0ZXhVcmwiLCJnZXREZWZhdWx0QmFzZVVybHMiLCJnZXRCYXNlVXJsIiwib3B0aW9ucyIsInZlcnRleEJhc2VVcmxGcm9tRW52IiwiZ2VtaW5pQmFzZVVybEZyb21FbnYiLCJfYSIsIl9iIiwiX2MiLCJodHRwT3B0aW9ucyIsImJhc2VVcmwiLCJkZWZhdWx0QmFzZVVybHMiLCJ2ZXJ0ZXhhaSIsIkJhc2VNb2R1bGUiLCJmb3JtYXRNYXAiLCJ0ZW1wbGF0ZVN0cmluZyIsInZhbHVlTWFwIiwicmVnZXgiLCJyZXBsYWNlIiwibWF0Y2giLCJrZXkiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJ2YWx1ZSIsIlN0cmluZyIsIkVycm9yIiwic2V0VmFsdWVCeVBhdGgiLCJkYXRhIiwiaSIsImxlbmd0aCIsImVuZHNXaXRoIiwia2V5TmFtZSIsInNsaWNlIiwiQXJyYXkiLCJpc0FycmF5IiwiZnJvbSIsImFycmF5RGF0YSIsImoiLCJlbnRyeSIsImtleVRvU2V0IiwiZXhpc3RpbmdEYXRhIiwiYXNzaWduIiwiZ2V0VmFsdWVCeVBhdGgiLCJtYXAiLCJlcnJvciIsIlR5cGVFcnJvciIsInRNb2RlbCIsImFwaUNsaWVudCIsIm1vZGVsIiwiaXNWZXJ0ZXhBSSIsInN0YXJ0c1dpdGgiLCJpbmRleE9mIiwicGFydHMiLCJzcGxpdCIsInRDYWNoZXNNb2RlbCIsInRyYW5zZm9ybWVkTW9kZWwiLCJnZXRQcm9qZWN0IiwiZ2V0TG9jYXRpb24iLCJ0QmxvYnMiLCJibG9icyIsImJsb2IiLCJ0QmxvYiIsInRJbWFnZUJsb2IiLCJ0cmFuc2Zvcm1lZEJsb2IiLCJtaW1lVHlwZSIsInRBdWRpb0Jsb2IiLCJ0UGFydCIsIm9yaWdpbiIsInRleHQiLCJ0UGFydHMiLCJpdGVtIiwiX2lzQ29udGVudCIsIl9pc0Z1bmN0aW9uQ2FsbFBhcnQiLCJfaXNGdW5jdGlvblJlc3BvbnNlUGFydCIsInRDb250ZW50Iiwicm9sZSIsInRDb250ZW50c0ZvckVtYmVkIiwiZmxhdE1hcCIsImNvbnRlbnQiLCJ0Q29udGVudHMiLCJyZXN1bHQiLCJhY2N1bXVsYXRlZFBhcnRzIiwiaXNDb250ZW50QXJyYXkiLCJpc0NvbnRlbnQiLCJwdXNoIiwidFNjaGVtYSIsInNjaGVtYSIsInRTcGVlY2hDb25maWciLCJzcGVlY2hDb25maWciLCJ2b2ljZUNvbmZpZyIsInByZWJ1aWx0Vm9pY2VDb25maWciLCJ2b2ljZU5hbWUiLCJ0VG9vbCIsInRvb2wiLCJ0VG9vbHMiLCJyZXNvdXJjZU5hbWUiLCJjbGllbnQiLCJyZXNvdXJjZVByZWZpeCIsInNwbGl0c0FmdGVyUHJlZml4Iiwic2hvdWxkQXBwZW5kUHJlZml4IiwidENhY2hlZENvbnRlbnROYW1lIiwibmFtZSIsInRCeXRlcyIsImZyb21JbWFnZUJ5dGVzIiwidEZpbGVOYW1lIiwiZnJvbU5hbWUiLCJwYXJ0VG9NbGRldiQyIiwiZnJvbU9iamVjdCIsInRvT2JqZWN0IiwiZnJvbVRob3VnaHQiLCJmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCIsImZyb21FeGVjdXRhYmxlQ29kZSIsImZyb21GaWxlRGF0YSIsImZyb21GdW5jdGlvbkNhbGwiLCJmcm9tRnVuY3Rpb25SZXNwb25zZSIsImZyb21JbmxpbmVEYXRhIiwiZnJvbVRleHQiLCJjb250ZW50VG9NbGRldiQyIiwiZnJvbVBhcnRzIiwiZnJvbVJvbGUiLCJmdW5jdGlvbkRlY2xhcmF0aW9uVG9NbGRldiQyIiwiZnJvbURlc2NyaXB0aW9uIiwiZnJvbVBhcmFtZXRlcnMiLCJnb29nbGVTZWFyY2hUb01sZGV2JDIiLCJkeW5hbWljUmV0cmlldmFsQ29uZmlnVG9NbGRldiQyIiwiZnJvbU1vZGUiLCJmcm9tRHluYW1pY1RocmVzaG9sZCIsImdvb2dsZVNlYXJjaFJldHJpZXZhbFRvTWxkZXYkMiIsImZyb21EeW5hbWljUmV0cmlldmFsQ29uZmlnIiwidG9vbFRvTWxkZXYkMiIsImZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyIsImZyb21Hb29nbGVTZWFyY2giLCJmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsIiwiZnJvbUNvZGVFeGVjdXRpb24iLCJmdW5jdGlvbkNhbGxpbmdDb25maWdUb01sZGV2JDEiLCJmcm9tQWxsb3dlZEZ1bmN0aW9uTmFtZXMiLCJ0b29sQ29uZmlnVG9NbGRldiQxIiwiZnJvbUZ1bmN0aW9uQ2FsbGluZ0NvbmZpZyIsImNyZWF0ZUNhY2hlZENvbnRlbnRDb25maWdUb01sZGV2IiwicGFyZW50T2JqZWN0IiwiZnJvbVR0bCIsImZyb21FeHBpcmVUaW1lIiwiZnJvbURpc3BsYXlOYW1lIiwiZnJvbUNvbnRlbnRzIiwiZnJvbVN5c3RlbUluc3RydWN0aW9uIiwiZnJvbVRvb2xzIiwiZnJvbVRvb2xDb25maWciLCJjcmVhdGVDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYiLCJmcm9tTW9kZWwiLCJmcm9tQ29uZmlnIiwiZ2V0Q2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb01sZGV2IiwiZGVsZXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb01sZGV2IiwidXBkYXRlQ2FjaGVkQ29udGVudENvbmZpZ1RvTWxkZXYiLCJ1cGRhdGVDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYiLCJsaXN0Q2FjaGVkQ29udGVudHNDb25maWdUb01sZGV2IiwiZnJvbVBhZ2VTaXplIiwiZnJvbVBhZ2VUb2tlbiIsImxpc3RDYWNoZWRDb250ZW50c1BhcmFtZXRlcnNUb01sZGV2IiwicGFydFRvVmVydGV4JDIiLCJmcm9tVmlkZW9NZXRhZGF0YSIsImNvbnRlbnRUb1ZlcnRleCQyIiwic2NoZW1hVG9WZXJ0ZXgkMiIsImZyb21FeGFtcGxlIiwiZnJvbVBhdHRlcm4iLCJmcm9tRGVmYXVsdCIsImZyb21NYXhMZW5ndGgiLCJmcm9tTWluTGVuZ3RoIiwiZnJvbU1pblByb3BlcnRpZXMiLCJmcm9tTWF4UHJvcGVydGllcyIsImZyb21BbnlPZiIsImZyb21FbnVtIiwiZnJvbUZvcm1hdCIsImZyb21JdGVtcyIsImZyb21NYXhJdGVtcyIsImZyb21NYXhpbXVtIiwiZnJvbU1pbkl0ZW1zIiwiZnJvbU1pbmltdW0iLCJmcm9tTnVsbGFibGUiLCJmcm9tUHJvcGVydGllcyIsImZyb21Qcm9wZXJ0eU9yZGVyaW5nIiwiZnJvbVJlcXVpcmVkIiwiZnJvbVRpdGxlIiwiZnJvbVR5cGUiLCJmdW5jdGlvbkRlY2xhcmF0aW9uVG9WZXJ0ZXgkMiIsImZyb21SZXNwb25zZSIsImdvb2dsZVNlYXJjaFRvVmVydGV4JDIiLCJkeW5hbWljUmV0cmlldmFsQ29uZmlnVG9WZXJ0ZXgkMiIsImdvb2dsZVNlYXJjaFJldHJpZXZhbFRvVmVydGV4JDIiLCJ0b29sVG9WZXJ0ZXgkMiIsImZyb21SZXRyaWV2YWwiLCJmdW5jdGlvbkNhbGxpbmdDb25maWdUb1ZlcnRleCQxIiwidG9vbENvbmZpZ1RvVmVydGV4JDEiLCJjcmVhdGVDYWNoZWRDb250ZW50Q29uZmlnVG9WZXJ0ZXgiLCJjcmVhdGVDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvVmVydGV4IiwiZ2V0Q2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleCIsImRlbGV0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJ1cGRhdGVDYWNoZWRDb250ZW50Q29uZmlnVG9WZXJ0ZXgiLCJ1cGRhdGVDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvVmVydGV4IiwibGlzdENhY2hlZENvbnRlbnRzQ29uZmlnVG9WZXJ0ZXgiLCJsaXN0Q2FjaGVkQ29udGVudHNQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJjYWNoZWRDb250ZW50RnJvbU1sZGV2IiwiZnJvbUNyZWF0ZVRpbWUiLCJmcm9tVXBkYXRlVGltZSIsImZyb21Vc2FnZU1ldGFkYXRhIiwiZGVsZXRlQ2FjaGVkQ29udGVudFJlc3BvbnNlRnJvbU1sZGV2IiwibGlzdENhY2hlZENvbnRlbnRzUmVzcG9uc2VGcm9tTWxkZXYiLCJmcm9tTmV4dFBhZ2VUb2tlbiIsImZyb21DYWNoZWRDb250ZW50cyIsImNhY2hlZENvbnRlbnRGcm9tVmVydGV4IiwiZGVsZXRlQ2FjaGVkQ29udGVudFJlc3BvbnNlRnJvbVZlcnRleCIsImxpc3RDYWNoZWRDb250ZW50c1Jlc3BvbnNlRnJvbVZlcnRleCIsImV4cG9ydHMiLCJQYWdlZEl0ZW0iLCJQYWdlciIsImNvbnN0cnVjdG9yIiwicmVxdWVzdCIsInJlc3BvbnNlIiwicGFyYW1zIiwicGFnZUludGVybmFsIiwicGFyYW1zSW50ZXJuYWwiLCJyZXF1ZXN0SW50ZXJuYWwiLCJpbml0IiwibmFtZUludGVybmFsIiwiaWR4SW50ZXJuYWwiLCJyZXF1ZXN0UGFyYW1zIiwiY29uZmlnIiwicGFnZUludGVybmFsU2l6ZSIsImluaXROZXh0UGFnZSIsInBhZ2UiLCJwYWdlU2l6ZSIsInBhZ2VMZW5ndGgiLCJnZXRJdGVtIiwiaW5kZXgiLCJTeW1ib2wiLCJhc3luY0l0ZXJhdG9yIiwibmV4dCIsImhhc05leHRQYWdlIiwibmV4dFBhZ2UiLCJkb25lIiwicmV0dXJuIiwiT3V0Y29tZSIsIkxhbmd1YWdlIiwiVHlwZSIsIkhhcm1DYXRlZ29yeSIsIkhhcm1CbG9ja01ldGhvZCIsIkhhcm1CbG9ja1RocmVzaG9sZCIsIk1vZGUiLCJGaW5pc2hSZWFzb24iLCJIYXJtUHJvYmFiaWxpdHkiLCJIYXJtU2V2ZXJpdHkiLCJCbG9ja2VkUmVhc29uIiwiVHJhZmZpY1R5cGUiLCJNb2RhbGl0eSIsIk1lZGlhUmVzb2x1dGlvbiIsIkZlYXR1cmVTZWxlY3Rpb25QcmVmZXJlbmNlIiwiRHluYW1pY1JldHJpZXZhbENvbmZpZ01vZGUiLCJGdW5jdGlvbkNhbGxpbmdDb25maWdNb2RlIiwiU2FmZXR5RmlsdGVyTGV2ZWwiLCJQZXJzb25HZW5lcmF0aW9uIiwiSW1hZ2VQcm9tcHRMYW5ndWFnZSIsIkZpbGVTdGF0ZSIsIkZpbGVTb3VyY2UiLCJNYXNrUmVmZXJlbmNlTW9kZSIsIkNvbnRyb2xSZWZlcmVuY2VUeXBlIiwiU3ViamVjdFJlZmVyZW5jZVR5cGUiLCJNZWRpYU1vZGFsaXR5IiwiU3RhcnRTZW5zaXRpdml0eSIsIkVuZFNlbnNpdGl2aXR5IiwiQWN0aXZpdHlIYW5kbGluZyIsIlR1cm5Db3ZlcmFnZSIsIkZ1bmN0aW9uUmVzcG9uc2UiLCJjcmVhdGVQYXJ0RnJvbVVyaSIsInVyaSIsImZpbGVEYXRhIiwiZmlsZVVyaSIsImNyZWF0ZVBhcnRGcm9tVGV4dCIsImNyZWF0ZVBhcnRGcm9tRnVuY3Rpb25DYWxsIiwiYXJncyIsImZ1bmN0aW9uQ2FsbCIsImNyZWF0ZVBhcnRGcm9tRnVuY3Rpb25SZXNwb25zZSIsImlkIiwiZnVuY3Rpb25SZXNwb25zZSIsImNyZWF0ZVBhcnRGcm9tQmFzZTY0IiwiaW5saW5lRGF0YSIsImNyZWF0ZVBhcnRGcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCIsIm91dGNvbWUiLCJvdXRwdXQiLCJjb2RlRXhlY3V0aW9uUmVzdWx0IiwiY3JlYXRlUGFydEZyb21FeGVjdXRhYmxlQ29kZSIsImNvZGUiLCJsYW5ndWFnZSIsImV4ZWN1dGFibGVDb2RlIiwiX2lzUGFydCIsIm9iaiIsIl90b1BhcnRzIiwicGFydE9yU3RyaW5nIiwicGFydCIsImNyZWF0ZVVzZXJDb250ZW50IiwiY3JlYXRlTW9kZWxDb250ZW50IiwiR2VuZXJhdGVDb250ZW50UmVzcG9uc2VQcm9tcHRGZWVkYmFjayIsIkdlbmVyYXRlQ29udGVudFJlc3BvbnNlVXNhZ2VNZXRhZGF0YSIsIkdlbmVyYXRlQ29udGVudFJlc3BvbnNlIiwiX2QiLCJfZSIsIl9mIiwiX2ciLCJfaCIsImNhbmRpZGF0ZXMiLCJjb25zb2xlIiwid2FybiIsImFueVRleHRQYXJ0VGV4dCIsIm5vblRleHRQYXJ0cyIsImZpZWxkTmFtZSIsImZpZWxkVmFsdWUiLCJlbnRyaWVzIiwidGhvdWdodCIsIm5vbkRhdGFQYXJ0cyIsImF0b2IiLCJidG9hIiwiZnVuY3Rpb25DYWxscyIsImZpbHRlciIsIl9qIiwiRW1iZWRDb250ZW50UmVzcG9uc2UiLCJHZW5lcmF0ZUltYWdlc1Jlc3BvbnNlIiwiQ291bnRUb2tlbnNSZXNwb25zZSIsIkNvbXB1dGVUb2tlbnNSZXNwb25zZSIsIkdlbmVyYXRlVmlkZW9zUmVzcG9uc2UiLCJEZWxldGVDYWNoZWRDb250ZW50UmVzcG9uc2UiLCJMaXN0Q2FjaGVkQ29udGVudHNSZXNwb25zZSIsIkxpc3RGaWxlc1Jlc3BvbnNlIiwiSHR0cFJlc3BvbnNlIiwiaGVhZGVycyIsInBhaXIiLCJyZXNwb25zZUludGVybmFsIiwianNvbiIsIkNyZWF0ZUZpbGVSZXNwb25zZSIsIkRlbGV0ZUZpbGVSZXNwb25zZSIsIlJlcGxheVJlc3BvbnNlIiwiTGl2ZUNsaWVudFRvb2xSZXNwb25zZSIsIkxpdmVTZW5kVG9vbFJlc3BvbnNlUGFyYW1ldGVycyIsImZ1bmN0aW9uUmVzcG9uc2VzIiwiQ2FjaGVzIiwibGlzdCIsIlBBR0VEX0lURU1fQ0FDSEVEX0NPTlRFTlRTIiwieCIsImxpc3RJbnRlcm5hbCIsInBhdGgiLCJxdWVyeVBhcmFtcyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwiaHR0cE1ldGhvZCIsImFib3J0U2lnbmFsIiwidGhlbiIsImh0dHBSZXNwb25zZSIsImFwaVJlc3BvbnNlIiwicmVzcCIsImRlbGV0ZSIsInR5cGVkUmVzcCIsInVwZGF0ZSIsIl9fdmFsdWVzIiwibyIsInMiLCJpdGVyYXRvciIsIm0iLCJfX2F3YWl0IiwidiIsIl9fYXN5bmNHZW5lcmF0b3IiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsImdlbmVyYXRvciIsImciLCJhcHBseSIsInEiLCJBc3luY0l0ZXJhdG9yIiwidmVyYiIsImF3YWl0UmV0dXJuIiwiZiIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiYSIsImIiLCJyZXN1bWUiLCJzdGVwIiwic2V0dGxlIiwiciIsImZ1bGZpbGwiLCJzaGlmdCIsIl9fYXN5bmNWYWx1ZXMiLCJTdXBwcmVzc2VkRXJyb3IiLCJzdXBwcmVzc2VkIiwibWVzc2FnZSIsImlzVmFsaWRSZXNwb25zZSIsImlzVmFsaWRDb250ZW50IiwidmFsaWRhdGVIaXN0b3J5IiwiaGlzdG9yeSIsImV4dHJhY3RDdXJhdGVkSGlzdG9yeSIsImNvbXByZWhlbnNpdmVIaXN0b3J5IiwiY3VyYXRlZEhpc3RvcnkiLCJ1c2VySW5wdXQiLCJtb2RlbE91dHB1dCIsImlzVmFsaWQiLCJDaGF0cyIsIm1vZGVsc01vZHVsZSIsIkNoYXQiLCJzZW5kUHJvbWlzZSIsInNlbmRNZXNzYWdlIiwiaW5wdXRDb250ZW50IiwicmVzcG9uc2VQcm9taXNlIiwiZ2VuZXJhdGVDb250ZW50IiwiY29udGVudHMiLCJnZXRIaXN0b3J5IiwiY29uY2F0Iiwib3V0cHV0Q29udGVudCIsInJlY29yZEhpc3RvcnkiLCJzZW5kTWVzc2FnZVN0cmVhbSIsInN0cmVhbVJlc3BvbnNlIiwiZ2VuZXJhdGVDb250ZW50U3RyZWFtIiwicHJvY2Vzc1N0cmVhbVJlc3BvbnNlIiwiY3VyYXRlZCIsImFyZ3VtZW50cyIsInByb2Nlc3NTdHJlYW1SZXNwb25zZV8xIiwiZV8xIiwic3RyZWFtUmVzcG9uc2VfMSIsInN0cmVhbVJlc3BvbnNlXzFfMSIsImNodW5rIiwiZV8xXzEiLCJvdXRwdXRDb250ZW50cyIsImV2ZXJ5IiwibGlzdEZpbGVzQ29uZmlnVG9NbGRldiIsImxpc3RGaWxlc1BhcmFtZXRlcnNUb01sZGV2IiwiZmlsZVN0YXR1c1RvTWxkZXYiLCJmcm9tRGV0YWlscyIsImZyb21NZXNzYWdlIiwiZnJvbUNvZGUiLCJmaWxlVG9NbGRldiIsImZyb21NaW1lVHlwZSIsImZyb21TaXplQnl0ZXMiLCJmcm9tRXhwaXJhdGlvblRpbWUiLCJmcm9tU2hhMjU2SGFzaCIsImZyb21VcmkiLCJmcm9tRG93bmxvYWRVcmkiLCJmcm9tU3RhdGUiLCJmcm9tU291cmNlIiwiZnJvbUVycm9yIiwiY3JlYXRlRmlsZVBhcmFtZXRlcnNUb01sZGV2IiwiZnJvbUZpbGUiLCJnZXRGaWxlUGFyYW1ldGVyc1RvTWxkZXYiLCJkZWxldGVGaWxlUGFyYW1ldGVyc1RvTWxkZXYiLCJmaWxlU3RhdHVzRnJvbU1sZGV2IiwiZmlsZUZyb21NbGRldiIsImxpc3RGaWxlc1Jlc3BvbnNlRnJvbU1sZGV2IiwiZnJvbUZpbGVzIiwiY3JlYXRlRmlsZVJlc3BvbnNlRnJvbU1sZGV2IiwiZGVsZXRlRmlsZVJlc3BvbnNlRnJvbU1sZGV2IiwiRmlsZXMiLCJQQUdFRF9JVEVNX0ZJTEVTIiwidXBsb2FkIiwidXBsb2FkRmlsZSIsImZpbGUiLCJjcmVhdGVJbnRlcm5hbCIsInBhcnRUb01sZGV2JDEiLCJwYXJ0VG9WZXJ0ZXgkMSIsImNvbnRlbnRUb01sZGV2JDEiLCJjb250ZW50VG9WZXJ0ZXgkMSIsInNjaGVtYVRvVmVydGV4JDEiLCJmdW5jdGlvbkRlY2xhcmF0aW9uVG9NbGRldiQxIiwiZnVuY3Rpb25EZWNsYXJhdGlvblRvVmVydGV4JDEiLCJnb29nbGVTZWFyY2hUb01sZGV2JDEiLCJnb29nbGVTZWFyY2hUb1ZlcnRleCQxIiwiZHluYW1pY1JldHJpZXZhbENvbmZpZ1RvTWxkZXYkMSIsImR5bmFtaWNSZXRyaWV2YWxDb25maWdUb1ZlcnRleCQxIiwiZ29vZ2xlU2VhcmNoUmV0cmlldmFsVG9NbGRldiQxIiwiZ29vZ2xlU2VhcmNoUmV0cmlldmFsVG9WZXJ0ZXgkMSIsInRvb2xUb01sZGV2JDEiLCJ0b29sVG9WZXJ0ZXgkMSIsInNlc3Npb25SZXN1bXB0aW9uQ29uZmlnVG9NbGRldiIsImZyb21IYW5kbGUiLCJzZXNzaW9uUmVzdW1wdGlvbkNvbmZpZ1RvVmVydGV4IiwiZnJvbVRyYW5zcGFyZW50IiwiYXVkaW9UcmFuc2NyaXB0aW9uQ29uZmlnVG9NbGRldiIsImF1ZGlvVHJhbnNjcmlwdGlvbkNvbmZpZ1RvVmVydGV4IiwiYXV0b21hdGljQWN0aXZpdHlEZXRlY3Rpb25Ub01sZGV2IiwiZnJvbURpc2FibGVkIiwiZnJvbVN0YXJ0T2ZTcGVlY2hTZW5zaXRpdml0eSIsImZyb21FbmRPZlNwZWVjaFNlbnNpdGl2aXR5IiwiZnJvbVByZWZpeFBhZGRpbmdNcyIsImZyb21TaWxlbmNlRHVyYXRpb25NcyIsImF1dG9tYXRpY0FjdGl2aXR5RGV0ZWN0aW9uVG9WZXJ0ZXgiLCJyZWFsdGltZUlucHV0Q29uZmlnVG9NbGRldiIsImZyb21BdXRvbWF0aWNBY3Rpdml0eURldGVjdGlvbiIsImZyb21BY3Rpdml0eUhhbmRsaW5nIiwiZnJvbVR1cm5Db3ZlcmFnZSIsInJlYWx0aW1lSW5wdXRDb25maWdUb1ZlcnRleCIsInNsaWRpbmdXaW5kb3dUb01sZGV2IiwiZnJvbVRhcmdldFRva2VucyIsInNsaWRpbmdXaW5kb3dUb1ZlcnRleCIsImNvbnRleHRXaW5kb3dDb21wcmVzc2lvbkNvbmZpZ1RvTWxkZXYiLCJmcm9tVHJpZ2dlclRva2VucyIsImZyb21TbGlkaW5nV2luZG93IiwiY29udGV4dFdpbmRvd0NvbXByZXNzaW9uQ29uZmlnVG9WZXJ0ZXgiLCJsaXZlQ29ubmVjdENvbmZpZ1RvTWxkZXYiLCJmcm9tR2VuZXJhdGlvbkNvbmZpZyIsImZyb21SZXNwb25zZU1vZGFsaXRpZXMiLCJmcm9tVGVtcGVyYXR1cmUiLCJmcm9tVG9wUCIsImZyb21Ub3BLIiwiZnJvbU1heE91dHB1dFRva2VucyIsImZyb21NZWRpYVJlc29sdXRpb24iLCJmcm9tU2VlZCIsImZyb21TcGVlY2hDb25maWciLCJmcm9tU2Vzc2lvblJlc3VtcHRpb24iLCJmcm9tT3V0cHV0QXVkaW9UcmFuc2NyaXB0aW9uIiwiZnJvbVJlYWx0aW1lSW5wdXRDb25maWciLCJmcm9tQ29udGV4dFdpbmRvd0NvbXByZXNzaW9uIiwibGl2ZUNvbm5lY3RDb25maWdUb1ZlcnRleCIsImZyb21JbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbiIsImxpdmVDb25uZWN0UGFyYW1ldGVyc1RvTWxkZXYiLCJsaXZlQ29ubmVjdFBhcmFtZXRlcnNUb1ZlcnRleCIsImFjdGl2aXR5U3RhcnRUb01sZGV2IiwiYWN0aXZpdHlTdGFydFRvVmVydGV4IiwiYWN0aXZpdHlFbmRUb01sZGV2IiwiYWN0aXZpdHlFbmRUb1ZlcnRleCIsImxpdmVTZW5kUmVhbHRpbWVJbnB1dFBhcmFtZXRlcnNUb01sZGV2IiwiZnJvbU1lZGlhIiwiZnJvbUF1ZGlvIiwiZnJvbUF1ZGlvU3RyZWFtRW5kIiwiZnJvbVZpZGVvIiwiZnJvbUFjdGl2aXR5U3RhcnQiLCJmcm9tQWN0aXZpdHlFbmQiLCJsaXZlU2VuZFJlYWx0aW1lSW5wdXRQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJsaXZlU2VydmVyU2V0dXBDb21wbGV0ZUZyb21NbGRldiIsImxpdmVTZXJ2ZXJTZXR1cENvbXBsZXRlRnJvbVZlcnRleCIsInBhcnRGcm9tTWxkZXYkMSIsInBhcnRGcm9tVmVydGV4JDEiLCJjb250ZW50RnJvbU1sZGV2JDEiLCJjb250ZW50RnJvbVZlcnRleCQxIiwidHJhbnNjcmlwdGlvbkZyb21NbGRldiIsImZyb21GaW5pc2hlZCIsInRyYW5zY3JpcHRpb25Gcm9tVmVydGV4IiwibGl2ZVNlcnZlckNvbnRlbnRGcm9tTWxkZXYiLCJmcm9tTW9kZWxUdXJuIiwiZnJvbVR1cm5Db21wbGV0ZSIsImZyb21JbnRlcnJ1cHRlZCIsImZyb21HZW5lcmF0aW9uQ29tcGxldGUiLCJmcm9tSW5wdXRUcmFuc2NyaXB0aW9uIiwiZnJvbU91dHB1dFRyYW5zY3JpcHRpb24iLCJsaXZlU2VydmVyQ29udGVudEZyb21WZXJ0ZXgiLCJmdW5jdGlvbkNhbGxGcm9tTWxkZXYiLCJmcm9tSWQiLCJmcm9tQXJncyIsImZ1bmN0aW9uQ2FsbEZyb21WZXJ0ZXgiLCJsaXZlU2VydmVyVG9vbENhbGxGcm9tTWxkZXYiLCJmcm9tRnVuY3Rpb25DYWxscyIsImxpdmVTZXJ2ZXJUb29sQ2FsbEZyb21WZXJ0ZXgiLCJsaXZlU2VydmVyVG9vbENhbGxDYW5jZWxsYXRpb25Gcm9tTWxkZXYiLCJmcm9tSWRzIiwibGl2ZVNlcnZlclRvb2xDYWxsQ2FuY2VsbGF0aW9uRnJvbVZlcnRleCIsIm1vZGFsaXR5VG9rZW5Db3VudEZyb21NbGRldiIsImZyb21Nb2RhbGl0eSIsImZyb21Ub2tlbkNvdW50IiwibW9kYWxpdHlUb2tlbkNvdW50RnJvbVZlcnRleCIsInVzYWdlTWV0YWRhdGFGcm9tTWxkZXYiLCJmcm9tUHJvbXB0VG9rZW5Db3VudCIsImZyb21DYWNoZWRDb250ZW50VG9rZW5Db3VudCIsImZyb21SZXNwb25zZVRva2VuQ291bnQiLCJmcm9tVG9vbFVzZVByb21wdFRva2VuQ291bnQiLCJmcm9tVGhvdWdodHNUb2tlbkNvdW50IiwiZnJvbVRvdGFsVG9rZW5Db3VudCIsImZyb21Qcm9tcHRUb2tlbnNEZXRhaWxzIiwiZnJvbUNhY2hlVG9rZW5zRGV0YWlscyIsImZyb21SZXNwb25zZVRva2Vuc0RldGFpbHMiLCJmcm9tVG9vbFVzZVByb21wdFRva2Vuc0RldGFpbHMiLCJ1c2FnZU1ldGFkYXRhRnJvbVZlcnRleCIsImZyb21UcmFmZmljVHlwZSIsImxpdmVTZXJ2ZXJHb0F3YXlGcm9tTWxkZXYiLCJmcm9tVGltZUxlZnQiLCJsaXZlU2VydmVyR29Bd2F5RnJvbVZlcnRleCIsImxpdmVTZXJ2ZXJTZXNzaW9uUmVzdW1wdGlvblVwZGF0ZUZyb21NbGRldiIsImZyb21OZXdIYW5kbGUiLCJmcm9tUmVzdW1hYmxlIiwiZnJvbUxhc3RDb25zdW1lZENsaWVudE1lc3NhZ2VJbmRleCIsImxpdmVTZXJ2ZXJTZXNzaW9uUmVzdW1wdGlvblVwZGF0ZUZyb21WZXJ0ZXgiLCJsaXZlU2VydmVyTWVzc2FnZUZyb21NbGRldiIsImZyb21TZXR1cENvbXBsZXRlIiwiZnJvbVNlcnZlckNvbnRlbnQiLCJmcm9tVG9vbENhbGwiLCJmcm9tVG9vbENhbGxDYW5jZWxsYXRpb24iLCJmcm9tR29Bd2F5IiwiZnJvbVNlc3Npb25SZXN1bXB0aW9uVXBkYXRlIiwibGl2ZVNlcnZlck1lc3NhZ2VGcm9tVmVydGV4IiwicGFydFRvTWxkZXYiLCJjb250ZW50VG9NbGRldiIsInNjaGVtYVRvTWxkZXYiLCJzYWZldHlTZXR0aW5nVG9NbGRldiIsImZyb21DYXRlZ29yeSIsImZyb21UaHJlc2hvbGQiLCJmdW5jdGlvbkRlY2xhcmF0aW9uVG9NbGRldiIsImdvb2dsZVNlYXJjaFRvTWxkZXYiLCJkeW5hbWljUmV0cmlldmFsQ29uZmlnVG9NbGRldiIsImdvb2dsZVNlYXJjaFJldHJpZXZhbFRvTWxkZXYiLCJ0b29sVG9NbGRldiIsImZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ1RvTWxkZXYiLCJ0b29sQ29uZmlnVG9NbGRldiIsInByZWJ1aWx0Vm9pY2VDb25maWdUb01sZGV2IiwiZnJvbVZvaWNlTmFtZSIsInZvaWNlQ29uZmlnVG9NbGRldiIsImZyb21QcmVidWlsdFZvaWNlQ29uZmlnIiwic3BlZWNoQ29uZmlnVG9NbGRldiIsImZyb21Wb2ljZUNvbmZpZyIsImZyb21MYW5ndWFnZUNvZGUiLCJ0aGlua2luZ0NvbmZpZ1RvTWxkZXYiLCJmcm9tSW5jbHVkZVRob3VnaHRzIiwiZnJvbVRoaW5raW5nQnVkZ2V0IiwiZ2VuZXJhdGVDb250ZW50Q29uZmlnVG9NbGRldiIsImZyb21DYW5kaWRhdGVDb3VudCIsImZyb21TdG9wU2VxdWVuY2VzIiwiZnJvbVJlc3BvbnNlTG9ncHJvYnMiLCJmcm9tTG9ncHJvYnMiLCJmcm9tUHJlc2VuY2VQZW5hbHR5IiwiZnJvbUZyZXF1ZW5jeVBlbmFsdHkiLCJmcm9tUmVzcG9uc2VNaW1lVHlwZSIsImZyb21SZXNwb25zZVNjaGVtYSIsImZyb21TYWZldHlTZXR0aW5ncyIsImZyb21DYWNoZWRDb250ZW50IiwiZnJvbVRoaW5raW5nQ29uZmlnIiwiZ2VuZXJhdGVDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYiLCJlbWJlZENvbnRlbnRDb25maWdUb01sZGV2IiwiZnJvbVRhc2tUeXBlIiwiZnJvbU91dHB1dERpbWVuc2lvbmFsaXR5IiwiZW1iZWRDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYiLCJmcm9tTW9kZWxGb3JFbWJlZENvbnRlbnQiLCJnZW5lcmF0ZUltYWdlc0NvbmZpZ1RvTWxkZXYiLCJmcm9tTnVtYmVyT2ZJbWFnZXMiLCJmcm9tQXNwZWN0UmF0aW8iLCJmcm9tR3VpZGFuY2VTY2FsZSIsImZyb21TYWZldHlGaWx0ZXJMZXZlbCIsImZyb21QZXJzb25HZW5lcmF0aW9uIiwiZnJvbUluY2x1ZGVTYWZldHlBdHRyaWJ1dGVzIiwiZnJvbUluY2x1ZGVSYWlSZWFzb24iLCJmcm9tTGFuZ3VhZ2UiLCJmcm9tT3V0cHV0TWltZVR5cGUiLCJmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5IiwiZ2VuZXJhdGVJbWFnZXNQYXJhbWV0ZXJzVG9NbGRldiIsImZyb21Qcm9tcHQiLCJnZXRNb2RlbFBhcmFtZXRlcnNUb01sZGV2IiwiY291bnRUb2tlbnNDb25maWdUb01sZGV2IiwiY291bnRUb2tlbnNQYXJhbWV0ZXJzVG9NbGRldiIsImltYWdlVG9NbGRldiIsImdlbmVyYXRlVmlkZW9zQ29uZmlnVG9NbGRldiIsImZyb21OdW1iZXJPZlZpZGVvcyIsImZyb21EdXJhdGlvblNlY29uZHMiLCJmcm9tTmVnYXRpdmVQcm9tcHQiLCJnZW5lcmF0ZVZpZGVvc1BhcmFtZXRlcnNUb01sZGV2IiwiZnJvbUltYWdlIiwicGFydFRvVmVydGV4IiwiY29udGVudFRvVmVydGV4Iiwic2NoZW1hVG9WZXJ0ZXgiLCJtb2RlbFNlbGVjdGlvbkNvbmZpZ1RvVmVydGV4IiwiZnJvbUZlYXR1cmVTZWxlY3Rpb25QcmVmZXJlbmNlIiwic2FmZXR5U2V0dGluZ1RvVmVydGV4IiwiZnJvbU1ldGhvZCIsImZ1bmN0aW9uRGVjbGFyYXRpb25Ub1ZlcnRleCIsImdvb2dsZVNlYXJjaFRvVmVydGV4IiwiZHluYW1pY1JldHJpZXZhbENvbmZpZ1RvVmVydGV4IiwiZ29vZ2xlU2VhcmNoUmV0cmlldmFsVG9WZXJ0ZXgiLCJ0b29sVG9WZXJ0ZXgiLCJmdW5jdGlvbkNhbGxpbmdDb25maWdUb1ZlcnRleCIsInRvb2xDb25maWdUb1ZlcnRleCIsInByZWJ1aWx0Vm9pY2VDb25maWdUb1ZlcnRleCIsInZvaWNlQ29uZmlnVG9WZXJ0ZXgiLCJzcGVlY2hDb25maWdUb1ZlcnRleCIsInRoaW5raW5nQ29uZmlnVG9WZXJ0ZXgiLCJnZW5lcmF0ZUNvbnRlbnRDb25maWdUb1ZlcnRleCIsImZyb21Sb3V0aW5nQ29uZmlnIiwiZnJvbU1vZGVsU2VsZWN0aW9uQ29uZmlnIiwiZnJvbUxhYmVscyIsImZyb21BdWRpb1RpbWVzdGFtcCIsImdlbmVyYXRlQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleCIsImVtYmVkQ29udGVudENvbmZpZ1RvVmVydGV4IiwiZnJvbUF1dG9UcnVuY2F0ZSIsImVtYmVkQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleCIsImdlbmVyYXRlSW1hZ2VzQ29uZmlnVG9WZXJ0ZXgiLCJmcm9tT3V0cHV0R2NzVXJpIiwiZnJvbUFkZFdhdGVybWFyayIsImZyb21FbmhhbmNlUHJvbXB0IiwiZ2VuZXJhdGVJbWFnZXNQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJnZXRNb2RlbFBhcmFtZXRlcnNUb1ZlcnRleCIsImNvdW50VG9rZW5zQ29uZmlnVG9WZXJ0ZXgiLCJjb3VudFRva2Vuc1BhcmFtZXRlcnNUb1ZlcnRleCIsImNvbXB1dGVUb2tlbnNQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJpbWFnZVRvVmVydGV4IiwiZnJvbUdjc1VyaSIsImdlbmVyYXRlVmlkZW9zQ29uZmlnVG9WZXJ0ZXgiLCJmcm9tRnBzIiwiZnJvbVJlc29sdXRpb24iLCJmcm9tUHVic3ViVG9waWMiLCJnZW5lcmF0ZVZpZGVvc1BhcmFtZXRlcnNUb1ZlcnRleCIsInBhcnRGcm9tTWxkZXYiLCJjb250ZW50RnJvbU1sZGV2IiwiY2l0YXRpb25NZXRhZGF0YUZyb21NbGRldiIsImZyb21DaXRhdGlvbnMiLCJjYW5kaWRhdGVGcm9tTWxkZXYiLCJmcm9tQ29udGVudCIsImZyb21DaXRhdGlvbk1ldGFkYXRhIiwiZnJvbUZpbmlzaFJlYXNvbiIsImZyb21BdmdMb2dwcm9icyIsImZyb21Hcm91bmRpbmdNZXRhZGF0YSIsImZyb21JbmRleCIsImZyb21Mb2dwcm9ic1Jlc3VsdCIsImZyb21TYWZldHlSYXRpbmdzIiwiZ2VuZXJhdGVDb250ZW50UmVzcG9uc2VGcm9tTWxkZXYiLCJmcm9tQ2FuZGlkYXRlcyIsImZyb21Nb2RlbFZlcnNpb24iLCJmcm9tUHJvbXB0RmVlZGJhY2siLCJjb250ZW50RW1iZWRkaW5nRnJvbU1sZGV2IiwiZnJvbVZhbHVlcyIsImVtYmVkQ29udGVudE1ldGFkYXRhRnJvbU1sZGV2IiwiZW1iZWRDb250ZW50UmVzcG9uc2VGcm9tTWxkZXYiLCJmcm9tRW1iZWRkaW5ncyIsImZyb21NZXRhZGF0YSIsImltYWdlRnJvbU1sZGV2Iiwic2FmZXR5QXR0cmlidXRlc0Zyb21NbGRldiIsImZyb21DYXRlZ29yaWVzIiwiZnJvbVNjb3JlcyIsImZyb21Db250ZW50VHlwZSIsImdlbmVyYXRlZEltYWdlRnJvbU1sZGV2IiwiZnJvbVJhaUZpbHRlcmVkUmVhc29uIiwiZnJvbVNhZmV0eUF0dHJpYnV0ZXMiLCJnZW5lcmF0ZUltYWdlc1Jlc3BvbnNlRnJvbU1sZGV2IiwiZnJvbUdlbmVyYXRlZEltYWdlcyIsImZyb21Qb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMiLCJ0dW5lZE1vZGVsSW5mb0Zyb21NbGRldiIsImZyb21CYXNlTW9kZWwiLCJtb2RlbEZyb21NbGRldiIsImZyb21WZXJzaW9uIiwiZnJvbVR1bmVkTW9kZWxJbmZvIiwiZnJvbUlucHV0VG9rZW5MaW1pdCIsImZyb21PdXRwdXRUb2tlbkxpbWl0IiwiZnJvbVN1cHBvcnRlZEFjdGlvbnMiLCJjb3VudFRva2Vuc1Jlc3BvbnNlRnJvbU1sZGV2IiwiZnJvbVRvdGFsVG9rZW5zIiwidmlkZW9Gcm9tTWxkZXYkMSIsImZyb21WaWRlb0J5dGVzIiwiZ2VuZXJhdGVkVmlkZW9Gcm9tTWxkZXYkMSIsImdlbmVyYXRlVmlkZW9zUmVzcG9uc2VGcm9tTWxkZXYkMSIsImZyb21HZW5lcmF0ZWRWaWRlb3MiLCJmcm9tUmFpTWVkaWFGaWx0ZXJlZENvdW50IiwiZnJvbVJhaU1lZGlhRmlsdGVyZWRSZWFzb25zIiwiZ2VuZXJhdGVWaWRlb3NPcGVyYXRpb25Gcm9tTWxkZXYkMSIsImZyb21Eb25lIiwicGFydEZyb21WZXJ0ZXgiLCJjb250ZW50RnJvbVZlcnRleCIsImNpdGF0aW9uTWV0YWRhdGFGcm9tVmVydGV4IiwiY2FuZGlkYXRlRnJvbVZlcnRleCIsImZyb21GaW5pc2hNZXNzYWdlIiwiZ2VuZXJhdGVDb250ZW50UmVzcG9uc2VGcm9tVmVydGV4IiwiZnJvbVJlc3BvbnNlSWQiLCJjb250ZW50RW1iZWRkaW5nU3RhdGlzdGljc0Zyb21WZXJ0ZXgiLCJmcm9tVHJ1bmNhdGVkIiwiY29udGVudEVtYmVkZGluZ0Zyb21WZXJ0ZXgiLCJmcm9tU3RhdGlzdGljcyIsImVtYmVkQ29udGVudE1ldGFkYXRhRnJvbVZlcnRleCIsImZyb21CaWxsYWJsZUNoYXJhY3RlckNvdW50IiwiZW1iZWRDb250ZW50UmVzcG9uc2VGcm9tVmVydGV4IiwiaW1hZ2VGcm9tVmVydGV4Iiwic2FmZXR5QXR0cmlidXRlc0Zyb21WZXJ0ZXgiLCJnZW5lcmF0ZWRJbWFnZUZyb21WZXJ0ZXgiLCJmcm9tRW5oYW5jZWRQcm9tcHQiLCJnZW5lcmF0ZUltYWdlc1Jlc3BvbnNlRnJvbVZlcnRleCIsImVuZHBvaW50RnJvbVZlcnRleCIsImZyb21EZXBsb3llZE1vZGVsSWQiLCJ0dW5lZE1vZGVsSW5mb0Zyb21WZXJ0ZXgiLCJtb2RlbEZyb21WZXJ0ZXgiLCJmcm9tRW5kcG9pbnRzIiwiY291bnRUb2tlbnNSZXNwb25zZUZyb21WZXJ0ZXgiLCJjb21wdXRlVG9rZW5zUmVzcG9uc2VGcm9tVmVydGV4IiwiZnJvbVRva2Vuc0luZm8iLCJ2aWRlb0Zyb21WZXJ0ZXgkMSIsImdlbmVyYXRlZFZpZGVvRnJvbVZlcnRleCQxIiwiZ2VuZXJhdGVWaWRlb3NSZXNwb25zZUZyb21WZXJ0ZXgkMSIsImdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uRnJvbVZlcnRleCQxIiwiRlVOQ1RJT05fUkVTUE9OU0VfUkVRVUlSRVNfSUQiLCJoYW5kbGVXZWJTb2NrZXRNZXNzYWdlIiwib25tZXNzYWdlIiwiZXZlbnQiLCJzZXJ2ZXJNZXNzYWdlIiwiQmxvYiIsInBhcnNlIiwiTGl2ZSIsImF1dGgiLCJ3ZWJTb2NrZXRGYWN0b3J5IiwiY29ubmVjdCIsIndlYnNvY2tldEJhc2VVcmwiLCJnZXRXZWJzb2NrZXRCYXNlVXJsIiwiYXBpVmVyc2lvbiIsImdldEFwaVZlcnNpb24iLCJ1cmwiLCJtYXBUb0hlYWRlcnMiLCJnZXREZWZhdWx0SGVhZGVycyIsImFkZEF1dGhIZWFkZXJzIiwiYXBpS2V5IiwiZ2V0QXBpS2V5Iiwib25vcGVuUmVzb2x2ZSIsIm9ub3BlblByb21pc2UiLCJjYWxsYmFja3MiLCJvbm9wZW5Bd2FpdGVkQ2FsbGJhY2siLCJvbm9wZW4iLCJ3ZWJzb2NrZXRDYWxsYmFja3MiLCJvbmVycm9yIiwib25jbG9zZSIsImNvbm4iLCJoZWFkZXJzVG9NYXAiLCJwcm9qZWN0IiwibG9jYXRpb24iLCJjbGllbnRNZXNzYWdlIiwicmVzcG9uc2VNb2RhbGl0aWVzIiwiQVVESU8iLCJnZW5lcmF0aW9uQ29uZmlnIiwibGl2ZUNvbm5lY3RQYXJhbWV0ZXJzIiwic2VuZCIsIlNlc3Npb24iLCJkZWZhdWx0TGl2ZVNlbmRDbGllbnRDb250ZW50UGFyYW1lcnRlcnMiLCJ0dXJuQ29tcGxldGUiLCJ0TGl2ZUNsaWVudENvbnRlbnQiLCJ0dXJucyIsImNsaWVudENvbnRlbnQiLCJ0TGl2ZUNsaWVudHRUb29sUmVzcG9uc2UiLCJ0b29sUmVzcG9uc2UiLCJzZW5kQ2xpZW50Q29udGVudCIsInNlbmRSZWFsdGltZUlucHV0Iiwic2VuZFRvb2xSZXNwb25zZSIsImNsb3NlIiwiaGVhZGVyTWFwIiwiSGVhZGVycyIsImFwcGVuZCIsIk1vZGVscyIsImdlbmVyYXRlQ29udGVudEludGVybmFsIiwiZ2VuZXJhdGVDb250ZW50U3RyZWFtSW50ZXJuYWwiLCJnZW5lcmF0ZUltYWdlcyIsImdlbmVyYXRlSW1hZ2VzSW50ZXJuYWwiLCJwb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMiLCJnZW5lcmF0ZWRJbWFnZXMiLCJnZW5lcmF0ZWRJbWFnZSIsInNhZmV0eUF0dHJpYnV0ZXMiLCJjb250ZW50VHlwZSIsInJlcXVlc3RTdHJlYW0iLCJhcGlSZXNwb25zZV8xIiwiYXBpUmVzcG9uc2VfMV8xIiwiZV8yIiwiYXBpUmVzcG9uc2VfMiIsImFwaVJlc3BvbnNlXzJfMSIsImVfMl8xIiwiZW1iZWRDb250ZW50IiwiY291bnRUb2tlbnMiLCJjb21wdXRlVG9rZW5zIiwiZ2VuZXJhdGVWaWRlb3MiLCJnZXRPcGVyYXRpb25QYXJhbWV0ZXJzVG9NbGRldiIsImZyb21PcGVyYXRpb25OYW1lIiwiZ2V0T3BlcmF0aW9uUGFyYW1ldGVyc1RvVmVydGV4IiwiZmV0Y2hQcmVkaWN0T3BlcmF0aW9uUGFyYW1ldGVyc1RvVmVydGV4IiwiZnJvbVJlc291cmNlTmFtZSIsInZpZGVvRnJvbU1sZGV2IiwiZ2VuZXJhdGVkVmlkZW9Gcm9tTWxkZXYiLCJnZW5lcmF0ZVZpZGVvc1Jlc3BvbnNlRnJvbU1sZGV2IiwiZ2VuZXJhdGVWaWRlb3NPcGVyYXRpb25Gcm9tTWxkZXYiLCJ2aWRlb0Zyb21WZXJ0ZXgiLCJnZW5lcmF0ZWRWaWRlb0Zyb21WZXJ0ZXgiLCJnZW5lcmF0ZVZpZGVvc1Jlc3BvbnNlRnJvbVZlcnRleCIsImdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uRnJvbVZlcnRleCIsIk9wZXJhdGlvbnMiLCJnZXRWaWRlb3NPcGVyYXRpb24iLCJwYXJhbWV0ZXJzIiwib3BlcmF0aW9uIiwiZmV0Y2hQcmVkaWN0VmlkZW9zT3BlcmF0aW9uSW50ZXJuYWwiLCJvcGVyYXRpb25OYW1lIiwiZ2V0VmlkZW9zT3BlcmF0aW9uSW50ZXJuYWwiLCJDT05URU5UX1RZUEVfSEVBREVSIiwiU0VSVkVSX1RJTUVPVVRfSEVBREVSIiwiVVNFUl9BR0VOVF9IRUFERVIiLCJHT09HTEVfQVBJX0NMSUVOVF9IRUFERVIiLCJTREtfVkVSU0lPTiIsIkxJQlJBUllfTEFCRUwiLCJWRVJURVhfQUlfQVBJX0RFRkFVTFRfVkVSU0lPTiIsIkdPT0dMRV9BSV9BUElfREVGQVVMVF9WRVJTSU9OIiwicmVzcG9uc2VMaW5lUkUiLCJDbGllbnRFcnJvciIsInN0YWNrVHJhY2UiLCJjYXVzZSIsInN0YWNrIiwiU2VydmVyRXJyb3IiLCJBcGlDbGllbnQiLCJvcHRzIiwiY2xpZW50T3B0aW9ucyIsImluaXRIdHRwT3B0aW9ucyIsInBhdGNoSHR0cE9wdGlvbnMiLCJnZXRSZXF1ZXN0VXJsIiwiZ2V0UmVxdWVzdFVybEludGVybmFsIiwiZ2V0SGVhZGVycyIsInVybEVsZW1lbnQiLCJqb2luIiwiZ2V0QmFzZVJlc291cmNlUGF0aCIsInVybFBhcnRzIiwiVVJMIiwicHJvdG9jb2wiLCJ0b1N0cmluZyIsInNldEJhc2VVcmwiLCJjb25zdHJ1Y3RVcmwiLCJwcmVwZW5kUHJvamVjdExvY2F0aW9uIiwic2hvdWxkUHJlcGVuZFZlcnRleFByb2plY3RQYXRoIiwicGF0Y2hlZEh0dHBPcHRpb25zIiwic2VhcmNoUGFyYW1zIiwicmVxdWVzdEluaXQiLCJpbmNsdWRlRXh0cmFIdHRwT3B0aW9uc1RvUmVxdWVzdEluaXQiLCJ1bmFyeUFwaUNhbGwiLCJiYXNlSHR0cE9wdGlvbnMiLCJyZXF1ZXN0SHR0cE9wdGlvbnMiLCJoYXMiLCJzZXQiLCJzdHJlYW1BcGlDYWxsIiwidGltZW91dCIsImFib3J0Q29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsInNpZ25hbCIsInNldFRpbWVvdXQiLCJhYm9ydCIsImFkZEV2ZW50TGlzdGVuZXIiLCJnZXRIZWFkZXJzSW50ZXJuYWwiLCJhcGlDYWxsIiwibWV0aG9kIiwidGhyb3dFcnJvcklmTm90T0siLCJjYXRjaCIsInJlYWRlciIsImdldFJlYWRlciIsImRlY29kZXIiLCJUZXh0RGVjb2RlciIsImJ1ZmZlciIsInJlYWQiLCJ0cmltIiwiY2h1bmtTdHJpbmciLCJkZWNvZGUiLCJjaHVua0pzb24iLCJlcnJvckpzb24iLCJzdGF0dXMiLCJlcnJvck1lc3NhZ2UiLCJjbGllbnRFcnJvciIsInNlcnZlckVycm9yIiwicHJvY2Vzc2VkQ2h1bmtTdHJpbmciLCJwYXJ0aWFsUmVzcG9uc2UiLCJSZXNwb25zZSIsInN0YXR1c1RleHQiLCJyZWxlYXNlTG9jayIsImZldGNoIiwidmVyc2lvbkhlYWRlclZhbHVlIiwidXNlckFnZW50RXh0cmEiLCJNYXRoIiwiY2VpbCIsImZpbGVUb1VwbG9hZCIsImRpc3BsYXlOYW1lIiwidXBsb2FkZXIiLCJmaWxlU3RhdCIsInN0YXQiLCJzaXplQnl0ZXMiLCJzaXplIiwidHlwZSIsInVwbG9hZFVybCIsImZldGNoVXBsb2FkVXJsIiwib2siLCJlcnJvckJvZHkiLCJpbmNsdWRlcyIsIkdPT0dMRV9BUElfS0VZX0hFQURFUiIsIlJFUVVJUkVEX1ZFUlRFWF9BSV9TQ09QRSIsIk5vZGVBdXRoIiwidmVydGV4QXV0aE9wdGlvbnMiLCJidWlsZEdvb2dsZUF1dGhPcHRpb25zIiwiZ29vZ2xlQXV0aE9wdGlvbnMiLCJnb29nbGVBdXRoIiwiR29vZ2xlQXV0aCIsImFkZEtleUhlYWRlciIsImFkZEdvb2dsZUF1dGhIZWFkZXJzIiwiYXV0aEhlYWRlcnMiLCJnZXRSZXF1ZXN0SGVhZGVycyIsImF1dGhPcHRpb25zIiwic2NvcGVzIiwiTm9kZVdlYlNvY2tldEZhY3RvcnkiLCJOb2RlV2ViU29ja2V0Iiwid3MiLCJXZWJTb2NrZXQiLCJNQVhfQ0hVTktfU0laRSIsInVwbG9hZEJsb2IiLCJmaWxlU2l6ZSIsIm9mZnNldCIsInVwbG9hZENvbW1hbmQiLCJjaHVua1NpemUiLCJtaW4iLCJyZXNwb25zZUpzb24iLCJnZXRCbG9iU3RhdCIsIk5vZGVVcGxvYWRlciIsIm9yaWdpbmFsU3RhdCIsImluZmVyTWltZVR5cGUiLCJ1cGxvYWRGaWxlRnJvbVBhdGgiLCJmaWxlUGF0aCIsImZpbGVFeHRlbnNpb24iLCJsYXN0SW5kZXhPZiIsIm1pbWVUeXBlcyIsInRvTG93ZXJDYXNlIiwiZmlsZUhhbmRsZSIsIm9wZW4iLCJVaW50OEFycmF5IiwiYnl0ZXNSZWFkIiwiTEFOR1VBR0VfTEFCRUxfUFJFRklYIiwiR29vZ2xlR2VuQUkiLCJnZXRCb29sZWFuRW52IiwiZW52QXBpS2V5IiwiZ2V0RW52IiwiZW52UHJvamVjdCIsImVudkxvY2F0aW9uIiwiZGVidWciLCJwcm9jZXNzIiwidmVyc2lvbiIsIm1vZGVscyIsImxpdmUiLCJjaGF0cyIsImNhY2hlcyIsImZpbGVzIiwib3BlcmF0aW9ucyIsImVudiIsInN0cmluZ1RvQm9vbGVhbiIsInN0ciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@google/genai/dist/node/index.js\n");

/***/ })

};
;