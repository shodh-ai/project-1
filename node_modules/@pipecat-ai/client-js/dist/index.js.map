{"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;ACAA;;;;CAIG;AAKI,eAAe,0CACpB,SAAiB,EACjB,MAAyB,EACzB,MAAwB,EACxB,cAAsD;IAEtD,IAAI;QACF,CAAA,GAAA,wCAAA,EAAO,KAAK,CAAC,uBAAuB,WAAW;QAE/C,MAAM,UAAU,IAAI,QAAQ;YAC1B,GAAG,OAAO,WAAW,CAAC,AAAC,CAAA,OAAO,OAAO,IAAI,IAAI,SAAO,EAAI,OAAO,GAAG;QACnE;QAED,IAAI,CAAC,QAAQ,GAAG,CAAC,iBACf,QAAQ,GAAG,CAAC,gBAAgB;QAE9B,QAAQ,GAAG,CAAC,iBAAiB;QAC7B,QAAQ,GAAG,CAAC,cAAc;QAE1B,4BAA4B;QAC5B,MAAM,WAAW,MAAM,MAAM,WAAW;YACtC,QAAQ;qBACR;YACA,MAAM,KAAK,SAAS,CAAC;gBAAE,GAAG,OAAO,WAAW;gBAAE,SAAS;oBAAC;iBAAO;YAAA;QAChE;QAED,kCAAkC;QAClC,MAAM,cAAc,SAAS,OAAO,CAAC,GAAG,CAAC;QAEzC,gCAAgC;QAChC,IAAI,CAAC,SAAS,EAAE,EAAE;YAChB,MAAM,eAAe,MAAM,SAAS,IAAI;YACxC,MAAM,IAAI,CAAA,GAAA,yCAAA,EACR,CAAA,0BAAA,EAA6B,cAAc,EAC3C,SAAS,MAAM;QAEnB;QAEA,IAAI,SAAS,IAAI,IAAI,aAAa,SAAS,sBAAsB;YAC/D,2BAA2B;YAC3B,MAAM,SAAS,SAAS,IAAI,CACzB,WAAW,CAAC,IAAI,qBAChB,SAAS;YAEZ,IAAI,SAAS;YAEb,MAAO,KAAM;gBACX,MAAM,SAAE,KAAK,QAAE,IAAI,EAAE,GAAG,MAAM,OAAO,IAAI;gBACzC,IAAI,MAAM;gBAEV,UAAU;gBAEV,IAAI,WAAW,OAAO,OAAO,CAAC;gBAC9B,MAAO,aAAa,GAAI;oBACtB,MAAM,UAAU,OAAO,KAAK,CAAC,GAAG;oBAChC,SAAS,OAAO,KAAK,CAAC,WAAW;oBAEjC,kDAAkD;oBAClD,MAAM,QAAQ,QAAQ,KAAK,CAAC;oBAC5B,IAAI,cAAc;oBAClB,KAAK,MAAM,QAAQ,MAAO;wBACxB,MAAM,aAAa,KAAK,OAAO,CAAC;wBAChC,IAAI,eAAe,IACjB,eAAe,KAAK,KAAK,CAAC,aAAa,GAAG,IAAI;oBAElD;oBAEA,IAAI;wBACF,MAAM,WAAW,KAAK;wBACtB,MAAM,aAAa,KAAK,KAAK,CAAC;wBAC9B,eAAe;oBACjB,EAAE,OAAO,OAAO;wBACd,CAAA,GAAA,wCAAA,EAAO,KAAK,CAAC,gCAAgC;wBAC7C,MAAM;oBACR;oBAEA,WAAW,OAAO,OAAO,CAAC;gBAC5B;YACF;QACF,OAAO;YACL,wEAAwE;YACxE,MAAM,OAAO,MAAM,SAAS,IAAI;YAChC,eAAe;QACjB;IACF,EAAE,OAAO,OAAO;QACd,CAAA,GAAA,wCAAA,EAAO,KAAK,CAAC,8BAA8B;QAC3C,MAAM;IACR;AACF,EACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BE;;CD7HC;;;;AEJH;;;;CAIG;;;ACJH,4BAAiB,KAAK,KAAK,CAAC;;;ACA5B;;;;;;;;;;;;;ACAA;;;;CAIG,GAEG,MAAO,kDAAkB;IAG7B,YAAY,OAAgB,EAAE,MAA2B,CAAzD;QACE,KAAK,CAAC;QACN,IAAI,CAAC,MAAM,GAAG;IAChB;AACD;AAEK,MAAO,kDAA+B;IAC1C,YAAY,OAA4B,CAAxC;QACE,KAAK,CACH,WACE;IAEN;AACD;AAEK,MAAO,kDAAsB;IAEjC,YAAY,OAA4B,EAAE,MAAe,CAAzD;QACE,KAAK,CACH,WAAW,CAAA,qDAAA,CAAuD,EAClE,UAAU;QAJL,IAAA,CAAA,KAAK,GAAW;IAMzB;AACD;AAEK,MAAO,iDAA4B;IACvC,YAAY,OAA4B,CAAxC;QACE,KAAK,CAAC,WAAW;IACnB;AACD;AAEK,MAAO,kDAAyB;IACpC,YAAY,OAA4B,CAAxC;QACE,KAAK,CACH,WACE;IAEN;AACD;AAEK,MAAO,kDAA0B;IAErC,YAAY,OAA4B,CAAxC;QACE,KAAK,CAAC,WAAW;QAFD,IAAA,CAAA,MAAM,GAAG;IAG3B;AACD;AAEK,MAAO,kDAAkC;IAC7C,YAAY,OAA4B,CAAxC;QACE,KAAK,CAAC,WAAW;IACnB;AACD;;CDxDE;AAKG,SAAU,0CACd,OAAU,EACV,WAA4B,EAC5B,UAA8B;IAE9B,MAAM,iBAAiB,WAAW,KAAK;IAEvC,WAAW,KAAK,GAAG,SAAmB,GAAG,IAAe;QACtD,IAAI,IAAI,CAAC,KAAK,KAAK,SACjB,OAAO,eAAe,KAAK,CAAC,IAAI,EAAE;aAElC,MAAM,IAAI,CAAA,GAAA,yCAAA,EACR,CAAA,gBAAA,EAAmB,YAAY,QAAQ,GAAE,0DAAA,CAA4D;IAG3G;IAEA,OAAO;AACT;AACM,SAAU,0CAAuC,MAAgB;IACrE,OAAO,SACL,OAAU,EACV,WAA4B,EAC5B,UAA8B;QAE9B,MAAM,iBAAiB,WAAW,KAAK;QAEvC,WAAW,GAAG,GAAG,SAAmB,GAAG,IAAe;YACpD,IAAI,OAAO,QAAQ,CAAC,IAAI,CAAC,KAAK,GAC5B,OAAO,eAAe,KAAK,CAAC,IAAI,EAAE;iBAElC,MAAM,IAAI,CAAA,GAAA,yCAAA,EACR,CAAA,gBAAA,EAAmB,YAAY,QAAQ,GAAE,uBAAA,EAA0B,OAAM,CAAA,CAAG;QAGlF;QAEA,OAAO;IACT;AACF;AAEM,SAAU,0CACd,GAAG,MAAgB;IAEnB,SAAS;QAAC;WAAY;KAAO;IAE7B,OAAO,SACL,OAAU,EACV,WAA4B,EAC5B,UAA8B;QAE9B,MAAM,iBAAiB,WAAW,GAAG;QAErC,WAAW,GAAG,GAAG;YACf,IAAI,OAAO,QAAQ,CAAC,IAAI,CAAC,KAAK,GAC5B,OAAO,gBAAgB,MAAM,IAAI;iBAEjC,MAAM,IAAI,CAAA,GAAA,yCAAA,EACR,CAAA,gBAAA,EAAmB,YAAY,QAAQ,GAAE,uBAAA,EAA0B,OAAM,wBAAA,CAA0B;QAGzG;QAEA,OAAO;IACT;AACF;;;;;;;AE1EA;;;;CAIG,GAgBH,IAAY;AAAZ,CAAA,SAAY,SAAS;IACnB,SAAA,CAAA,eAAA,GAAA;IACA,SAAA,CAAA,QAAA,GAAA;IAEA,SAAA,CAAA,YAAA,GAAA;IACA,SAAA,CAAA,eAAA,GAAA;IACA,SAAA,CAAA,wBAAA,GAAA;IAEA,SAAA,CAAA,SAAA,GAAA;IACA,SAAA,CAAA,iBAAA,GAAA;IACA,SAAA,CAAA,mBAAA,GAAA;IAEA,SAAA,CAAA,uBAAA,GAAA;IACA,SAAA,CAAA,kBAAA,GAAA;IACA,SAAA,CAAA,eAAA,GAAA;IACA,SAAA,CAAA,eAAA,GAAA;IACA,SAAA,CAAA,qBAAA,GAAA;IACA,SAAA,CAAA,qBAAA,GAAA;IACA,SAAA,CAAA,mBAAA,GAAA;IAEA,SAAA,CAAA,uBAAA,GAAA;IACA,SAAA,CAAA,uBAAA,GAAA;IACA,SAAA,CAAA,2BAAA,GAAA;IACA,SAAA,CAAA,aAAA,GAAA;IACA,SAAA,CAAA,aAAA,GAAA;IACA,SAAA,CAAA,iBAAA,GAAA;IAEA,SAAA,CAAA,eAAA,GAAA;IACA,SAAA,CAAA,WAAA,GAAA;IACA,SAAA,CAAA,kBAAA,GAAA;IACA,SAAA,CAAA,qBAAA,GAAA;IACA,SAAA,CAAA,qBAAA,GAAA;IACA,SAAA,CAAA,mBAAA,GAAA;IAEA,SAAA,CAAA,sBAAA,GAAA;IACA,SAAA,CAAA,sBAAA,GAAA;IACA,SAAA,CAAA,kBAAA,GAAA;IAEA,SAAA,CAAA,UAAA,GAAA;IAEA,SAAA,CAAA,iBAAA,GAAA;IACA,SAAA,CAAA,gBAAA,GAAA;IAEA,SAAA,CAAA,aAAA,GAAA;IACA,SAAA,CAAA,gBAAA,GAAA;IACA,SAAA,CAAA,gBAAA,GAAA;IAEA,SAAA,CAAA,aAAA,GAAA;IACA,SAAA,CAAA,gBAAA,GAAA;IACA,SAAA,CAAA,gBAAA,GAAA;IAEA,SAAA,CAAA,kBAAA,GAAA;IACA,SAAA,CAAA,uBAAA,GAAA;IACA,SAAA,CAAA,oBAAA,GAAA;IAEA,SAAA,CAAA,oBAAA,GAAA;IAEA,SAAA,CAAA,uBAAA,GAAA;IACA,SAAA,CAAA,gBAAA,GAAA;AACF,CAAA,EA3DY,6CAAA,CAAA,4CAAS,CAAA,CAAA;;;;;;ACpBrB;;;;CAIG,GAgBG,MAAgB;IAKpB,YAAY,OAAgC,CAA5C;QACE,IAAI,CAAC,QAAQ,GAAG;IAClB;IAIA,IAAW,OAAO,MAAkB,EAApC;QACE,IAAI,CAAC,OAAO,GAAG;IACjB;IACA,IAAW,QAAQ,OAAe,EAAlC;QACE,IAAI,CAAC,QAAQ,GAAG;IAClB;AACD;;;;;;;ACrCD;;;;CAIG,GAEH,IAAY;AAAZ,CAAA,SAAY,QAAQ;IAClB,QAAA,CAAA,QAAA,CAAA,OAAA,GAAA,EAAA,GAAA;IACA,QAAA,CAAA,QAAA,CAAA,QAAA,GAAA,EAAA,GAAA;IACA,QAAA,CAAA,QAAA,CAAA,OAAA,GAAA,EAAA,GAAA;IACA,QAAA,CAAA,QAAA,CAAA,OAAA,GAAA,EAAA,GAAA;IACA,QAAA,CAAA,QAAA,CAAA,QAAA,GAAA,EAAA,GAAA;AACF,CAAA,EANY,6CAAA,CAAA,4CAAQ,CAAA,CAAA;AAQpB,MAAM;IAIJ,aAAA;QAFQ,IAAA,CAAA,KAAK,GAAa,0CAAS,KAAK;IAEjB;IAEvB,OAAO,cAAP;QACE,IAAI,CAAC,6BAAO,QAAQ,EAClB,6BAAO,QAAQ,GAAG,IAAI;QAExB,OAAO,6BAAO,QAAQ;IACxB;IAEA,SAAS,KAAe,EAAxB;QACE,IAAI,CAAC,KAAK,GAAG;IACf;IAEA,MAAM,GAAG,IAAe,EAAxB;QACE,IAAI,IAAI,CAAC,KAAK,IAAI,0CAAS,KAAK,EAC9B,QAAQ,KAAK,IAAI;IAErB;IAEA,KAAK,GAAG,IAAe,EAAvB;QACE,IAAI,IAAI,CAAC,KAAK,IAAI,0CAAS,IAAI,EAC7B,QAAQ,IAAI,IAAI;IAEpB;IAEA,KAAK,GAAG,IAAe,EAAvB;QACE,IAAI,IAAI,CAAC,KAAK,IAAI,0CAAS,IAAI,EAC7B,QAAQ,IAAI,IAAI;IAEpB;IAEA,MAAM,GAAG,IAAe,EAAxB;QACE,IAAI,IAAI,CAAC,KAAK,IAAI,0CAAS,KAAK,EAC9B,QAAQ,KAAK,IAAI;IAErB;AACD;AAEM,MAAM,2CAAS,6BAAO,WAAW;;;;;;;;;;ACxDxC;;;;CAIG;;;;AASI,MAAM,4CAAqB;AAElC,IAAY;AAAZ,CAAA,SAAY,eAAe;IACzB,WAAW;IACX,eAAA,CAAA,eAAA,GAAA;IACA,eAAA,CAAA,gBAAA,GAAA;IACA,eAAA,CAAA,aAAA,GAAA;IACA,eAAA,CAAA,kBAAA,GAAA;IACA,eAAA,CAAA,mBAAA,GAAA;IACA,eAAA,CAAA,iBAAA,GAAA;IACA,eAAA,CAAA,SAAA,GAAA;IAEA,UAAU;IACV,eAAA,CAAA,YAAA,GAAA;IACA,eAAA,CAAA,QAAA,GAAA;IACA,eAAA,CAAA,iBAAA,GAAA;IACA,eAAA,CAAA,SAAA,GAAA;IACA,eAAA,CAAA,mBAAA,GAAA;IACA,eAAA,CAAA,eAAA,GAAA;IACA,eAAA,CAAA,oBAAA,GAAA;IACA,eAAA,CAAA,kBAAA,GAAA;IACA,eAAA,CAAA,UAAA,GAAA;IACA,eAAA,CAAA,qBAAA,GAAA;IACA,eAAA,CAAA,oBAAA,GAAA;IACA,eAAA,CAAA,wBAAA,GAAA;IACA,eAAA,CAAA,wBAAA,GAAA;IACA,eAAA,CAAA,uBAAA,GAAA;IACA,eAAA,CAAA,uBAAA,GAAA;IACA,mBAAmB;IACnB,eAAA,CAAA,gBAAA,GAAA;IACA,eAAA,CAAA,eAAA,GAAA;IACA,eAAA,CAAA,kBAAA,GAAA;IACA,eAAA,CAAA,kBAAA,GAAA;IACA,eAAA,CAAA,eAAA,GAAA;IACA,eAAA,CAAA,kBAAA,GAAA;IACA,eAAA,CAAA,kBAAA,GAAA;IACA,eAAA,CAAA,0BAAA,GAAA;IACA,UAAU;IACV,eAAA,CAAA,sBAAA,GAAA;IACA,4BAA4B;IAC5B,eAAA,CAAA,iBAAA,GAAA;AACF,CAAA,EAvCY,6CAAA,CAAA,4CAAe,CAAA,CAAA;AAsHrB,MAAO;IAMX,YAAY,IAAY,EAAE,IAAa,EAAE,EAAW,CAApD;QAJA,IAAA,CAAA,KAAK,GAAW;QAKd,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,EAAE,GAAG,MAAM,CAAA,GAAA,cAAA,IAAS,KAAK,CAAC,GAAG;IACpC;IAEA,yBAAyB;IACzB,OAAO,cAAP;QACE,OAAO,IAAI,yCAAY,0CAAgB,YAAY,EAAE,CAAA;IACvD;IAEA,OAAO,aACL,MAAgC,EAChC,YAAqB,KAAK,EAF5B;QAIE,OAAO,IAAI,yCAAY,0CAAgB,aAAa,EAAE;oBACpD;uBACA;QACD;IACH;IAEA,OAAO,iBAAP;QACE,OAAO,IAAI,yCAAY,0CAAgB,eAAe,EAAE,CAAA;IAC1D;IAEA,OAAO,eAAP;QACE,OAAO,IAAI,yCAAY,0CAAgB,UAAU,EAAE,CAAA;IACrD;IAEA,OAAO,kBAAP;QACE,OAAO,IAAI,yCAAY,0CAAgB,gBAAgB,EAAE,CAAA;IAC3D;IAEA,OAAO,gBAAP;QACE,OAAO,IAAI,yCAAY,0CAAgB,cAAc,EAAE,CAAA;IACzD;IAEA,OAAO,MAAM,OAAe,EAAE,QAAQ,KAAK,EAA3C;QACE,OAAO,IAAI,yCAAY,0CAAgB,KAAK,EAAE;qBAAE;mBAAS;QAAK;IAChE;AACD;AAUK,MAAO,kDAA0B;IACrC,YAAY,IAA2B,CAAvC;QACE,KAAK,CAAC,0CAAgB,MAAM,EAAE;IAChC;AACD;AAkBK,MAAO;IAKX,YAAY,MAAkB,CAA9B;QAFQ,IAAA,CAAA,MAAM,GAAG,IAAI;QAGnB,IAAI,CAAC,OAAO,GAAG,OAAO,gDAAgD;QACtE,IAAI,CAAC,MAAM,GAAG,EAAE;QAChB,IAAI,CAAC,OAAO,GAAG;IACjB;IAEO,SAAS,OAAoB,EAA7B;QACL,MAAM,UAAU,IAAI,QAAQ,CAAC,SAAS;YACpC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC;yBACf;gBACA,WAAW,KAAK,GAAG;yBACnB;wBACA;YACD;QACH;QAEA,CAAA,GAAA,wCAAA,EAAO,KAAK,CAAC,gCAAgC;QAE7C,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC;QAEzB,IAAI,CAAC,GAAG;QAER,OAAO;IACT;IAEO,MAAM,eACX,MAAyB,EACzB,SAAyC,EAFpC;QAIL,MAAM,UAAU,IAAI,QAAQ,CAAC,SAAS;YACpC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC;gBACf,SAAS;gBACT,WAAW,KAAK,GAAG;yBACnB;wBACA;YACD;QACH;QAEA,CAAA,GAAA,wCAAA,EAAO,KAAK,CAAC,8BAA8B;QAE3C,IAAI,IAAI,CAAC,OAAO,CAAC,SAAS,EACxB,2CAA2C;QAC3C,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC;aACpB;YACL,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,SAAS,EAAE,QAAQ;gBAC1C,CAAA,GAAA,wCAAA,EAAO,KAAK,CACV;gBAEF,MAAM,IAAI,CAAA,GAAA,yCAAA;YACZ;YACA,MAAM,YAAY,IAAI,CAAC,OAAO,CAAC,YAAY,CAAC;YAE5C,IAAI;gBACF,6CAA6C;gBAC7C,MAAM,CAAA,GAAA,yCAAA,EACJ,WACA,QACA,IAAI,CAAC,OAAO,CAAC,MAAM,EACnB,CAAC;oBACC,UAAU;gBACZ;YAEF,mEAAmE;YACrE,EAAE,OAAO,GAAG;gBACV,UACE,IAAI,yCACF,0CAAgB,cAAc,EAC9B,CAAA,iBAAA,EAAoB,UAAS,4BAAA,CAA8B,EAC3D,OAAO,EAAE;YAGf;QACF;QAEA,IAAI,CAAC,GAAG;QAER,OAAO;IACT;IAEQ,eACN,OAAoB,EACpB,UAAmB,IAAI,EAFjB;QAIN,MAAM,gBAAgB,IAAI,CAAC,MAAM,CAAC,IAAI,CACpC,CAAC,MAAQ,IAAI,OAAO,CAAC,EAAE,KAAK,QAAQ,EAAE;QAGxC,IAAI,eAAe;YACjB,IAAI,SAAS;gBACX,CAAA,GAAA,wCAAA,EAAO,KAAK,CAAC,+BAA+B;gBAC5C,cAAc,OAAO,CACnB,QAAQ,IAAI,KAAK,0CAAgB,eAAe,GAC3C,UACA;YAET,OAAO;gBACL,CAAA,GAAA,wCAAA,EAAO,KAAK,CAAC,8BAA8B;gBAC3C,cAAc,MAAM,CAAC;YACvB;YACA,4BAA4B;YAC5B,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,MAAQ,IAAI,OAAO,CAAC,EAAE,KAAK,QAAQ,EAAE;YACvE,CAAA,GAAA,wCAAA,EAAO,KAAK,CAAC,6BAA6B,IAAI,CAAC,MAAM;QACvD;QAEA,OAAO;IACT;IAEO,QAAQ,OAAoB,EAA5B;QACL,OAAO,IAAI,CAAC,cAAc,CAAC,SAAS;IACtC;IAEO,OAAO,OAAoB,EAA3B;QACL,OAAO,IAAI,CAAC,cAAc,CAAC,SAAS;IACtC;IAEQ,MAAA;QACN,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;YAChC,OAAO,KAAK,GAAG,KAAK,IAAI,SAAS,GAAG,IAAI,CAAC,OAAO;QAClD;QACA,CAAA,GAAA,wCAAA,EAAO,KAAK,CAAC,0BAA0B,IAAI,CAAC,MAAM;IACpD;AACD;;;A,I,mC,a,U,U,I,S,U,E,M,E,G,E,I;I,I,I,U,M,E,I,I,I,S,S,O,O,O,wB,C,Q,O,M;I,I,O,Y,Y,O,Q,Q,K,Y,I,Q,Q,C,Y,Q,K;S,I,I,I,W,M,G,G,K,G,I,I,I,U,C,E,E,I,A,C,I,I,E,K,I,I,E,Q,K,K,E,Q,I,K;I,O,I,K,K,O,c,C,Q,K,I;A;APlSD,MAAM,yCAA4D;IAChE,SAAS;IACT,QAAQ;AACT;AAED,MAAM;IAIJ,YAAY,SAAoB,CAAhC;QACE,IAAI,CAAC,UAAU,GAAG;QAClB,IAAI,CAAC,MAAM,GAAG,IAAI,MAAM,IAAI,CAAC,UAAU,EAAE;YACvC,KAAK,CAAC,QAAQ,MAAM;gBAClB,IAAI,OAAO,MAAM,CAAC,KAAwB,KAAK,YAAY;oBACzD,IAAI;oBACJ,OAAQ,OAAO;wBACb,0EAA0E;wBAC1E,0EAA0E;wBAC1E,KAAK;4BACH,SAAS,CAAA,wEAAA,CAA0E;4BACnF;wBACF,KAAK;4BACH,SAAS,CAAA,8EAAA,CAAgF;4BACzF;wBACF,KAAK;4BACH,SAAS,CAAA,gEAAA,CAAkE;4BAC3E;wBACF,KAAK;4BACH,SAAS,CAAA,sEAAA,CAAwE;4BACjF;oBACJ;oBACA,IAAI,QACF,OAAO;wBACL,MAAM,IAAI,MAAM;oBAClB;oBAEF,6BAA6B;oBAC7B,OAAO,CAAC,GAAG;wBACT,OAAQ,MAAM,CAAC,KAAqC,IAAI;oBAC1D;gBACF;gBACA,0BAA0B;gBAC1B,OAAO,QAAQ,GAAG,CAAC,QAAQ,MAAM;YACnC;QACD;IACH;IAEA,IAAI,QAAJ;QACE,OAAO,IAAI,CAAC,MAAM;IACpB;AACD;AA2HD,MAAe,+CAA0B,CAAA,GAAA,uCAAA;AAAiE;AAEpG,MAAO,kDAAmB;IAW9B,YAAY,OAA0B,CAAtC;QACE,KAAK;QAEL,IAAI,CAAC,MAAM,GAAG;YACZ,GAAG,QAAQ,MAAM;YACjB,WAAW;gBACT,GAAG,sCAAgB;gBACnB,GAAI,QAAQ,MAAM,CAAC,SAAS,IAAI,CAAA,CAAE;YACnC;QACF;QAED,IAAI,CAAC,QAAQ,GAAG,CAAA;QAChB,IAAI,CAAC,UAAU,GAAG,QAAQ,SAAS;QACnC,IAAI,CAAC,iBAAiB,GAAG,IAAI,uCAAiB,IAAI,CAAC,UAAU;QAE7D,+CAA+C;QAC/C,4EAA4E;QAC5E,MAAM,mBAAuC;YAC3C,GAAG,QAAQ,SAAS;YACpB,gBAAgB,CAAC;gBACf,SAAS,WAAW,iBAAiB;gBACrC,IAAI,CAAC,IAAI,CAAC,CAAA,GAAA,yCAAA,EAAU,YAAY,EAAE;YACpC;YACA,SAAS,CAAC;gBACR,SAAS,WAAW,UAAU;gBAC9B,IAAI;oBACF,IAAI,CAAC,IAAI,CAAC,CAAA,GAAA,yCAAA,EAAU,KAAK,EAAE;gBAC7B,EAAE,OAAO,GAAG;oBACV,CAAA,GAAA,wCAAA,EAAO,KAAK,CAAC,wBAAwB;gBACvC;gBACA,MAAM,OAAO,QAAQ,IAAiB;gBACtC,IAAI,MAAM,OAAO;oBACf,CAAA,GAAA,wCAAA,EAAO,KAAK,CAAC;oBACb,IAAI,CAAC,UAAU;gBACjB;YACF;YACA,aAAa;gBACX,SAAS,WAAW;gBACpB,IAAI,CAAC,IAAI,CAAC,CAAA,GAAA,yCAAA,EAAU,SAAS;YAC/B;YACA,gBAAgB;gBACd,SAAS,WAAW;gBACpB,IAAI,CAAC,IAAI,CAAC,CAAA,GAAA,yCAAA,EAAU,YAAY;YAClC;YACA,yBAAyB,CAAC;gBACxB,SAAS,WAAW,0BAA0B;gBAC9C,IAAI,CAAC,IAAI,CAAC,CAAA,GAAA,yCAAA,EAAU,qBAAqB,EAAE;YAC7C;YACA,UAAU,CAAC;gBACT,SAAS,WAAW,WAAW;gBAC/B,IAAI,CAAC,IAAI,CAAC,CAAA,GAAA,yCAAA,EAAU,MAAM,EAAE;YAC9B;YACA,kBAAkB,CAAC;gBACjB,SAAS,WAAW,mBAAmB;gBACvC,IAAI,CAAC,IAAI,CAAC,CAAA,GAAA,yCAAA,EAAU,cAAc,EAAE;YACtC;YACA,oBAAoB,CAAC;gBACnB,SAAS,WAAW,qBAAqB;gBACzC,IAAI,CAAC,IAAI,CAAC,CAAA,GAAA,yCAAA,EAAU,gBAAgB,EAAE;YACxC;YACA,qBAAqB,CAAC;gBACpB,SAAS,WAAW,sBAAsB;gBAC1C,IAAI,CAAC,IAAI,CAAC,CAAA,GAAA,yCAAA,EAAU,oBAAoB,EAAE;YAC5C;YACA,mBAAmB,CAAC;gBAClB,SAAS,WAAW,oBAAoB;gBACxC,IAAI,CAAC,IAAI,CAAC,CAAA,GAAA,yCAAA,EAAU,eAAe,EAAE;YACvC;YACA,gBAAgB,CAAC,OAAO;gBACtB,SAAS,WAAW,iBAAiB,OAAO;gBAC5C,IAAI,CAAC,IAAI,CAAC,CAAA,GAAA,yCAAA,EAAU,YAAY,EAAE,OAAO;YAC3C;YACA,gBAAgB,CAAC,OAAO;gBACtB,SAAS,WAAW,iBAAiB,OAAO;gBAC5C,IAAI,CAAC,IAAI,CAAC,CAAA,GAAA,yCAAA,EAAU,YAAY,EAAE,OAAO;YAC3C;YACA,sBAAsB,CAAC,OAAO;gBAC5B,SAAS,WAAW,uBAAuB,OAAO;gBAClD,IAAI,CAAC,IAAI,CAAC,CAAA,GAAA,yCAAA,EAAU,kBAAkB,EAAE,OAAO;YACjD;YACA,sBAAsB,CAAC,OAAO;gBAC5B,SAAS,WAAW,uBAAuB,OAAO;gBAClD,IAAI,CAAC,IAAI,CAAC,CAAA,GAAA,yCAAA,EAAU,kBAAkB,EAAE,OAAO;YACjD;YACA,oBAAoB,CAAC;gBACnB,SAAS,WAAW,qBAAqB;gBACzC,IAAI,CAAC,IAAI,CAAC,CAAA,GAAA,yCAAA,EAAU,gBAAgB,EAAE;YACxC;YACA,wBAAwB,CAAC;gBACvB,SAAS,WAAW,yBAAyB;gBAC7C,IAAI,CAAC,IAAI,CAAC,CAAA,GAAA,yCAAA,EAAU,oBAAoB,EAAE;YAC5C;YACA,wBAAwB,CAAC;gBACvB,SAAS,WAAW,yBAAyB;gBAC7C,IAAI,CAAC,IAAI,CAAC,CAAA,GAAA,yCAAA,EAAU,oBAAoB,EAAE;YAC5C;YACA,4BAA4B,CAAC;gBAC3B,SAAS,WAAW,6BAA6B;gBACjD,IAAI,CAAC,IAAI,CAAC,CAAA,GAAA,yCAAA,EAAU,wBAAwB,EAAE;YAChD;YACA,cAAc,CAAC;gBACb,SAAS,WAAW,eAAe;gBACnC,IAAI,CAAC,IAAI,CAAC,CAAA,GAAA,yCAAA,EAAU,UAAU,EAAE;YAClC;YACA,cAAc,CAAC;gBACb,SAAS,WAAW,eAAe;gBACnC,IAAI,CAAC,IAAI,CAAC,CAAA,GAAA,yCAAA,EAAU,UAAU,EAAE;YAClC;YACA,kBAAkB,CAAC;gBACjB,SAAS,WAAW,mBAAmB;gBACvC,IAAI,CAAC,IAAI,CAAC,CAAA,GAAA,yCAAA,EAAU,cAAc,EAAE;YACtC;YACA,gBAAgB,CAAC;gBACf,SAAS,WAAW,iBAAiB;gBACrC,IAAI,CAAC,IAAI,CAAC,CAAA,GAAA,yCAAA,EAAU,YAAY,EAAE;YACpC;YACA,YAAY,CAAC;gBACX,SAAS,WAAW,aAAa;gBACjC,IAAI,CAAC,IAAI,CAAC,CAAA,GAAA,yCAAA,EAAU,QAAQ,EAAE;YAChC;YACA,mBAAmB,CAAC;gBAClB,SAAS,WAAW,oBAAoB;gBACxC,IAAI,CAAC,IAAI,CAAC,CAAA,GAAA,yCAAA,EAAU,eAAe,EAAE;YACvC;YACA,sBAAsB;gBACpB,SAAS,WAAW;gBACpB,IAAI,CAAC,IAAI,CAAC,CAAA,GAAA,yCAAA,EAAU,kBAAkB;YACxC;YACA,sBAAsB;gBACpB,SAAS,WAAW;gBACpB,IAAI,CAAC,IAAI,CAAC,CAAA,GAAA,yCAAA,EAAU,kBAAkB;YACxC;YACA,oBAAoB,CAAC,OAAO;gBAC1B,SAAS,WAAW,qBAAqB,OAAO;gBAChD,IAAI,CAAC,IAAI,CAAC,CAAA,GAAA,yCAAA,EAAU,gBAAgB,EAAE,OAAO;YAC/C;YACA,uBAAuB;gBACrB,SAAS,WAAW;gBACpB,IAAI,CAAC,IAAI,CAAC,CAAA,GAAA,yCAAA,EAAU,mBAAmB;YACzC;YACA,uBAAuB;gBACrB,SAAS,WAAW;gBACpB,IAAI,CAAC,IAAI,CAAC,CAAA,GAAA,yCAAA,EAAU,mBAAmB;YACzC;YACA,mBAAmB,CAAC;gBAClB,SAAS,WAAW,oBAAoB;gBACxC,IAAI,CAAC,IAAI,CAAC,CAAA,GAAA,yCAAA,EAAU,eAAe,EAAE;YACvC;YACA,kBAAkB,CAAC;gBACjB,SAAS,WAAW,mBAAmB;gBACvC,IAAI,CAAC,IAAI,CAAC,CAAA,GAAA,yCAAA,EAAU,cAAc,EAAE;YACtC;YACA,iBAAiB,CAAC;gBAChB,SAAS,WAAW,kBAAkB;gBACtC,IAAI,CAAC,IAAI,CAAC,CAAA,GAAA,yCAAA,EAAU,aAAa,EAAE;YACrC;YACA,cAAc,CAAC;gBACb,SAAS,WAAW,eAAe;gBACnC,IAAI,CAAC,IAAI,CAAC,CAAA,GAAA,yCAAA,EAAU,UAAU,EAAE;YAClC;YACA,iBAAiB;gBACf,SAAS,WAAW;gBACpB,IAAI,CAAC,IAAI,CAAC,CAAA,GAAA,yCAAA,EAAU,aAAa;YACnC;YACA,iBAAiB;gBACf,SAAS,WAAW;gBACpB,IAAI,CAAC,IAAI,CAAC,CAAA,GAAA,yCAAA,EAAU,aAAa;YACnC;YACA,cAAc,CAAC;gBACb,SAAS,WAAW,eAAe;gBACnC,IAAI,CAAC,IAAI,CAAC,CAAA,GAAA,yCAAA,EAAU,UAAU,EAAE;YAClC;YACA,iBAAiB;gBACf,SAAS,WAAW;gBACpB,IAAI,CAAC,IAAI,CAAC,CAAA,GAAA,yCAAA,EAAU,aAAa;YACnC;YACA,iBAAiB;gBACf,SAAS,WAAW;gBACpB,IAAI,CAAC,IAAI,CAAC,CAAA,GAAA,yCAAA,EAAU,aAAa;YACnC;YACA,qBAAqB,CAAC;gBACpB,SAAS,WAAW,sBAAsB;gBAC1C,IAAI,CAAC,IAAI,CAAC,CAAA,GAAA,yCAAA,EAAU,iBAAiB,EAAE;YACzC;QACD;QAED,oEAAoE;QACpE,IAAI,CAAC,QAAQ,GAAG;YACd,GAAG,OAAO;YACV,WAAW;YACX,WAAW,QAAQ,SAAS,IAAI;YAChC,WAAW,QAAQ,SAAS,IAAI;QACjC;QAED,2DAA2D;QAC3D,IAAI,CAAC,WAAW;QAEhB,6BAA6B;QAC7B,CAAA,GAAA,wCAAA,EAAO,KAAK,CAAC,6BAA6B,IAAI,CAAC,OAAO;IACxD;IAEO,aAAa,QAA0B,EAAvC;QACL,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,EACtB,MAAM,IAAI,0CACR;QAGJ,MAAM,UAAU,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,QAAQ;QACpD,OAAO,UAAW,CAAA,IAAI,CAAC,MAAM,CAAC,SAAS,EAAE,CAAC,SAAS,IAAI,EAAA;IACzD;IAEO,YAAY,KAAe,EAA3B;QACL,CAAA,GAAA,wCAAA,EAAO,QAAQ,CAAC;IAClB;IAEA,2BAA2B;IAE3B;;KAEG,GACI,MAAM,cAAN;QACL,CAAA,GAAA,wCAAA,EAAO,KAAK,CAAC;QACb,MAAM,IAAI,CAAC,UAAU,CAAC,WAAW;IACnC;IAEA;;;KAGG,GACI,MAAM,UAAN;QACL,IACE;YAAC;YAAkB;YAAc;YAAa;SAAQ,CAAC,QAAQ,CAC7D,IAAI,CAAC,UAAU,CAAC,KAAK,GAGvB,MAAM,IAAI,0CACR;QAIJ,IAAI,CAAC,gBAAgB,GAAG,IAAI;QAE5B,yDAAyD;QACzD,OAAO,IAAI,QAAQ,CAAC,SAAS;YAC1B,CAAA;gBACC,IAAI,CAAC,aAAa,GAAG;gBAErB,IAAI,IAAI,CAAC,UAAU,CAAC,KAAK,KAAK,gBAC5B,MAAM,IAAI,CAAC,UAAU,CAAC,WAAW;gBAGnC,IAAI,CAAC,UAAU,CAAC,KAAK,GAAG;gBAExB,8EAA8E;gBAC9E,IAAI,IAAI,CAAC,QAAQ,CAAC,OAAO,EACvB,IAAI,CAAC,iBAAiB,GAAG,WAAW;oBAClC,IAAI,CAAC,gBAAgB,EAAE;oBACvB,MAAM,IAAI,CAAC,UAAU;oBACrB,IAAI,CAAC,UAAU,CAAC,KAAK,GAAG;oBACxB,OAAO,IAAI;gBACb,GAAG,IAAI,CAAC,QAAQ,CAAC,OAAO;gBAG1B,IAAI;gBACJ,MAAM,uBAAuB,IAAI,CAAC,QAAQ,CAAC,oBAAoB;gBAE/D,CAAA,GAAA,wCAAA,EAAO,KAAK,CAAC,8BAA8B,IAAI,CAAC,MAAM;gBAEtD,IAAI,CAAC,MAAM,GAAG;oBACZ,GAAG,IAAI,CAAC,MAAM;oBACd,aAAa;wBACX,GAAG,IAAI,CAAC,MAAM,CAAC,WAAW;wBAC1B,qBAAqB,IAAI,CAAC,OAAO;oBAClC;gBACF;gBAED,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,SAAS,EAAE,SAAS;oBAC3D,0FAA0F;oBAC1F,wGAAwG;oBACxG,oEAAoE;oBACpE,CAAA,GAAA,wCAAA,EAAO,KAAK,CACV;oBAEF,aAAa,IAAI,CAAC,iBAAiB;gBACrC,OAAO;oBACL,MAAM,aAAa,IAAI,CAAC,YAAY,CAAC;oBAErC,CAAA,GAAA,wCAAA,EAAO,KAAK,CAAC,+BAA+B;oBAC5C,CAAA,GAAA,wCAAA,EAAO,KAAK,CAAC,8BAA8B,IAAI,CAAC,MAAM;oBAEtD,IAAI;wBACF,IAAI,sBACF,aAAa,MAAM,qBACjB,IAAI,CAAC,MAAM,EACX,IAAI,CAAC,iBAAiB,EACtB,IAAI,CAAC,gBAAiB;6BAGxB,aAAa,MAAM,MAAM,YAAY;4BACnC,QAAQ;4BACR,MAAM;4BACN,SAAS,IAAI,QAAQ;gCACnB,gBAAgB;gCAChB,GAAG,OAAO,WAAW,CACnB,AAAC,CAAA,IAAI,CAAC,MAAM,CAAC,OAAO,IAAI,IAAI,SAAO,EAAI,OAAO,GAC/C;4BACF;4BACD,MAAM,KAAK,SAAS,CAAC;gCACnB,QAAQ,IAAI,CAAC,MAAM,CAAC,MAAM;gCAC1B,GAAI,IAAI,CAAC,MAAM,CAAC,QAAQ,GACpB;oCAAE,UAAU,IAAI,CAAC,MAAM,CAAC,QAAQ;gCAAA,IAChC,CAAA,CAAE;gCACN,GAAG,IAAI,CAAC,MAAM,CAAC,WAAW;4BAC3B;4BACD,QAAQ,IAAI,CAAC,gBAAgB,EAAE;wBAChC,GAAE,IAAI,CAAC,CAAC;4BACP,aAAa,IAAI,CAAC,iBAAiB;4BAEnC,IAAI,IAAI,EAAE,EACR,OAAO,IAAI,IAAI;4BAGjB,OAAO,QAAQ,MAAM,CAAC;wBACxB;oBAEJ,EAAE,OAAO,GAAG;wBACV,aAAa,IAAI,CAAC,iBAAiB;wBACnC,+CAA+C;wBAC/C,IAAI,IAAI,CAAC,gBAAgB,EAAE,OAAO,SAChC;wBAEF,IAAI,CAAC,UAAU,CAAC,KAAK,GAAG;wBACxB,IAAI,aAAa,UAAU;4BACzB,MAAM,YAAY,MAAM,EAAE,IAAI;4BAC9B,OACE,IAAI,0CACF,UAAU,IAAI,IAAI,UAAU,MAAM,IAAI,EAAE,UAAU,EAClD,EAAE,MAAM;wBAGd,OACE,OAAO,IAAI;wBAEb;oBACF;oBAEA,CAAA,GAAA,wCAAA,EAAO,KAAK,CAAC,sCAAsC;gBACrD;gBACA,IAAI;oBACF,MAAM,IAAI,CAAC,UAAU,CAAC,OAAO,CAC3B,YACA,IAAI,CAAC,gBAAmC;oBAE1C,MAAM,IAAI,CAAC,UAAU,CAAC,gBAAgB;gBACxC,EAAE,OAAO,GAAG;oBACV,aAAa,IAAI,CAAC,iBAAiB;oBACnC,IAAI,CAAC,UAAU;oBACf,OAAO;oBACP;gBACF;YACF,CAAA;QACF;IACF;IAEA;;;KAGG,GACI,MAAM,aAAN;QACL,IAAI,IAAI,CAAC,gBAAgB,EACvB,IAAI,CAAC,gBAAgB,CAAC,KAAK;QAG7B,aAAa,IAAI,CAAC,iBAAiB;QAEnC,MAAM,IAAI,CAAC,UAAU,CAAC,UAAU;QAEhC,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAA,GAAA,yCAAA,EAAkB,IAAI;IACtD;IAEQ,cAAA;QACN,IAAI,CAAC,UAAU,CAAC,UAAU,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI;QAEtE,iEAAiE;QACjE,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAA,GAAA,yCAAA,EAAkB,IAAI;IACtD;IAEA;;KAEG,GACH,IAAW,YAAX;QACE,OAAO;YAAC;YAAa;SAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,UAAU,CAAC,KAAK;IAC9D;IAEA,IAAW,YAAX;QACE,OAAO,IAAI,CAAC,iBAAiB,CAAC,KAAK;IACrC;IAEA,IAAW,QAAX;QACE,OAAO,IAAI,CAAC,UAAU,CAAC,KAAK;IAC9B;IAEA,IAAW,UAAX;QACE,OAAO,CAAA,GAAA,gEAAA,EAAY,OAAO;IAC5B;IAEA,wBAAwB;IAEjB,MAAM,aAAN;QACL,OAAO,MAAM,IAAI,CAAC,UAAU,CAAC,UAAU;IACzC;IAEO,MAAM,aAAN;QACL,OAAO,MAAM,IAAI,CAAC,UAAU,CAAC,UAAU;IACzC;IAEO,MAAM,iBAAN;QACL,OAAO,MAAM,IAAI,CAAC,UAAU,CAAC,cAAc;IAC7C;IAEA,IAAW,cAAX;QACE,OAAO,IAAI,CAAC,UAAU,CAAC,WAAW;IACpC;IAEA,IAAW,cAAX;QACE,OAAO,IAAI,CAAC,UAAU,CAAC,WAAW;IACpC;IAEA,IAAW,kBAAX;QACE,OAAO,IAAI,CAAC,UAAU,CAAC,eAAe;IACxC;IAEO,UAAU,KAAa,EAAvB;QACL,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC;IAC5B;IAEO,UAAU,KAAa,EAAvB;QACL,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC;IAC5B;IAEO,cAAc,SAAiB,EAA/B;QACL,IAAI,CAAC,UAAU,CAAC,aAAa,CAAC;IAChC;IAEO,UAAU,MAAe,EAAzB;QACL,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC;IAC5B;IAEA,IAAW,eAAX;QACE,OAAO,IAAI,CAAC,UAAU,CAAC,YAAY;IACrC;IAEO,UAAU,MAAe,EAAzB;QACL,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC;IAC5B;IAEA,IAAW,eAAX;QACE,OAAO,IAAI,CAAC,UAAU,CAAC,YAAY;IACrC;IAEO,SAAA;QACL,OAAO,IAAI,CAAC,UAAU,CAAC,MAAM;IAC/B;IAEO,kBAAkB,MAAe,EAAjC;QACL,OAAO,IAAI,CAAC,UAAU,CAAC,iBAAiB,CAAC;IAC3C;IAEA,IAAW,kBAAX;QACE,OAAO,IAAI,CAAC,UAAU,CAAC,eAAe;IACxC;IAEA,wBAAwB;IAExB;;;KAGG,GAEI,MAAM,YAAA;QACX,MAAM,YAAY,MAAM,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CACtD,CAAA,GAAA,wCAAA,EAAY,YAAY;QAE1B,OAAQ,UAAU,IAAmB,CAAC,MAAkC;IAC1E;IAEA;;;;;KAKG,GAEI,MAAM,aACX,MAAgC,EAChC,YAAqB,KAAK,EAFf;QAIX,CAAA,GAAA,wCAAA,EAAO,KAAK,CAAC,iCAAiC;QAC9C,8DAA8D;QAC9D,+DAA+D;QAC/D,OAAO,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CACrC,CAAA,GAAA,wCAAA,EAAY,YAAY,CAAC,QAAQ;IAErC;IAEA;;;KAGG,GAEI,MAAM,iBAAA;QACX,OAAO,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,CAAA,GAAA,wCAAA,EAAY,cAAc;IACpE;IAEA;;;;;KAKG,GACI,MAAM,4BACX,UAAkB,EAClB,MAAiC,EAF5B;QAIL,IAAI,CAAC,UAAU,IAAI,CAAC,KAAK,KAAK,SAC5B,MAAM,IAAI,0CACR;QAIJ,OAAO,QAAQ,OAAO,GAAG,IAAI,CAAC;YAC5B,wDAAwD;YACxD,IAAI,CAAC,YAAY;gBACf,CAAA,GAAA,wCAAA,EAAO,KAAK,CAAC;gBACb,OAAO;YACT;YAEA,MAAM,eACJ,UAAW,MAAM,IAAI,CAAC,SAAS;YAEjC,mEAAmE;YACnE,MAAM,mBAAmB,aAAa,IAAI,CACxC,CAAC,SAAmC,OAAO,OAAO,KAAK;YAGzD,IAAI,CAAC,kBAAkB;gBACrB,CAAA,GAAA,wCAAA,EAAO,KAAK,CACV,0BAA0B,aAAa;gBAEzC,OAAO;YACT;YAEA,uDAAuD;YACvD,OAAO;QACT;IACF;IAEA;;;;;KAKG,GACI,MAAM,gCACX,UAAkB,EAClB,MAAc,EACd,MAAiC,EAH5B;QAKL,MAAM,mBACJ,MAAM,IAAI,CAAC,2BAA2B,CAAC,YAAY;QAErD,IAAI,CAAC,kBAAkB;YACrB,CAAA,GAAA,wCAAA,EAAO,KAAK,CAAC,uBAAuB,aAAa;YACjD,OAAO;QACT;QAEA,iDAAiD;QACjD,MAAM,cAAwC,iBAAiB,OAAO,CAAC,IAAI,CACzE,CAAC,IAAoB,EAAE,IAAI,KAAK;QAGlC,OAAO,cAAe,YAA6B,KAAK,GAAG;IAC7D;IAEQ,mBACN,eAA+B,EAC/B,SAAuB,EAFjB;QAIN,MAAM,sBAAsB,gBAAgB,SAAS,CACnD,CAAC,OAAS,KAAK,IAAI,KAAK,UAAU,IAAI;QAExC,IAAI,wBAAwB,IAC1B,yBAAyB;QACzB,OAAO,gBAAgB,GAAG,CAAC,CAAC,MAAM,QAChC,UAAU,sBACN;gBAAE,GAAG,IAAI;gBAAE,OAAO,UAAU,KAAK;YAAA,IACjC;aAGN,iBAAiB;QACjB,OAAO;eACF;YACH;gBAAE,MAAM,UAAU,IAAI;gBAAE,OAAO,UAAU,KAAK;YAAA;SAC/C;IAEL;IAEA;;;;;;;KAOG,GACI,MAAM,yBACX,UAAkB,EAClB,MAAqC,EACrC,MAAiC,EAH5B;QAKL,MAAM,YAAsC,CAAA,GAAA,0CAAA,EAC1C,UAAW,MAAM,IAAI,CAAC,SAAS;QAGjC,MAAM,iBAAiB,MAAM,IAAI,CAAC,2BAA2B,CAC3D,YACA;QAGF,IAAI,CAAC,gBAAgB;YACnB,CAAA,GAAA,wCAAA,EAAO,KAAK,CACV,wBAAwB,aAAa;YAEvC,OAAO;QACT;QAEA,MAAM,eAAe,MAAM,OAAO,CAAC,UAAU,SAAS;YAAC;SAAO;QAE9D,KAAK,MAAM,OAAO,aAAc;YAC9B,MAAM,eAAe,UAAU,IAAI,CACjC,CAAC,OAAS,KAAK,OAAO,KAAK;YAE7B,MAAM,iBAAiB,eACnB,IAAI,CAAC,kBAAkB,CAAC,aAAa,OAAO,EAAE,OAC9C;gBAAC;oBAAE,MAAM,IAAI,IAAI;oBAAE,OAAO,IAAI,KAAK;gBAAA;aAAG;YAE1C,IAAI,cACF,aAAa,OAAO,GAAG;iBAEvB,UAAU,IAAI,CAAC;gBAAE,SAAS;gBAAY,SAAS;YAAc;QAEjE;QAEA,OAAO;IACT;IAEA;;;;;KAKG,GACI,MAAM,iBACX,aAAuC,EACvC,MAAiC,EAF5B;QAIL,IAAI,cAAwC,CAAA,GAAA,0CAAA,EAC1C,UAAW,MAAM,IAAI,CAAC,SAAS;QAGjC,KAAK,MAAM,gBAAgB,cACzB,cACE,AAAC,MAAM,IAAI,CAAC,wBAAwB,CAClC,aAAa,OAAO,EACpB,aAAa,OAAO,EACpB,gBACI;QAEV,OAAO;IACT;IAEA,iBAAiB;IAEjB;;KAEG,GACI,MAAM,OACX,MAA6B,EADxB;QAGL,OAAO,IAAI,CAAC,kBAAkB,CAAC,cAAc,CAC3C,IAAI,CAAA,GAAA,yCAAA,EAAkB,SACtB,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI;IAEhC;IAEA;;;KAGG,GAEI,MAAM,kBAAA;QACX,OAAO,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,CAAA,GAAA,wCAAA,EAAY,eAAe;IACrE;IAEA,2BAA2B;IAE3B;;;KAGG,GAEH,IAAW,kBAAX;QACE,OAAO,IAAI,CAAC,UAAU,CAAC,MAAM;IAC/B;IAEA,kBAAkB;IAElB;;;KAGG,GAEI,YAAY,OAAoB,EAAhC;QACL,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC;IAC9B;IAEA;;KAEG,GAEI,gBAAA;QACL,IAAI,CAAC,UAAU,CAAC,WAAW,CACzB,IAAI,CAAA,GAAA,wCAAA,EAAY,CAAA,GAAA,yCAAA,EAAgB,cAAc,EAAE,CAAA;IAEpD;IAEU,cAAc,EAAe,EAA7B;QACR,CAAA,GAAA,wCAAA,EAAO,KAAK,CAAC,kBAAkB;QAE/B,OAAQ,GAAG,IAAI;YACb,KAAK,CAAA,GAAA,yCAAA,EAAgB,SAAS;gBAC5B,aAAa,IAAI,CAAC,iBAAiB;gBACnC,IAAI,CAAC,aAAa,GAAG,GAAG,IAAoB;gBAC5C,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE,aAAa,GAAG,IAAoB;gBAC7D;YACF,KAAK,CAAA,GAAA,yCAAA,EAAgB,gBAAgB;gBACnC,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC;gBAChC,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE,mBAAmB,GAAG,IAAI;gBACnD;YAEF,KAAK,CAAA,GAAA,yCAAA,EAAgB,MAAM;gBAAE;oBAC3B,MAAM,OAAO,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC;oBAC7C,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE,WAAY,KAAK,IAAmB,CAAC,MAAM;oBACpE;gBACF;YACA,KAAK,CAAA,GAAA,yCAAA,EAAgB,iBAAiB;gBACpC,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC;gBAChC,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE,qBAAqB,GAAG,IAAI;gBACrD;YAEF,KAAK,CAAA,GAAA,yCAAA,EAAgB,eAAe;gBAClC,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC;gBAChC;YAEF,KAAK,CAAA,GAAA,yCAAA,EAAgB,cAAc;gBAAE;oBACnC,MAAM,OAAO,IAAI,CAAC,kBAAkB,CAAC,MAAM,CAAC;oBAC5C,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE,iBAAiB;oBAC1C;gBACF;YACA,KAAK,CAAA,GAAA,yCAAA,EAAgB,KAAK;gBACxB,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE,UAAU;gBACnC;YACF,KAAK,CAAA,GAAA,yCAAA,EAAgB,qBAAqB;gBACxC,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE;gBACzB;YACF,KAAK,CAAA,GAAA,yCAAA,EAAgB,qBAAqB;gBACxC,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE;gBACzB;YACF,KAAK,CAAA,GAAA,yCAAA,EAAgB,oBAAoB;gBACvC,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE;gBACzB;YACF,KAAK,CAAA,GAAA,yCAAA,EAAgB,oBAAoB;gBACvC,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE;gBACzB;YACF,KAAK,CAAA,GAAA,yCAAA,EAAgB,kBAAkB;gBAAE;oBACvC,MAAM,iBAAiB,GAAG,IAAsB;oBAChD,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE,mBAAmB;oBAC5C;gBACF;YACA,KAAK,CAAA,GAAA,yCAAA,EAAgB,iBAAiB;gBACpC,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE,kBAAkB,GAAG,IAAsB;gBACpE;YAEF,KAAK,CAAA,GAAA,yCAAA,EAAgB,YAAY;gBAC/B,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE,eAAe,GAAG,IAAsB;gBACjE;YACF,KAAK,CAAA,GAAA,yCAAA,EAAgB,eAAe;gBAClC,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE;gBACzB;YACF,KAAK,CAAA,GAAA,yCAAA,EAAgB,eAAe;gBAClC,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE;gBACzB;YACF,KAAK,CAAA,GAAA,yCAAA,EAAgB,YAAY;gBAC/B,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE,eAAe,GAAG,IAAsB;gBACjE;YACF,KAAK,CAAA,GAAA,yCAAA,EAAgB,eAAe;gBAClC,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE;gBACzB;YACF,KAAK,CAAA,GAAA,yCAAA,EAAgB,eAAe;gBAClC,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE;gBACzB;YACF,KAAK,CAAA,GAAA,yCAAA,EAAgB,uBAAuB;gBAC1C,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE,yBACvB,GAAG,IAAgC;gBAErC,IAAI,CAAC,IAAI,CACP,CAAA,GAAA,yCAAA,EAAU,oBAAoB,EAC9B,GAAG,IAAgC;gBAErC;YACF,KAAK,CAAA,GAAA,yCAAA,EAAgB,OAAO;gBAC1B,IAAI,CAAC,IAAI,CAAC,CAAA,GAAA,yCAAA,EAAU,OAAO,EAAE,GAAG,IAA0B;gBAC1D,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE,YAAY,GAAG,IAA0B;gBAClE;YACF,KAAK,CAAA,GAAA,yCAAA,EAAgB,mBAAmB;gBACtC,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE,sBACvB,GAAG,IAA6B;gBAElC;YACF,KAAK,CAAA,GAAA,yCAAA,EAAgB,cAAc;gBACjC,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE,kBAAkB,GAAG,IAAI;gBAClD,IAAI,CAAC,IAAI,CAAC,CAAA,GAAA,yCAAA,EAAU,aAAa,EAAE,GAAG,IAAI;gBAC1C;YAEF;gBAAS;oBACP,IAAI,QAAiB;oBACrB,qCAAqC;oBACrC,KAAK,MAAM,UAAU,OAAO,MAAM,CAChC,IAAI,CAAC,QAAQ,EAEb,IAAI,OAAO,eAAe,GAAG,QAAQ,CAAC,GAAG,IAAI,GAAG;wBAC9C,QAAQ;wBACR,OAAO,aAAa,CAAC;oBACvB;oBAEF,IAAI,CAAC,OACH,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE,mBAAmB,GAAG,IAAI;gBAEvD;QACF;IACF;IAEA,iBAAiB;IAEjB;;;;;;;KAOG,GACI,eACL,OAAe,EACf,MAAwB,EAFnB;QAIL,IAAI,IAAI,CAAC,QAAQ,CAAC,QAAQ,EACxB,MAAM,IAAI,MAAM,CAAA,kBAAA,EAAqB,QAAO,oBAAA,CAAsB;QAGpE,+CAA+C;QAC/C,IAAI,CAAE,CAAA,kBAAkB,CAAA,GAAA,yCAAA,CAAA,GACtB,MAAM,IAAI,MAAM,CAAA,8CAAA,CAAgD;QAGlE,OAAO,OAAO,GAAG;QACjB,OAAO,MAAM,GAAG,IAAI;QAEpB,IAAI,CAAC,QAAQ,CAAC,QAAQ,GAAG;QAEzB,OAAO,IAAI,CAAC,QAAQ,CAAC,QAAQ;IAC/B;IAEO,UAAsC,OAAe,EAArD;QACL,MAAM,SAAS,IAAI,CAAC,QAAQ,CAAC,QAAQ;QACrC,IAAI,CAAC,QAAQ;YACX,CAAA,GAAA,wCAAA,EAAO,KAAK,CAAC,CAAA,0BAAA,EAA6B,QAAO,WAAA,CAAa;YAC9D,OAAO;QACT;QACA,OAAO;IACT;IAEO,iBAAiB,OAAe,EAAhC;QACL,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,QAAQ,EACzB;QAEF,OAAO,IAAI,CAAC,QAAQ,CAAC,QAAQ;IAC/B;AACD;AAnac,iCAAA;IADZ,CAAA,GAAA,yCAAA;CAMA,EAAA,0CAAA,SAAA,EAAA,aAAA;AASY,iCAAA;IADZ,CAAA,GAAA,yCAAA;CAWA,EAAA,0CAAA,SAAA,EAAA,gBAAA;AAOY,iCAAA;IADZ,CAAA,GAAA,yCAAA;CAGA,EAAA,0CAAA,SAAA,EAAA,kBAAA;AA4LY,iCAAA;IADZ,CAAA,GAAA,yCAAA;CAGA,EAAA,0CAAA,SAAA,EAAA,mBAAA;AASD,iCAAA;IADC,CAAA,GAAA,yCAAA,EAAsB,aAAa;CAGnC,EAAA,0CAAA,SAAA,EAAA,mBAAA;AASM,iCAAA;IADN,CAAA,GAAA,yCAAA;CAGA,EAAA,0CAAA,SAAA,EAAA,eAAA;AAMM,iCAAA;IADN,CAAA,GAAA,yCAAA;CAKA,EAAA,0CAAA,SAAA,EAAA,iBAAA;;;;;;;;;;;AQv8BH;;;;CAIG;;;;AAsCH,IAAY;AAAZ,CAAA,SAAY,cAAc;IACxB,cAAA,CAAA,oBAAA,GAAA;IACA,cAAA,CAAA,0BAAA,GAAA;IACA,cAAA,CAAA,2BAAA,GAAA;IACA,cAAA,CAAA,sBAAA,GAAA;AACF,CAAA,EALY,6CAAA,CAAA,4CAAc,CAAA,CAAA;AAO1B,IAAY;AAAZ,CAAA,SAAY,aAAa;IACvB,aAAA,CAAA,qBAAA,GAAA;IACA,aAAA,CAAA,cAAA,GAAA;IACA,aAAA,CAAA,cAAA,GAAA;IACA,aAAA,CAAA,MAAA,GAAA;AACF,CAAA,EALY,4CAAA,CAAA,2CAAa,CAAA,CAAA;AAoBnB,MAAO,kDAAkB,CAAA,GAAA,yCAAA;IAI7B,YAAY,OAAyB,CAArC;QACE,KAAK,CAAC;QAEN,IAAI,CAAC,qBAAqB,GAAG;IAC/B;IAEO,kBAAA;QACL,OAAO,OAAO,MAAM,CAAC;IACvB;IAEA,cAAc;IAEd;;;KAGG,GACI,MAAM,aAAN;QACL,IAAI,IAAI,CAAC,OAAO,CAAC,KAAK,KAAK,SACzB,MAAM,IAAI,0CACR;QAGJ,MAAM,oBAAwC,MAAM,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC;YACtE,SAAS,IAAI,CAAC,QAAQ;YACtB,QAAQ,yCAAc,WAAW;QACT;QAC1B,OAAO,kBAAkB,IAAI,CAAC,MAAoB;IACpD;IAEA;;;;;;KAMG,GAEI,MAAM,WACX,OAAmB,EACnB,YAAqB,KAAK,EAFrB;QAIL,IAAI,IAAI,CAAC,OAAO,CAAC,KAAK,KAAK,SACzB,MAAM,IAAI,0CACR;QAIJ,MAAM,iBAAsC,MAAM,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC;YACpE,SAAS,IAAI,CAAC,QAAQ;YACtB,QAAQ,yCAAc,WAAW;YACjC,WAAW;gBACT;oBACE,MAAM;oBACN,OAAO,QAAQ,QAAQ;gBACxB;gBACD;oBACE,MAAM;oBACN,OAAO;gBACR;aACF;QACuB;QAE1B,OAAO,CAAC,CAAC,eAAe,IAAI,CAAC,MAAM;IACrC;IAEA;;;;;;KAMG,GAEI,MAAM,iBACX,OAA0B,EAC1B,iBAA0B,KAAK,EAF1B;QAIL,IAAI,IAAI,CAAC,OAAO,CAAC,KAAK,KAAK,SACzB,MAAM,IAAI,0CACR;QAIJ,MAAM,iBAAkB,MAAM,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC;YAChD,SAAS,IAAI,CAAC,QAAQ;YACtB,QAAQ,yCAAc,kBAAkB;YACxC,WAAW;gBACT;oBACE,MAAM;oBACN,OAAO;wBAAC;qBAAQ;gBACjB;gBACD;oBACE,MAAM;oBACN,OAAO;gBACR;aACF;QACuB;QAC1B,OAAO,CAAC,CAAC,eAAe,IAAI,CAAC,MAAM;IACrC;IAEA;;;;;;KAMG,GACI,MAAM,IAAI,YAAqB,KAAK,EAApC;QACL,IAAI,IAAI,CAAC,OAAO,CAAC,KAAK,KAAK,SACzB;QAGF,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC;YACzB,SAAS,IAAI,CAAC,QAAQ;YACtB,QAAQ,yCAAc,GAAG;YACzB,WAAW;gBACT;oBACE,MAAM;oBACN,OAAO;gBACR;aACF;QACuB;IAC5B;IAEA,eAAe;IAEf;;;;;KAKG,GACI,mBAAmB,QAA8B,EAAjD;QACL,IAAI,CAAC,qBAAqB,GAAG;IAC/B;IAEO,cAAc,EAAe,EAA7B;QACL,OAAQ,GAAG,IAAI;YACb,KAAK,0CAAe,mBAAmB;gBACrC,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE,sBAAsB,GAAG,IAAc;gBAChE,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAA,GAAA,yCAAA,EAAU,iBAAiB,EAAE,GAAG,IAAc;gBAChE;YACF,KAAK,0CAAe,iBAAiB;gBAAE;oBACrC,MAAM,IAAI,GAAG,IAA2B;oBACxC,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE,oBACvB,GAAG,IAA2B;oBAEhC,IAAI,CAAC,OAAO,CAAC,IAAI,CACf,CAAA,GAAA,yCAAA,EAAU,eAAe,EACzB,GAAG,IAA2B;oBAEhC,IAAI,IAAI,CAAC,qBAAqB,EAAE;wBAC9B,MAAM,KAAK;4BACT,cAAc,EAAE,aAAa;4BAC7B,WAAW,EAAE,IAAI;wBAClB;wBACD,IAAI,IAAI,CAAC,OAAO,CAAC,KAAK,KAAK,SACzB,IAAI,CAAC,qBAAqB,CAAC,IAAI,IAAI,CAAC,CAAC;4BACnC,IAAI,CAAC,OAAO,CAAC,WAAW,CACtB,IAAI,CAAA,GAAA,wCAAA,EAAY,0CAAe,wBAAwB,EAAE;gCACvD,eAAe,EAAE,aAAa;gCAC9B,cAAc,EAAE,YAAY;gCAC5B,WAAW,EAAE,IAAI;wCACjB;4BACD;wBAEL;6BAEA,MAAM,IAAI,0CACR;oBAGN;oBACA;gBACF;YACA,KAAK,0CAAe,uBAAuB;gBAAE;oBAC3C,MAAM,IAAI,GAAG,IAA2B;oBACxC,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE,yBACvB,EAAE,aAAuB;oBAE3B,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAA,GAAA,yCAAA,EAAU,oBAAoB,EAAE,EAAE,aAAa;oBACjE;gBACF;QACF;IACF;AACD;;;;;;;;AClQD;;;;CAIG,GAqCG,MAAgB;IAOpB,aAAA;QAHU,IAAA,CAAA,MAAM,GAAmB;QACzB,IAAA,CAAA,OAAO,GAAY;IAEd;IAwCf,IAAI,SAAJ;QACE,OAAO,IAAI,CAAC,OAAO;IACrB;AAGD;;","sources":["client-js/src/index.ts","client-js/src/actions.ts","client-js/src/client.ts","client-js/package.json","client-js/src/decorators.ts","client-js/src/errors.ts","client-js/src/events.ts","client-js/src/helpers/index.ts","client-js/src/logger.ts","client-js/src/messages.ts","client-js/src/helpers/llm.ts","client-js/src/transport.ts"],"sourcesContent":["/**\n * Copyright (c) 2024, Daily.\n *\n * SPDX-License-Identifier: BSD-2-Clause\n */\n\nexport * from \"./actions\";\nexport * from \"./client\";\nexport * from \"./errors\";\nexport * from \"./events\";\nexport * from \"./helpers\";\nexport * from \"./helpers/llm\";\nexport * from \"./logger\";\nexport * from \"./messages\";\nexport * from \"./transport\";\n","/**\n * Copyright (c) 2024, Daily.\n *\n * SPDX-License-Identifier: BSD-2-Clause\n */\n\nimport { logger, RTVIClientParams, RTVIError } from \".\";\nimport { RTVIActionRequest, RTVIActionResponse } from \"./messages\";\n\nexport async function httpActionGenerator(\n  actionUrl: string,\n  action: RTVIActionRequest,\n  params: RTVIClientParams,\n  handleResponse: (response: RTVIActionResponse) => void\n): Promise<void> {\n  try {\n    logger.debug(\"[RTVI] Fetch action\", actionUrl, action);\n\n    const headers = new Headers({\n      ...Object.fromEntries((params.headers ?? new Headers()).entries()),\n    });\n\n    if (!headers.has(\"Content-Type\")) {\n      headers.set(\"Content-Type\", \"application/json\");\n    }\n    headers.set(\"Cache-Control\", \"no-cache\");\n    headers.set(\"Connection\", \"keep-alive\");\n\n    // Perform the fetch request\n    const response = await fetch(actionUrl, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify({ ...params.requestData, actions: [action] }),\n    });\n\n    // Check the response content type\n    const contentType = response.headers.get(\"content-type\");\n\n    // Handle non-ok response status\n    if (!response.ok) {\n      const errorMessage = await response.text();\n      throw new RTVIError(\n        `Failed to resolve action: ${errorMessage}`,\n        response.status\n      );\n    }\n\n    if (response.body && contentType?.includes(\"text/event-stream\")) {\n      // Parse streamed responses\n      const reader = response.body\n        .pipeThrough(new TextDecoderStream())\n        .getReader();\n\n      let buffer = \"\";\n\n      while (true) {\n        const { value, done } = await reader.read();\n        if (done) break;\n\n        buffer += value;\n\n        let boundary = buffer.indexOf(\"\\n\\n\");\n        while (boundary !== -1) {\n          const message = buffer.slice(0, boundary);\n          buffer = buffer.slice(boundary + 2);\n\n          // Split on the first \":\" to extract the JSON part\n          const lines = message.split(\"\\n\");\n          let encodedData = \"\";\n          for (const line of lines) {\n            const colonIndex = line.indexOf(\":\");\n            if (colonIndex !== -1) {\n              encodedData += line.slice(colonIndex + 1).trim();\n            }\n          }\n\n          try {\n            const jsonData = atob(encodedData);\n            const parsedData = JSON.parse(jsonData);\n            handleResponse(parsedData);\n          } catch (error) {\n            logger.error(\"[RTVI] Failed to parse JSON:\", error);\n            throw error;\n          }\n\n          boundary = buffer.indexOf(\"\\n\\n\");\n        }\n      }\n    } else {\n      // For regular non-streamed responses, parse and handle the data as JSON\n      const data = await response.json();\n      handleResponse(data);\n    }\n  } catch (error) {\n    logger.error(\"[RTVI] Error during fetch:\", error);\n    throw error;\n  }\n}\n/*\n//@TODO: implement abortController when mode changes / bad things happen\nexport async function dispatchAction(\n  this: RTVIClient,\n  action: RTVIActionRequest\n): Promise<RTVIActionResponse> {\n  const promise = new Promise((resolve, reject) => {\n    (async () => {\n      if (this.connected) {\n        return this._messageDispatcher.dispatch(action);\n      } else {\n        const actionUrl = this.constructUrl(\"action\");\n        try {\n          const result = await httpActionGenerator(\n            actionUrl,\n            action,\n            this.params,\n            (response) => {\n              this.handleMessage(response);\n            }\n          );\n          resolve(result);\n        } catch (error) {\n          reject(error);\n        }\n      }\n    })();\n  });\n\n  return promise as Promise<RTVIActionResponse>;\n}\n*/\n","/**\n * Copyright (c) 2024, Daily.\n *\n * SPDX-License-Identifier: BSD-2-Clause\n */\n\nimport cloneDeep from \"clone-deep\";\nimport EventEmitter from \"events\";\nimport TypedEmitter from \"typed-emitter\";\n\nimport packageJson from \"../package.json\";\nimport { getIfTransportInState, transportReady } from \"./decorators\";\nimport * as RTVIErrors from \"./errors\";\nimport { RTVIEvent, RTVIEvents } from \"./events\";\nimport { RTVIClientHelper, RTVIClientHelpers } from \"./helpers\";\nimport { logger, LogLevel } from \"./logger\";\nimport {\n  BotLLMSearchResponseData,\n  BotLLMTextData,\n  BotReadyData,\n  BotTTSTextData,\n  ConfigData,\n  ErrorData,\n  MessageDispatcher,\n  PipecatMetricsData,\n  RTVIActionRequest,\n  RTVIActionRequestData,\n  RTVIActionResponse,\n  RTVIMessage,\n  RTVIMessageType,\n  StorageItemStoredData,\n  TranscriptData,\n} from \"./messages\";\nimport { Participant, Tracks, Transport, TransportState } from \"./transport\";\n\nexport type ConfigOption = {\n  name: string;\n  value: unknown;\n};\n\nexport type RTVIClientConfigOption = {\n  service: string;\n  options: ConfigOption[];\n};\n\nexport type RTVIURLEndpoints = \"connect\" | \"action\";\n\nconst defaultEndpoints: Record<RTVIURLEndpoints, string | null> = {\n  connect: \"/connect\",\n  action: \"/action\",\n};\n\nclass TransportWrapper {\n  private _transport: Transport;\n  private _proxy: Transport;\n\n  constructor(transport: Transport) {\n    this._transport = transport;\n    this._proxy = new Proxy(this._transport, {\n      get: (target, prop, receiver) => {\n        if (typeof target[prop as keyof Transport] === \"function\") {\n          let errMsg;\n          switch (String(prop)) {\n            // Disable methods that modify the lifecycle of the call. These operations\n            // should be performed via the RTVI client in order to keep state in sync.\n            case \"initialize\":\n              errMsg = `Calls to initialize() are disabled and used internally by the RTVIClient`;\n              break;\n            case \"sendReadyMessage\":\n              errMsg = `Calls to sendReadyMessage() are disabled and used internally by the RTVIClient`;\n              break;\n            case \"connect\":\n              errMsg = `Calls to connect() are disabled. Please use RTVIClient.connect()`;\n              break;\n            case \"disconnect\":\n              errMsg = `Calls to disconnect() are disabled. Please use RTVIClient.disconnect()`;\n              break;\n          }\n          if (errMsg) {\n            return () => {\n              throw new Error(errMsg);\n            };\n          }\n          // Forward other method calls\n          return (...args: any[]) => {\n            return (target[prop as keyof Transport] as Function)(...args);\n          };\n        }\n        // Forward property access\n        return Reflect.get(target, prop, receiver);\n      },\n    });\n  }\n\n  get proxy(): Transport {\n    return this._proxy;\n  }\n}\n\nexport type RTVIClientParams = {\n  baseUrl?: string | null;\n} & Partial<{\n  headers?: Headers;\n  endpoints: Partial<Record<RTVIURLEndpoints, string | null>>;\n  requestData?: object;\n  config?: RTVIClientConfigOption[];\n}> & {\n    [key: string]: unknown;\n  };\n\nexport interface RTVIClientOptions {\n  /**\n   * Parameters passed as JSON stringified body params to all endpoints (e.g. connect)\n   */\n  params: RTVIClientParams;\n\n  /**\n   * Transport class for media streaming\n   */\n  transport: Transport;\n\n  /**\n   * Optional callback methods for RTVI events\n   */\n  callbacks?: RTVIEventCallbacks;\n\n  /**\n   * Handshake timeout\n   *\n   * How long should the client wait for the bot ready event (when authenticating / requesting an agent)\n   * Defaults to no timeout (undefined)\n   */\n  timeout?: number;\n\n  /**\n   * Enable user mic input\n   *\n   * Default to true\n   */\n  enableMic?: boolean;\n\n  /**\n   * Enable user cam input\n   *\n   * Default to false\n   */\n  enableCam?: boolean;\n\n  /**\n   * Custom start method handler for retrieving auth bundle for transport\n   * @param baseUrl\n   * @param params\n   * @param timeout\n   * @param abortController\n   * @returns Promise<void>\n   */\n  customConnectHandler?: (\n    params: RTVIClientParams,\n    timeout: ReturnType<typeof setTimeout> | undefined,\n    abortController: AbortController\n  ) => Promise<void>;\n}\n\nexport type RTVIEventCallbacks = Partial<{\n  onGenericMessage: (data: unknown) => void;\n  onMessageError: (message: RTVIMessage) => void;\n  onError: (message: RTVIMessage) => void;\n  onConnected: () => void;\n  onDisconnected: () => void;\n  onTransportStateChanged: (state: TransportState) => void;\n  onConfig: (config: RTVIClientConfigOption[]) => void;\n  onConfigDescribe: (configDescription: unknown) => void;\n  onActionsAvailable: (actions: unknown) => void;\n  onBotConnected: (participant: Participant) => void;\n  onBotReady: (botReadyData: BotReadyData) => void;\n  onBotDisconnected: (participant: Participant) => void;\n  onParticipantJoined: (participant: Participant) => void;\n  onParticipantLeft: (participant: Participant) => void;\n  onMetrics: (data: PipecatMetricsData) => void;\n\n  onAvailableCamsUpdated: (cams: MediaDeviceInfo[]) => void;\n  onAvailableMicsUpdated: (mics: MediaDeviceInfo[]) => void;\n  onAvailableSpeakersUpdated: (speakers: MediaDeviceInfo[]) => void;\n  onCamUpdated: (cam: MediaDeviceInfo) => void;\n  onMicUpdated: (mic: MediaDeviceInfo) => void;\n  onSpeakerUpdated: (speaker: MediaDeviceInfo) => void;\n  onTrackStarted: (track: MediaStreamTrack, participant?: Participant) => void;\n  onTrackStopped: (track: MediaStreamTrack, participant?: Participant) => void;\n  onScreenTrackStarted: (\n    track: MediaStreamTrack,\n    participant?: Participant\n  ) => void;\n  onScreenTrackStopped: (\n    track: MediaStreamTrack,\n    participant?: Participant\n  ) => void;\n  onScreenShareError: (errorMessage: string) => void;\n  onLocalAudioLevel: (level: number) => void;\n  onRemoteAudioLevel: (level: number, participant: Participant) => void;\n\n  onBotStartedSpeaking: () => void;\n  onBotStoppedSpeaking: () => void;\n  onUserStartedSpeaking: () => void;\n  onUserStoppedSpeaking: () => void;\n  onUserTranscript: (data: TranscriptData) => void;\n  onBotTranscript: (data: BotLLMTextData) => void;\n\n  onBotLlmText: (data: BotLLMTextData) => void;\n  onBotLlmStarted: () => void;\n  onBotLlmStopped: () => void;\n  onBotTtsText: (data: BotTTSTextData) => void;\n  onBotTtsStarted: () => void;\n  onBotTtsStopped: () => void;\n  onBotLlmSearchResponse: (data: BotLLMSearchResponseData) => void;\n\n  onStorageItemStored: (data: StorageItemStoredData) => void;\n\n  onServerMessage: (data: any) => void;\n}>;\n\nabstract class RTVIEventEmitter extends (EventEmitter as unknown as new () => TypedEmitter<RTVIEvents>) {}\n\nexport class RTVIClient extends RTVIEventEmitter {\n  public params: RTVIClientParams;\n  protected _options: RTVIClientOptions;\n  private _abortController: AbortController | undefined;\n  private _handshakeTimeout: ReturnType<typeof setTimeout> | undefined;\n  private _helpers: RTVIClientHelpers;\n  private _startResolve: ((value: unknown) => void) | undefined;\n  protected _transport: Transport;\n  protected _transportWrapper: TransportWrapper;\n  protected declare _messageDispatcher: MessageDispatcher;\n\n  constructor(options: RTVIClientOptions) {\n    super();\n\n    this.params = {\n      ...options.params,\n      endpoints: {\n        ...defaultEndpoints,\n        ...(options.params.endpoints ?? {}),\n      },\n    };\n\n    this._helpers = {};\n    this._transport = options.transport;\n    this._transportWrapper = new TransportWrapper(this._transport);\n\n    // Wrap transport callbacks with event triggers\n    // This allows for either functional callbacks or .on / .off event listeners\n    const wrappedCallbacks: RTVIEventCallbacks = {\n      ...options.callbacks,\n      onMessageError: (message: RTVIMessage) => {\n        options?.callbacks?.onMessageError?.(message);\n        this.emit(RTVIEvent.MessageError, message);\n      },\n      onError: (message: RTVIMessage) => {\n        options?.callbacks?.onError?.(message);\n        try {\n          this.emit(RTVIEvent.Error, message);\n        } catch (e) {\n          logger.debug(\"Could not emit error\", message);\n        }\n        const data = message.data as ErrorData;\n        if (data?.fatal) {\n          logger.error(\"Fatal error reported. Disconnecting...\");\n          this.disconnect();\n        }\n      },\n      onConnected: () => {\n        options?.callbacks?.onConnected?.();\n        this.emit(RTVIEvent.Connected);\n      },\n      onDisconnected: () => {\n        options?.callbacks?.onDisconnected?.();\n        this.emit(RTVIEvent.Disconnected);\n      },\n      onTransportStateChanged: (state: TransportState) => {\n        options?.callbacks?.onTransportStateChanged?.(state);\n        this.emit(RTVIEvent.TransportStateChanged, state);\n      },\n      onConfig: (config: RTVIClientConfigOption[]) => {\n        options?.callbacks?.onConfig?.(config);\n        this.emit(RTVIEvent.Config, config);\n      },\n      onConfigDescribe: (configDescription: unknown) => {\n        options?.callbacks?.onConfigDescribe?.(configDescription);\n        this.emit(RTVIEvent.ConfigDescribe, configDescription);\n      },\n      onActionsAvailable: (actionsAvailable: unknown) => {\n        options?.callbacks?.onActionsAvailable?.(actionsAvailable);\n        this.emit(RTVIEvent.ActionsAvailable, actionsAvailable);\n      },\n      onParticipantJoined: (p) => {\n        options?.callbacks?.onParticipantJoined?.(p);\n        this.emit(RTVIEvent.ParticipantConnected, p);\n      },\n      onParticipantLeft: (p) => {\n        options?.callbacks?.onParticipantLeft?.(p);\n        this.emit(RTVIEvent.ParticipantLeft, p);\n      },\n      onTrackStarted: (track, p) => {\n        options?.callbacks?.onTrackStarted?.(track, p);\n        this.emit(RTVIEvent.TrackStarted, track, p);\n      },\n      onTrackStopped: (track, p) => {\n        options?.callbacks?.onTrackStopped?.(track, p);\n        this.emit(RTVIEvent.TrackStopped, track, p);\n      },\n      onScreenTrackStarted: (track, p) => {\n        options?.callbacks?.onScreenTrackStarted?.(track, p);\n        this.emit(RTVIEvent.ScreenTrackStarted, track, p);\n      },\n      onScreenTrackStopped: (track, p) => {\n        options?.callbacks?.onScreenTrackStopped?.(track, p);\n        this.emit(RTVIEvent.ScreenTrackStopped, track, p);\n      },\n      onScreenShareError: (errorMessage) => {\n        options?.callbacks?.onScreenShareError?.(errorMessage);\n        this.emit(RTVIEvent.ScreenShareError, errorMessage);\n      },\n      onAvailableCamsUpdated: (cams) => {\n        options?.callbacks?.onAvailableCamsUpdated?.(cams);\n        this.emit(RTVIEvent.AvailableCamsUpdated, cams);\n      },\n      onAvailableMicsUpdated: (mics) => {\n        options?.callbacks?.onAvailableMicsUpdated?.(mics);\n        this.emit(RTVIEvent.AvailableMicsUpdated, mics);\n      },\n      onAvailableSpeakersUpdated: (speakers) => {\n        options?.callbacks?.onAvailableSpeakersUpdated?.(speakers);\n        this.emit(RTVIEvent.AvailableSpeakersUpdated, speakers);\n      },\n      onCamUpdated: (cam) => {\n        options?.callbacks?.onCamUpdated?.(cam);\n        this.emit(RTVIEvent.CamUpdated, cam);\n      },\n      onMicUpdated: (mic) => {\n        options?.callbacks?.onMicUpdated?.(mic);\n        this.emit(RTVIEvent.MicUpdated, mic);\n      },\n      onSpeakerUpdated: (speaker) => {\n        options?.callbacks?.onSpeakerUpdated?.(speaker);\n        this.emit(RTVIEvent.SpeakerUpdated, speaker);\n      },\n      onBotConnected: (p) => {\n        options?.callbacks?.onBotConnected?.(p);\n        this.emit(RTVIEvent.BotConnected, p);\n      },\n      onBotReady: (botReadyData: BotReadyData) => {\n        options?.callbacks?.onBotReady?.(botReadyData);\n        this.emit(RTVIEvent.BotReady, botReadyData);\n      },\n      onBotDisconnected: (p) => {\n        options?.callbacks?.onBotDisconnected?.(p);\n        this.emit(RTVIEvent.BotDisconnected, p);\n      },\n      onBotStartedSpeaking: () => {\n        options?.callbacks?.onBotStartedSpeaking?.();\n        this.emit(RTVIEvent.BotStartedSpeaking);\n      },\n      onBotStoppedSpeaking: () => {\n        options?.callbacks?.onBotStoppedSpeaking?.();\n        this.emit(RTVIEvent.BotStoppedSpeaking);\n      },\n      onRemoteAudioLevel: (level, p) => {\n        options?.callbacks?.onRemoteAudioLevel?.(level, p);\n        this.emit(RTVIEvent.RemoteAudioLevel, level, p);\n      },\n      onUserStartedSpeaking: () => {\n        options?.callbacks?.onUserStartedSpeaking?.();\n        this.emit(RTVIEvent.UserStartedSpeaking);\n      },\n      onUserStoppedSpeaking: () => {\n        options?.callbacks?.onUserStoppedSpeaking?.();\n        this.emit(RTVIEvent.UserStoppedSpeaking);\n      },\n      onLocalAudioLevel: (level) => {\n        options?.callbacks?.onLocalAudioLevel?.(level);\n        this.emit(RTVIEvent.LocalAudioLevel, level);\n      },\n      onUserTranscript: (data) => {\n        options?.callbacks?.onUserTranscript?.(data);\n        this.emit(RTVIEvent.UserTranscript, data);\n      },\n      onBotTranscript: (text) => {\n        options?.callbacks?.onBotTranscript?.(text);\n        this.emit(RTVIEvent.BotTranscript, text);\n      },\n      onBotLlmText: (text) => {\n        options?.callbacks?.onBotLlmText?.(text);\n        this.emit(RTVIEvent.BotLlmText, text);\n      },\n      onBotLlmStarted: () => {\n        options?.callbacks?.onBotLlmStarted?.();\n        this.emit(RTVIEvent.BotLlmStarted);\n      },\n      onBotLlmStopped: () => {\n        options?.callbacks?.onBotLlmStopped?.();\n        this.emit(RTVIEvent.BotLlmStopped);\n      },\n      onBotTtsText: (text) => {\n        options?.callbacks?.onBotTtsText?.(text);\n        this.emit(RTVIEvent.BotTtsText, text);\n      },\n      onBotTtsStarted: () => {\n        options?.callbacks?.onBotTtsStarted?.();\n        this.emit(RTVIEvent.BotTtsStarted);\n      },\n      onBotTtsStopped: () => {\n        options?.callbacks?.onBotTtsStopped?.();\n        this.emit(RTVIEvent.BotTtsStopped);\n      },\n      onStorageItemStored: (data) => {\n        options?.callbacks?.onStorageItemStored?.(data);\n        this.emit(RTVIEvent.StorageItemStored, data);\n      },\n    };\n\n    // Update options to reference wrapped callbacks and config defaults\n    this._options = {\n      ...options,\n      callbacks: wrappedCallbacks,\n      enableMic: options.enableMic ?? true,\n      enableCam: options.enableCam ?? false,\n    };\n\n    // Instantiate the transport class and bind message handler\n    this._initialize();\n\n    // Get package version number\n    logger.debug(\"[RTVI Client] Initialized\", this.version);\n  }\n\n  public constructUrl(endpoint: RTVIURLEndpoints): string {\n    if (!this.params.baseUrl) {\n      throw new RTVIErrors.RTVIError(\n        \"Base URL not set. Please set rtviClient.params.baseUrl\"\n      );\n    }\n    const baseUrl = this.params.baseUrl.replace(/\\/+$/, \"\");\n    return baseUrl + (this.params.endpoints?.[endpoint] ?? \"\");\n  }\n\n  public setLogLevel(level: LogLevel) {\n    logger.setLevel(level);\n  }\n\n  // ------ Transport methods\n\n  /**\n   * Initialize local media devices\n   */\n  public async initDevices() {\n    logger.debug(\"[RTVI Client] Initializing devices...\");\n    await this._transport.initDevices();\n  }\n\n  /**\n   * Connect the voice client session with chosen transport\n   * Call async (await) to handle errors\n   */\n  public async connect(): Promise<unknown> {\n    if (\n      [\"authenticating\", \"connecting\", \"connected\", \"ready\"].includes(\n        this._transport.state\n      )\n    ) {\n      throw new RTVIErrors.RTVIError(\n        \"Voice client has already been started. Please call disconnect() before starting again.\"\n      );\n    }\n\n    this._abortController = new AbortController();\n\n    // Establish transport session and await bot ready signal\n    return new Promise((resolve, reject) => {\n      (async () => {\n        this._startResolve = resolve;\n\n        if (this._transport.state === \"disconnected\") {\n          await this._transport.initDevices();\n        }\n\n        this._transport.state = \"authenticating\";\n\n        // Set a timer for the bot to enter a ready state, otherwise abort the attempt\n        if (this._options.timeout) {\n          this._handshakeTimeout = setTimeout(async () => {\n            this._abortController?.abort();\n            await this.disconnect();\n            this._transport.state = \"error\";\n            reject(new RTVIErrors.ConnectionTimeoutError());\n          }, this._options.timeout);\n        }\n\n        let authBundle: unknown;\n        const customConnectHandler = this._options.customConnectHandler;\n\n        logger.debug(\"[RTVI Client] Start params\", this.params);\n\n        this.params = {\n          ...this.params,\n          requestData: {\n            ...this.params.requestData,\n            rtvi_client_version: this.version,\n          },\n        };\n\n        if (!this.params.baseUrl && !this.params.endpoints?.connect) {\n          // If baseUrl and endpoints.connect are not set, bypass the handshake and connect directly\n          // This is useful with transports that do not require service side auth, especially in local development\n          // Note: this is not recommended for production use, see [docs link]\n          logger.debug(\n            \"[RTVI Client] Connecting directly (skipping handshake / auth)...\"\n          );\n          clearTimeout(this._handshakeTimeout);\n        } else {\n          const connectUrl = this.constructUrl(\"connect\");\n\n          logger.debug(\"[RTVI Client] Connecting...\", connectUrl);\n          logger.debug(\"[RTVI Client] Start params\", this.params);\n\n          try {\n            if (customConnectHandler) {\n              authBundle = await customConnectHandler(\n                this.params,\n                this._handshakeTimeout,\n                this._abortController!\n              );\n            } else {\n              authBundle = await fetch(connectUrl, {\n                method: \"POST\",\n                mode: \"cors\",\n                headers: new Headers({\n                  \"Content-Type\": \"application/json\",\n                  ...Object.fromEntries(\n                    (this.params.headers ?? new Headers()).entries()\n                  ),\n                }),\n                body: JSON.stringify({\n                  config: this.params.config,\n                  ...(this.params.services\n                    ? { services: this.params.services }\n                    : {}), // @deprecated - pass services through request data\n                  ...this.params.requestData,\n                }),\n                signal: this._abortController?.signal,\n              }).then((res) => {\n                clearTimeout(this._handshakeTimeout);\n\n                if (res.ok) {\n                  return res.json();\n                }\n\n                return Promise.reject(res);\n              });\n            }\n          } catch (e) {\n            clearTimeout(this._handshakeTimeout);\n            // Handle errors if the request was not aborted\n            if (this._abortController?.signal.aborted) {\n              return;\n            }\n            this._transport.state = \"error\";\n            if (e instanceof Response) {\n              const errorResp = await e.json();\n              reject(\n                new RTVIErrors.StartBotError(\n                  errorResp.info ?? errorResp.detail ?? e.statusText,\n                  e.status\n                )\n              );\n            } else {\n              reject(new RTVIErrors.StartBotError());\n            }\n            return;\n          }\n\n          logger.debug(\"[RTVI Client] Auth bundle received\", authBundle);\n        }\n        try {\n          await this._transport.connect(\n            authBundle,\n            this._abortController as AbortController\n          );\n          await this._transport.sendReadyMessage();\n        } catch (e) {\n          clearTimeout(this._handshakeTimeout);\n          this.disconnect();\n          reject(e);\n          return;\n        }\n      })();\n    });\n  }\n\n  /**\n   * Disconnect the voice client from the transport\n   * Reset / reinitialize transport and abort any pending requests\n   */\n  public async disconnect(): Promise<void> {\n    if (this._abortController) {\n      this._abortController.abort();\n    }\n\n    clearTimeout(this._handshakeTimeout);\n\n    await this._transport.disconnect();\n\n    this._messageDispatcher = new MessageDispatcher(this);\n  }\n\n  private _initialize() {\n    this._transport.initialize(this._options, this.handleMessage.bind(this));\n\n    // Create a new message dispatch queue for async message handling\n    this._messageDispatcher = new MessageDispatcher(this);\n  }\n\n  /**\n   * Get the current state of the transport\n   */\n  public get connected(): boolean {\n    return [\"connected\", \"ready\"].includes(this._transport.state);\n  }\n\n  public get transport(): Transport {\n    return this._transportWrapper.proxy;\n  }\n\n  public get state(): TransportState {\n    return this._transport.state;\n  }\n\n  public get version(): string {\n    return packageJson.version;\n  }\n\n  // ------ Device methods\n\n  public async getAllMics(): Promise<MediaDeviceInfo[]> {\n    return await this._transport.getAllMics();\n  }\n\n  public async getAllCams(): Promise<MediaDeviceInfo[]> {\n    return await this._transport.getAllCams();\n  }\n\n  public async getAllSpeakers(): Promise<MediaDeviceInfo[]> {\n    return await this._transport.getAllSpeakers();\n  }\n\n  public get selectedMic() {\n    return this._transport.selectedMic;\n  }\n\n  public get selectedCam() {\n    return this._transport.selectedCam;\n  }\n\n  public get selectedSpeaker() {\n    return this._transport.selectedSpeaker;\n  }\n\n  public updateMic(micId: string) {\n    this._transport.updateMic(micId);\n  }\n\n  public updateCam(camId: string) {\n    this._transport.updateCam(camId);\n  }\n\n  public updateSpeaker(speakerId: string) {\n    this._transport.updateSpeaker(speakerId);\n  }\n\n  public enableMic(enable: boolean) {\n    this._transport.enableMic(enable);\n  }\n\n  public get isMicEnabled(): boolean {\n    return this._transport.isMicEnabled;\n  }\n\n  public enableCam(enable: boolean) {\n    this._transport.enableCam(enable);\n  }\n\n  public get isCamEnabled(): boolean {\n    return this._transport.isCamEnabled;\n  }\n\n  public tracks(): Tracks {\n    return this._transport.tracks();\n  }\n\n  public enableScreenShare(enable: boolean) {\n    return this._transport.enableScreenShare(enable);\n  }\n\n  public get isSharingScreen(): boolean {\n    return this._transport.isSharingScreen;\n  }\n\n  // ------ Config methods\n\n  /**\n   * Request the bot to send the current configuration\n   * @returns Promise<RTVIClientConfigOption[]> - Promise that resolves with the bot's configuration\n   */\n  @transportReady\n  public async getConfig(): Promise<RTVIClientConfigOption[]> {\n    const configMsg = await this._messageDispatcher.dispatch(\n      RTVIMessage.getBotConfig()\n    );\n    return (configMsg.data as ConfigData).config as RTVIClientConfigOption[];\n  }\n\n  /**\n   * Update pipeline and services\n   * @param config - RTVIClientConfigOption[] partial object with the new configuration\n   * @param interrupt - boolean flag to interrupt the current pipeline, or wait until the next turn\n   * @returns Promise<RTVIMessage> - Promise that resolves with the updated configuration\n   */\n  @transportReady\n  public async updateConfig(\n    config: RTVIClientConfigOption[],\n    interrupt: boolean = false\n  ): Promise<RTVIMessage> {\n    logger.debug(\"[RTVI Client] Updating config\", config);\n    // Only send the partial config if the bot is ready to prevent\n    // potential racing conditions whilst pipeline is instantiating\n    return this._messageDispatcher.dispatch(\n      RTVIMessage.updateConfig(config, interrupt)\n    );\n  }\n\n  /**\n   * Request bot describe the current configuration options\n   * @returns Promise<unknown> - Promise that resolves with the bot's configuration description\n   */\n  @transportReady\n  public async describeConfig(): Promise<unknown> {\n    return this._messageDispatcher.dispatch(RTVIMessage.describeConfig());\n  }\n\n  /**\n   * Returns configuration options for specified service key\n   * @param serviceKey - Service name to get options for (e.g. \"llm\")\n   * @param config? - Optional RTVIClientConfigOption[] to query (vs. using remote config)\n   * @returns RTVIClientConfigOption | undefined - Configuration options array for the service with specified key or undefined\n   */\n  public async getServiceOptionsFromConfig(\n    serviceKey: string,\n    config?: RTVIClientConfigOption[]\n  ): Promise<RTVIClientConfigOption | undefined> {\n    if (!config && this.state !== \"ready\") {\n      throw new RTVIErrors.BotNotReadyError(\n        \"getServiceOptionsFromConfig called without config array before bot is ready\"\n      );\n    }\n\n    return Promise.resolve().then(async () => {\n      // Check if we have registered service with name service\n      if (!serviceKey) {\n        logger.debug(\"Target service name is required\");\n        return undefined;\n      }\n\n      const passedConfig: RTVIClientConfigOption[] =\n        config ?? (await this.getConfig());\n\n      // Find matching service name in the config and update the messages\n      const configServiceKey = passedConfig.find(\n        (config: RTVIClientConfigOption) => config.service === serviceKey\n      );\n\n      if (!configServiceKey) {\n        logger.debug(\n          \"No service with name \" + serviceKey + \" not found in config\"\n        );\n        return undefined;\n      }\n\n      // Return a new object, as to not mutate existing state\n      return configServiceKey;\n    });\n  }\n\n  /**\n   * Returns configuration option value (unknown) for specified service key and option name\n   * @param serviceKey - Service name to get options for (e.g. \"llm\")\n   * @optional option Name of option return from the config (e.g. \"model\")\n   * @returns Promise<unknown | undefined> - Service configuration option value or undefined\n   */\n  public async getServiceOptionValueFromConfig(\n    serviceKey: string,\n    option: string,\n    config?: RTVIClientConfigOption[]\n  ): Promise<unknown | undefined> {\n    const configServiceKey: RTVIClientConfigOption | undefined =\n      await this.getServiceOptionsFromConfig(serviceKey, config);\n\n    if (!configServiceKey) {\n      logger.debug(\"Service with name \" + serviceKey + \" not found in config\");\n      return undefined;\n    }\n\n    // Find matching option key in the service config\n    const optionValue: ConfigOption | undefined = configServiceKey.options.find(\n      (o: ConfigOption) => o.name === option\n    );\n\n    return optionValue ? (optionValue as ConfigOption).value : undefined;\n  }\n\n  private _updateOrAddOption(\n    existingOptions: ConfigOption[],\n    newOption: ConfigOption\n  ): ConfigOption[] {\n    const existingOptionIndex = existingOptions.findIndex(\n      (item) => item.name === newOption.name\n    );\n    if (existingOptionIndex !== -1) {\n      // Update existing option\n      return existingOptions.map((item, index) =>\n        index === existingOptionIndex\n          ? { ...item, value: newOption.value }\n          : item\n      );\n    } else {\n      // Add new option\n      return [\n        ...existingOptions,\n        { name: newOption.name, value: newOption.value },\n      ];\n    }\n  }\n\n  /**\n   * Returns config with updated option(s) for specified service key and option name\n   * Note: does not update current config, only returns a new object (call updateConfig to apply changes)\n   * @param serviceKey - Service name to get options for (e.g. \"llm\")\n   * @param option - Service name to get options for (e.g. \"model\")\n   * @param config - Optional RTVIClientConfigOption[] to update (vs. using current config)\n   * @returns Promise<RTVIClientConfigOption[] | undefined> - Configuration options array with updated option(s) or undefined\n   */\n  public async setServiceOptionInConfig(\n    serviceKey: string,\n    option: ConfigOption | ConfigOption[],\n    config?: RTVIClientConfigOption[]\n  ): Promise<RTVIClientConfigOption[] | undefined> {\n    const newConfig: RTVIClientConfigOption[] = cloneDeep(\n      config ?? (await this.getConfig())\n    );\n\n    const serviceOptions = await this.getServiceOptionsFromConfig(\n      serviceKey,\n      newConfig\n    );\n\n    if (!serviceOptions) {\n      logger.debug(\n        \"Service with name '\" + serviceKey + \"' not found in config\"\n      );\n      return newConfig;\n    }\n\n    const optionsArray = Array.isArray(option) ? option : [option];\n\n    for (const opt of optionsArray) {\n      const existingItem = newConfig.find(\n        (item) => item.service === serviceKey\n      );\n      const updatedOptions = existingItem\n        ? this._updateOrAddOption(existingItem.options, opt)\n        : [{ name: opt.name, value: opt.value }];\n\n      if (existingItem) {\n        existingItem.options = updatedOptions;\n      } else {\n        newConfig.push({ service: serviceKey, options: updatedOptions });\n      }\n    }\n\n    return newConfig;\n  }\n\n  /**\n   * Returns config object with updated properties from passed array.\n   * @param configOptions - Array of RTVIClientConfigOption[] to update\n   * @param config? - Optional RTVIClientConfigOption[] to update (vs. using current config)\n   * @returns Promise<RTVIClientConfigOption[]> - Configuration options\n   */\n  public async setConfigOptions(\n    configOptions: RTVIClientConfigOption[],\n    config?: RTVIClientConfigOption[]\n  ): Promise<RTVIClientConfigOption[]> {\n    let accumulator: RTVIClientConfigOption[] = cloneDeep(\n      config ?? (await this.getConfig())\n    );\n\n    for (const configOption of configOptions) {\n      accumulator =\n        (await this.setServiceOptionInConfig(\n          configOption.service,\n          configOption.options,\n          accumulator\n        )) || accumulator;\n    }\n    return accumulator;\n  }\n\n  // ------ Actions\n\n  /**\n   * Dispatch an action message to the bot or http single-turn endpoint\n   */\n  public async action(\n    action: RTVIActionRequestData\n  ): Promise<RTVIActionResponse> {\n    return this._messageDispatcher.dispatchAction(\n      new RTVIActionRequest(action),\n      this.handleMessage.bind(this)\n    );\n  }\n\n  /**\n   * Describe available / registered actions the bot has\n   * @returns Promise<unknown> - Promise that resolves with the bot's actions\n   */\n  @transportReady\n  public async describeActions(): Promise<unknown> {\n    return this._messageDispatcher.dispatch(RTVIMessage.describeActions());\n  }\n\n  // ------ Transport methods\n\n  /**\n   * Get the session expiry time for the transport session (if applicable)\n   * @returns number - Expiry time in milliseconds\n   */\n  @getIfTransportInState(\"connected\", \"ready\")\n  public get transportExpiry(): number | undefined {\n    return this._transport.expiry;\n  }\n\n  // ------ Messages\n\n  /**\n   * Directly send a message to the bot via the transport\n   * @param message - RTVIMessage object to send\n   */\n  @transportReady\n  public sendMessage(message: RTVIMessage): void {\n    this._transport.sendMessage(message);\n  }\n\n  /**\n   * Disconnects the bot, but keeps the session alive\n   */\n  @transportReady\n  public disconnectBot(): void {\n    this._transport.sendMessage(\n      new RTVIMessage(RTVIMessageType.DISCONNECT_BOT, {})\n    );\n  }\n\n  protected handleMessage(ev: RTVIMessage): void {\n    logger.debug(\"[RTVI Message]\", ev);\n\n    switch (ev.type) {\n      case RTVIMessageType.BOT_READY:\n        clearTimeout(this._handshakeTimeout);\n        this._startResolve?.(ev.data as BotReadyData);\n        this._options.callbacks?.onBotReady?.(ev.data as BotReadyData);\n        break;\n      case RTVIMessageType.CONFIG_AVAILABLE: {\n        this._messageDispatcher.resolve(ev);\n        this._options.callbacks?.onConfigDescribe?.(ev.data);\n        break;\n      }\n      case RTVIMessageType.CONFIG: {\n        const resp = this._messageDispatcher.resolve(ev);\n        this._options.callbacks?.onConfig?.((resp.data as ConfigData).config);\n        break;\n      }\n      case RTVIMessageType.ACTIONS_AVAILABLE: {\n        this._messageDispatcher.resolve(ev);\n        this._options.callbacks?.onActionsAvailable?.(ev.data);\n        break;\n      }\n      case RTVIMessageType.ACTION_RESPONSE: {\n        this._messageDispatcher.resolve(ev);\n        break;\n      }\n      case RTVIMessageType.ERROR_RESPONSE: {\n        const resp = this._messageDispatcher.reject(ev);\n        this._options.callbacks?.onMessageError?.(resp as RTVIMessage);\n        break;\n      }\n      case RTVIMessageType.ERROR:\n        this._options.callbacks?.onError?.(ev);\n        break;\n      case RTVIMessageType.USER_STARTED_SPEAKING:\n        this._options.callbacks?.onUserStartedSpeaking?.();\n        break;\n      case RTVIMessageType.USER_STOPPED_SPEAKING:\n        this._options.callbacks?.onUserStoppedSpeaking?.();\n        break;\n      case RTVIMessageType.BOT_STARTED_SPEAKING:\n        this._options.callbacks?.onBotStartedSpeaking?.();\n        break;\n      case RTVIMessageType.BOT_STOPPED_SPEAKING:\n        this._options.callbacks?.onBotStoppedSpeaking?.();\n        break;\n      case RTVIMessageType.USER_TRANSCRIPTION: {\n        const TranscriptData = ev.data as TranscriptData;\n        this._options.callbacks?.onUserTranscript?.(TranscriptData);\n        break;\n      }\n      case RTVIMessageType.BOT_TRANSCRIPTION: {\n        this._options.callbacks?.onBotTranscript?.(ev.data as BotLLMTextData);\n        break;\n      }\n      case RTVIMessageType.BOT_LLM_TEXT:\n        this._options.callbacks?.onBotLlmText?.(ev.data as BotLLMTextData);\n        break;\n      case RTVIMessageType.BOT_LLM_STARTED:\n        this._options.callbacks?.onBotLlmStarted?.();\n        break;\n      case RTVIMessageType.BOT_LLM_STOPPED:\n        this._options.callbacks?.onBotLlmStopped?.();\n        break;\n      case RTVIMessageType.BOT_TTS_TEXT:\n        this._options.callbacks?.onBotTtsText?.(ev.data as BotTTSTextData);\n        break;\n      case RTVIMessageType.BOT_TTS_STARTED:\n        this._options.callbacks?.onBotTtsStarted?.();\n        break;\n      case RTVIMessageType.BOT_TTS_STOPPED:\n        this._options.callbacks?.onBotTtsStopped?.();\n        break;\n      case RTVIMessageType.BOT_LLM_SEARCH_RESPONSE:\n        this._options.callbacks?.onBotLlmSearchResponse?.(\n          ev.data as BotLLMSearchResponseData\n        );\n        this.emit(\n          RTVIEvent.BotLlmSearchResponse,\n          ev.data as BotLLMSearchResponseData\n        );\n        break;\n      case RTVIMessageType.METRICS:\n        this.emit(RTVIEvent.Metrics, ev.data as PipecatMetricsData);\n        this._options.callbacks?.onMetrics?.(ev.data as PipecatMetricsData);\n        break;\n      case RTVIMessageType.STORAGE_ITEM_STORED:\n        this._options.callbacks?.onStorageItemStored?.(\n          ev.data as StorageItemStoredData\n        );\n        break;\n      case RTVIMessageType.SERVER_MESSAGE: {\n        this._options.callbacks?.onServerMessage?.(ev.data);\n        this.emit(RTVIEvent.ServerMessage, ev.data);\n        break;\n      }\n      default: {\n        let match: boolean = false;\n        // Pass message to registered helpers\n        for (const helper of Object.values(\n          this._helpers\n        ) as RTVIClientHelper[]) {\n          if (helper.getMessageTypes().includes(ev.type)) {\n            match = true;\n            helper.handleMessage(ev);\n          }\n        }\n        if (!match) {\n          this._options.callbacks?.onGenericMessage?.(ev.data);\n        }\n      }\n    }\n  }\n\n  // ------ Helpers\n\n  /**\n   * Register a new helper to the client\n   * This (optionally) provides a way to reference helpers directly\n   * from the client and use the event dispatcher\n   * @param service - Target service for this helper\n   * @param helper - Helper instance\n   * @returns RTVIClientHelper - Registered helper instance\n   */\n  public registerHelper(\n    service: string,\n    helper: RTVIClientHelper\n  ): RTVIClientHelper {\n    if (this._helpers[service]) {\n      throw new Error(`Helper with name '${service}' already registered`);\n    }\n\n    // Check helper is instance of RTVIClientHelper\n    if (!(helper instanceof RTVIClientHelper)) {\n      throw new Error(`Helper must be an instance of RTVIClientHelper`);\n    }\n\n    helper.service = service;\n    helper.client = this;\n\n    this._helpers[service] = helper;\n\n    return this._helpers[service];\n  }\n\n  public getHelper<T extends RTVIClientHelper>(service: string): T | undefined {\n    const helper = this._helpers[service];\n    if (!helper) {\n      logger.debug(`Helper targeting service '${service}' not found`);\n      return undefined;\n    }\n    return helper as T;\n  }\n\n  public unregisterHelper(service: string) {\n    if (!this._helpers[service]) {\n      return;\n    }\n    delete this._helpers[service];\n  }\n}\n","{\n  \"name\": \"@pipecat-ai/client-js\",\n  \"version\": \"0.3.4\",\n  \"license\": \"BSD-2-Clause\",\n  \"main\": \"dist/index.js\",\n  \"module\": \"dist/index.module.js\",\n  \"types\": \"dist/index.d.ts\",\n  \"source\": \"src/index.ts\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/pipecat-ai/pipecat-client-web.git\"\n  },\n  \"files\": [\n    \"dist\",\n    \"package.json\",\n    \"README.md\"\n  ],\n  \"scripts\": {\n    \"build\": \"jest --silent && parcel build --no-cache\",\n    \"dev\": \"parcel watch\",\n    \"lint\": \"eslint src/ --report-unused-disable-directives --max-warnings 0\",\n    \"test\": \"jest\"\n  },\n  \"jest\": {\n    \"preset\": \"ts-jest\",\n    \"testEnvironment\": \"node\"\n  },\n  \"devDependencies\": {\n    \"@jest/globals\": \"^29.7.0\",\n    \"@types/clone-deep\": \"^4.0.4\",\n    \"@types/jest\": \"^29.5.12\",\n    \"@types/uuid\": \"^10.0.0\",\n    \"eslint\": \"^9.11.1\",\n    \"eslint-config-prettier\": \"^9.1.0\",\n    \"eslint-plugin-simple-import-sort\": \"^12.1.1\",\n    \"jest\": \"^29.7.0\",\n    \"ts-jest\": \"^29.2.5\"\n  },\n  \"dependencies\": {\n    \"@types/events\": \"^3.0.3\",\n    \"clone-deep\": \"^4.0.1\",\n    \"events\": \"^3.3.0\",\n    \"typed-emitter\": \"^2.1.0\",\n    \"uuid\": \"^10.0.0\"\n  }\n}\n","/**\n * Copyright (c) 2024, Daily.\n *\n * SPDX-License-Identifier: BSD-2-Clause\n */\n\nimport { RTVIClient } from \".\";\nimport { BotNotReadyError } from \"./errors\";\n\nexport function transportReady<T extends RTVIClient>(\n  _target: T,\n  propertyKey: string | symbol,\n  descriptor: PropertyDescriptor\n): PropertyDescriptor | void {\n  const originalMethod = descriptor.value;\n\n  descriptor.value = function (this: T, ...args: unknown[]) {\n    if (this.state === \"ready\") {\n      return originalMethod.apply(this, args);\n    } else {\n      throw new BotNotReadyError(\n        `Attempt to call ${propertyKey.toString()} when transport not in ready state. Await connect() first.`\n      );\n    }\n  };\n\n  return descriptor;\n}\nexport function transportInState<T extends RTVIClient>(states: string[]) {\n  return function (\n    _target: T,\n    propertyKey: string | symbol,\n    descriptor: PropertyDescriptor\n  ): PropertyDescriptor | void {\n    const originalMethod = descriptor.value;\n\n    descriptor.get = function (this: T, ...args: unknown[]) {\n      if (states.includes(this.state)) {\n        return originalMethod.apply(this, args);\n      } else {\n        throw new BotNotReadyError(\n          `Attempt to call ${propertyKey.toString()} when transport not in ${states}.`\n        );\n      }\n    };\n\n    return descriptor;\n  };\n}\n\nexport function getIfTransportInState<T extends RTVIClient>(\n  ...states: string[]\n) {\n  states = [\"ready\", ...states];\n\n  return function (\n    _target: T,\n    propertyKey: string | symbol,\n    descriptor: PropertyDescriptor\n  ): PropertyDescriptor | void {\n    const originalGetter = descriptor.get;\n\n    descriptor.get = function (this: T) {\n      if (states.includes(this.state)) {\n        return originalGetter?.apply(this);\n      } else {\n        throw new BotNotReadyError(\n          `Attempt to call ${propertyKey.toString()} when transport not in ${states}. Await connect() first.`\n        );\n      }\n    };\n\n    return descriptor;\n  };\n}\n","/**\n * Copyright (c) 2024, Daily.\n *\n * SPDX-License-Identifier: BSD-2-Clause\n */\n\nexport class RTVIError extends Error {\n  readonly status: number | undefined;\n\n  constructor(message?: string, status?: number | undefined) {\n    super(message);\n    this.status = status;\n  }\n}\n\nexport class ConnectionTimeoutError extends RTVIError {\n  constructor(message?: string | undefined) {\n    super(\n      message ??\n        \"Bot did not enter ready state within the specified timeout period.\"\n    );\n  }\n}\n\nexport class StartBotError extends RTVIError {\n  readonly error: string = \"invalid-request-error\";\n  constructor(message?: string | undefined, status?: number) {\n    super(\n      message ?? `Failed to connect / invalid auth bundle from base url`,\n      status ?? 500\n    );\n  }\n}\n\nexport class TransportStartError extends RTVIError {\n  constructor(message?: string | undefined) {\n    super(message ?? \"Unable to connect to transport\");\n  }\n}\n\nexport class BotNotReadyError extends RTVIError {\n  constructor(message?: string | undefined) {\n    super(\n      message ??\n        \"Attempt to call action on transport when not in 'ready' state.\"\n    );\n  }\n}\n\nexport class ConfigUpdateError extends RTVIError {\n  override readonly status = 400;\n  constructor(message?: string | undefined) {\n    super(message ?? \"Unable to update configuration\");\n  }\n}\n\nexport class ActionEndpointNotSetError extends RTVIError {\n  constructor(message?: string | undefined) {\n    super(message ?? \"Action endpoint is not set\");\n  }\n}\n","/**\n * Copyright (c) 2024, Daily.\n *\n * SPDX-License-Identifier: BSD-2-Clause\n */\n\nimport { RTVIClientConfigOption } from \".\";\nimport { LLMFunctionCallData } from \"./helpers/llm\";\nimport {\n  BotLLMTextData,\n  BotLLMSearchResponseData,\n  BotReadyData,\n  BotTTSTextData,\n  PipecatMetricsData,\n  RTVIMessage,\n  StorageItemStoredData,\n  TranscriptData,\n} from \"./messages\";\nimport { Participant, TransportState } from \"./transport\";\n\nexport enum RTVIEvent {\n  MessageError = \"messageError\",\n  Error = \"error\",\n\n  Connected = \"connected\",\n  Disconnected = \"disconnected\",\n  TransportStateChanged = \"transportStateChanged\",\n\n  Config = \"config\",\n  ConfigDescribe = \"configDescribe\",\n  ActionsAvailable = \"actionsAvailable\",\n\n  ParticipantConnected = \"participantConnected\",\n  ParticipantLeft = \"participantLeft\",\n  TrackStarted = \"trackStarted\",\n  TrackStopped = \"trackStopped\",\n  ScreenTrackStarted = \"screenTrackStarted\",\n  ScreenTrackStopped = \"screenTrackStopped\",\n  ScreenShareError = \"screenShareError\",\n\n  AvailableCamsUpdated = \"availableCamsUpdated\",\n  AvailableMicsUpdated = \"availableMicsUpdated\",\n  AvailableSpeakersUpdated = \"availableSpeakersUpdated\",\n  CamUpdated = \"camUpdated\",\n  MicUpdated = \"micUpdated\",\n  SpeakerUpdated = \"speakerUpdated\",\n\n  BotConnected = \"botConnected\",\n  BotReady = \"botReady\",\n  BotDisconnected = \"botDisconnected\",\n  BotStartedSpeaking = \"botStartedSpeaking\",\n  BotStoppedSpeaking = \"botStoppedSpeaking\",\n  RemoteAudioLevel = \"remoteAudioLevel\",\n\n  UserStartedSpeaking = \"userStartedSpeaking\",\n  UserStoppedSpeaking = \"userStoppedSpeaking\",\n  LocalAudioLevel = \"localAudioLevel\",\n\n  Metrics = \"metrics\",\n\n  UserTranscript = \"userTranscript\",\n  BotTranscript = \"botTranscript\",\n\n  BotLlmText = \"botLlmText\",\n  BotLlmStarted = \"botLlmStarted\",\n  BotLlmStopped = \"botLlmStopped\",\n\n  BotTtsText = \"botTtsText\",\n  BotTtsStarted = \"botTtsStarted\",\n  BotTtsStopped = \"botTtsStopped\",\n\n  LLMFunctionCall = \"llmFunctionCall\",\n  LLMFunctionCallStart = \"llmFunctionCallStart\",\n  LLMJsonCompletion = \"llmJsonCompletion\",\n\n  StorageItemStored = \"storageItemStored\",\n\n  BotLlmSearchResponse = \"botLlmSearchResponse\",\n  ServerMessage = \"serverMessage\",\n}\n\nexport type RTVIEvents = Partial<{\n  connected: () => void;\n  disconnected: () => void;\n  transportStateChanged: (state: TransportState) => void;\n\n  config: (config: RTVIClientConfigOption[]) => void;\n  configUpdated: (config: RTVIClientConfigOption[]) => void;\n  configDescribe: (configDescription: unknown) => void;\n  actionsAvailable: (actions: unknown) => void;\n\n  participantConnected: (participant: Participant) => void;\n  participantLeft: (participant: Participant) => void;\n  trackStarted: (track: MediaStreamTrack, participant?: Participant) => void;\n  trackStopped: (track: MediaStreamTrack, participant?: Participant) => void;\n  screenTrackStarted: (track: MediaStreamTrack, p?: Participant) => void;\n  screenTrackStopped: (track: MediaStreamTrack, p?: Participant) => void;\n  screenShareError: (errorMessage: string) => void;\n\n  availableCamsUpdated: (cams: MediaDeviceInfo[]) => void;\n  availableMicsUpdated: (mics: MediaDeviceInfo[]) => void;\n  availableSpeakersUpdated: (speakers: MediaDeviceInfo[]) => void;\n  camUpdated: (cam: MediaDeviceInfo) => void;\n  micUpdated: (mic: MediaDeviceInfo) => void;\n  speakerUpdated: (speaker: MediaDeviceInfo) => void;\n\n  botReady: (botData: BotReadyData) => void;\n  botConnected: (participant: Participant) => void;\n  botDisconnected: (participant: Participant) => void;\n  botStartedSpeaking: () => void;\n  botStoppedSpeaking: () => void;\n  remoteAudioLevel: (level: number, p: Participant) => void;\n\n  userStartedSpeaking: () => void;\n  userStoppedSpeaking: () => void;\n  localAudioLevel: (level: number) => void;\n\n  metrics: (data: PipecatMetricsData) => void;\n\n  userTranscript: (data: TranscriptData) => void;\n  botTranscript: (data: BotLLMTextData) => void;\n\n  botLlmText: (data: BotLLMTextData) => void;\n  botLlmStarted: () => void;\n  botLlmStopped: () => void;\n\n  botTtsText: (data: BotTTSTextData) => void;\n  botTtsStarted: () => void;\n  botTtsStopped: () => void;\n\n  error: (message: RTVIMessage) => void;\n  messageError: (message: RTVIMessage) => void;\n\n  llmFunctionCall: (func: LLMFunctionCallData) => void;\n  llmFunctionCallStart: (functionName: string) => void;\n  llmJsonCompletion: (data: string) => void;\n\n  storageItemStored: (data: StorageItemStoredData) => void;\n\n  botLlmSearchResponse: (data: BotLLMSearchResponseData) => void;\n  serverMessage: (data: any) => void;\n}>;\n\nexport type RTVIEventHandler<E extends RTVIEvent> = E extends keyof RTVIEvents\n  ? RTVIEvents[E]\n  : never;\n","/**\n * Copyright (c) 2024, Daily.\n *\n * SPDX-License-Identifier: BSD-2-Clause\n */\n\nimport { RTVIClient } from \"../client\";\nimport { RTVIMessage } from \"../messages\";\n\nexport type RTVIClientHelpers = Partial<Record<string, RTVIClientHelper>>;\n\nexport type RTVIClientHelperCallbacks = Partial<object>;\n\nexport interface RTVIClientHelperOptions {\n  /**\n   * Callback methods for events / messages\n   */\n  callbacks?: RTVIClientHelperCallbacks;\n}\n\nexport abstract class RTVIClientHelper {\n  protected _options: RTVIClientHelperOptions;\n  protected declare _client: RTVIClient;\n  protected declare _service: string;\n\n  constructor(options: RTVIClientHelperOptions) {\n    this._options = options;\n  }\n\n  public abstract handleMessage(ev: RTVIMessage): void;\n  public abstract getMessageTypes(): string[];\n  public set client(client: RTVIClient) {\n    this._client = client;\n  }\n  public set service(service: string) {\n    this._service = service;\n  }\n}\n","/**\n * Copyright (c) 2024, Daily.\n *\n * SPDX-License-Identifier: BSD-2-Clause\n */\n\nexport enum LogLevel {\n  NONE = 0,\n  ERROR = 1,\n  WARN = 2,\n  INFO = 3,\n  DEBUG = 4,\n}\n\nclass Logger {\n  private static instance: Logger;\n  private level: LogLevel = LogLevel.DEBUG;\n\n  private constructor() {}\n\n  static getInstance(): Logger {\n    if (!Logger.instance) {\n      Logger.instance = new Logger();\n    }\n    return Logger.instance;\n  }\n\n  setLevel(level: LogLevel) {\n    this.level = level;\n  }\n\n  debug(...args: unknown[]) {\n    if (this.level >= LogLevel.DEBUG) {\n      console.debug(...args);\n    }\n  }\n\n  info(...args: unknown[]) {\n    if (this.level >= LogLevel.INFO) {\n      console.info(...args);\n    }\n  }\n\n  warn(...args: unknown[]) {\n    if (this.level >= LogLevel.WARN) {\n      console.warn(...args);\n    }\n  }\n\n  error(...args: unknown[]) {\n    if (this.level >= LogLevel.ERROR) {\n      console.error(...args);\n    }\n  }\n}\n\nexport const logger = Logger.getInstance();\n\nexport type ILogger = Logger;\n","/**\n * Copyright (c) 2024, Daily.\n *\n * SPDX-License-Identifier: BSD-2-Clause\n */\n\nimport { v4 as uuidv4 } from \"uuid\";\n\nimport { httpActionGenerator } from \"./actions\";\nimport { RTVIClient, RTVIClientConfigOption } from \"./client\";\nimport { ActionEndpointNotSetError } from \"./errors\";\nimport { logger } from \"./logger\";\n\nexport const RTVI_MESSAGE_LABEL = \"rtvi-ai\";\n\nexport enum RTVIMessageType {\n  // Outbound\n  CLIENT_READY = \"client-ready\",\n  UPDATE_CONFIG = \"update-config\",\n  GET_CONFIG = \"get-config\",\n  DESCRIBE_CONFIG = \"describe-config\",\n  DESCRIBE_ACTIONS = \"describe-actions\",\n  DISCONNECT_BOT = \"disconnect-bot\",\n  ACTION = \"action\",\n\n  // Inbound\n  BOT_READY = \"bot-ready\", // Bot is connected and ready to receive messages\n  ERROR = \"error\", // Bot initialization error\n  ERROR_RESPONSE = \"error-response\", // Error response from the bot in response to an action\n  CONFIG = \"config\", // Bot configuration\n  CONFIG_AVAILABLE = \"config-available\", // Configuration options available on the bot\n  CONFIG_ERROR = \"config-error\", // Configuration options have changed failed\n  ACTIONS_AVAILABLE = \"actions-available\", // Actions available on the bot\n  ACTION_RESPONSE = \"action-response\", // Action response from the bot\n  METRICS = \"metrics\", // RTVI reporting metrics\n  USER_TRANSCRIPTION = \"user-transcription\", // Local user speech to text transcription (partials and finals)\n  BOT_TRANSCRIPTION = \"bot-transcription\", // Bot full text transcription (sentence aggregated)\n  USER_STARTED_SPEAKING = \"user-started-speaking\", // User started speaking\n  USER_STOPPED_SPEAKING = \"user-stopped-speaking\", // User stopped speaking\n  BOT_STARTED_SPEAKING = \"bot-started-speaking\", // Bot started speaking\n  BOT_STOPPED_SPEAKING = \"bot-stopped-speaking\", // Bot stopped speaking\n  // Service-specific\n  USER_LLM_TEXT = \"user-llm-text\", // Aggregated user input text which is sent to LLM\n  BOT_LLM_TEXT = \"bot-llm-text\", // Streamed token returned by the LLM\n  BOT_LLM_STARTED = \"bot-llm-started\", // Bot LLM inference starts\n  BOT_LLM_STOPPED = \"bot-llm-stopped\", // Bot LLM inference stops\n  BOT_TTS_TEXT = \"bot-tts-text\", // Bot TTS text output (streamed word as it is spoken)\n  BOT_TTS_STARTED = \"bot-tts-started\", // Bot TTS response starts\n  BOT_TTS_STOPPED = \"bot-tts-stopped\", // Bot TTS response stops\n  BOT_LLM_SEARCH_RESPONSE = \"bot-llm-search-response\", // Bot LLM search response\n  // Storage\n  STORAGE_ITEM_STORED = \"storage-item-stored\", // Item was stored to configured storage, if applicable\n  // Server-to-client messages\n  SERVER_MESSAGE = \"server-message\",\n}\n\n// ----- Message Data Types\n\nexport type ConfigData = {\n  config: RTVIClientConfigOption[];\n};\n\nexport type BotReadyData = {\n  config: RTVIClientConfigOption[];\n  version: string;\n};\n\nexport type ErrorData = {\n  message: string;\n  fatal: boolean;\n};\n\nexport type PipecatMetricData = {\n  processor: string;\n  value: number;\n};\n\nexport type PipecatMetricsData = {\n  processing?: PipecatMetricData[];\n  ttfb?: PipecatMetricData[];\n  characters?: PipecatMetricData[];\n};\n\nexport type TranscriptData = {\n  text: string;\n  final: boolean;\n  timestamp: string;\n  user_id: string;\n};\n\nexport type BotLLMTextData = {\n  text: string;\n};\n\nexport type BotTTSTextData = {\n  text: string;\n};\n\nexport type StorageItemStoredData = {\n  action: string;\n  items: unknown;\n};\n\nexport type LLMSearchResult = {\n  text: string;\n  confidence: number[];\n};\n\nexport type LLMSearchOrigin = {\n  site_uri?: string;\n  site_title?: string;\n  results: LLMSearchResult[];\n};\n\nexport type BotLLMSearchResponseData = {\n  search_result?: string;\n  rendered_content?: string;\n  origins: LLMSearchOrigin[];\n};\n\nexport type ServerMessageData = {\n  data: any;\n};\n\n// ----- Message Classes\n\nexport type RTVIMessageActionResponse = {\n  id: string;\n  label: string;\n  type: string;\n  data: { result: unknown };\n};\n\nexport class RTVIMessage {\n  id: string;\n  label: string = RTVI_MESSAGE_LABEL;\n  type: string;\n  data: unknown;\n\n  constructor(type: string, data: unknown, id?: string) {\n    this.type = type;\n    this.data = data;\n    this.id = id || uuidv4().slice(0, 8);\n  }\n\n  // Outbound message types\n  static clientReady(): RTVIMessage {\n    return new RTVIMessage(RTVIMessageType.CLIENT_READY, {});\n  }\n\n  static updateConfig(\n    config: RTVIClientConfigOption[],\n    interrupt: boolean = false\n  ): RTVIMessage {\n    return new RTVIMessage(RTVIMessageType.UPDATE_CONFIG, {\n      config,\n      interrupt,\n    });\n  }\n\n  static describeConfig(): RTVIMessage {\n    return new RTVIMessage(RTVIMessageType.DESCRIBE_CONFIG, {});\n  }\n\n  static getBotConfig(): RTVIMessage {\n    return new RTVIMessage(RTVIMessageType.GET_CONFIG, {});\n  }\n\n  static describeActions(): RTVIMessage {\n    return new RTVIMessage(RTVIMessageType.DESCRIBE_ACTIONS, {});\n  }\n\n  static disconnectBot(): RTVIMessage {\n    return new RTVIMessage(RTVIMessageType.DISCONNECT_BOT, {});\n  }\n\n  static error(message: string, fatal = false): RTVIMessage {\n    return new RTVIMessage(RTVIMessageType.ERROR, { message, fatal });\n  }\n}\n\n// ----- Action Types\n\nexport type RTVIActionRequestData = {\n  service: string;\n  action: string;\n  arguments?: { name: string; value: unknown }[];\n};\n\nexport class RTVIActionRequest extends RTVIMessage {\n  constructor(data: RTVIActionRequestData) {\n    super(RTVIMessageType.ACTION, data);\n  }\n}\n\nexport type RTVIActionResponse = {\n  id: string;\n  label: string;\n  type: string;\n  data: { result: unknown };\n};\n\n// ----- Message Dispatcher\n\ninterface QueuedRTVIMessage {\n  message: RTVIMessage;\n  timestamp: number;\n  resolve: (value: unknown) => void;\n  reject: (reason?: unknown) => void;\n}\n\nexport class MessageDispatcher {\n  private _client: RTVIClient;\n  private _gcTime: number;\n  private _queue = new Array<QueuedRTVIMessage>();\n\n  constructor(client: RTVIClient) {\n    this._gcTime = 10000; // How long to wait before resolving the message\n    this._queue = [];\n    this._client = client;\n  }\n\n  public dispatch(message: RTVIMessage): Promise<RTVIMessage> {\n    const promise = new Promise((resolve, reject) => {\n      this._queue.push({\n        message,\n        timestamp: Date.now(),\n        resolve,\n        reject,\n      });\n    });\n\n    logger.debug(\"[MessageDispatcher] dispatch\", message);\n\n    this._client.sendMessage(message);\n\n    this._gc();\n\n    return promise as Promise<RTVIMessage | RTVIMessageActionResponse>;\n  }\n\n  public async dispatchAction(\n    action: RTVIActionRequest,\n    onMessage: (message: RTVIMessage) => void\n  ): Promise<RTVIMessageActionResponse> {\n    const promise = new Promise((resolve, reject) => {\n      this._queue.push({\n        message: action,\n        timestamp: Date.now(),\n        resolve,\n        reject,\n      });\n    });\n\n    logger.debug(\"[MessageDispatcher] action\", action);\n\n    if (this._client.connected) {\n      // Send message to transport when connected\n      this._client.sendMessage(action);\n    } else {\n      if (!this._client.params.endpoints?.action) {\n        logger.error(\n          \"[MessageDispatcher] Action endpoint is required when dispatching action in disconnected state\"\n        );\n        throw new ActionEndpointNotSetError();\n      }\n      const actionUrl = this._client.constructUrl(\"action\");\n\n      try {\n        // Dispatch action via HTTP when disconnected\n        await httpActionGenerator(\n          actionUrl,\n          action,\n          this._client.params,\n          (response: RTVIActionResponse) => {\n            onMessage(response);\n          }\n        );\n        // On HTTP success (resolve), send `action` message (for callbacks)\n      } catch (e) {\n        onMessage(\n          new RTVIMessage(\n            RTVIMessageType.ERROR_RESPONSE,\n            `Action endpoint '${actionUrl}' returned an error response`,\n            action.id\n          )\n        );\n      }\n    }\n\n    this._gc();\n\n    return promise as Promise<RTVIMessageActionResponse>;\n  }\n\n  private _resolveReject(\n    message: RTVIMessage,\n    resolve: boolean = true\n  ): RTVIMessage {\n    const queuedMessage = this._queue.find(\n      (msg) => msg.message.id === message.id\n    );\n\n    if (queuedMessage) {\n      if (resolve) {\n        logger.debug(\"[MessageDispatcher] Resolve\", message);\n        queuedMessage.resolve(\n          message.type === RTVIMessageType.ACTION_RESPONSE\n            ? (message as RTVIMessageActionResponse)\n            : (message as RTVIMessage)\n        );\n      } else {\n        logger.debug(\"[MessageDispatcher] Reject\", message);\n        queuedMessage.reject(message as RTVIMessage);\n      }\n      // Remove message from queue\n      this._queue = this._queue.filter((msg) => msg.message.id !== message.id);\n      logger.debug(\"[MessageDispatcher] Queue\", this._queue);\n    }\n\n    return message;\n  }\n\n  public resolve(message: RTVIMessage): RTVIMessage {\n    return this._resolveReject(message, true);\n  }\n\n  public reject(message: RTVIMessage): RTVIMessage {\n    return this._resolveReject(message, false);\n  }\n\n  private _gc() {\n    this._queue = this._queue.filter((msg) => {\n      return Date.now() - msg.timestamp < this._gcTime;\n    });\n    logger.debug(\"[MessageDispatcher] GC\", this._queue);\n  }\n}\n","/**\n * Copyright (c) 2024, Daily.\n *\n * SPDX-License-Identifier: BSD-2-Clause\n */\n\nimport * as RTVIErrors from \"./../errors\";\nimport { RTVIEvent } from \"./../events\";\nimport {\n  RTVIActionRequestData,\n  RTVIActionResponse,\n  RTVIMessage,\n} from \"./../messages\";\nimport { RTVIClientHelper, RTVIClientHelperOptions } from \".\";\n\n// --- Types\n\nexport type LLMFunctionCallData = {\n  function_name: string;\n  tool_call_id: string;\n  args: unknown;\n  result?: unknown;\n};\n\nexport type LLMContextMessage = {\n  role: string;\n  content: unknown;\n};\n\nexport type LLMContext = Partial<{\n  messages?: LLMContextMessage[];\n  tools?: [];\n}>;\n\nexport type FunctionCallParams = {\n  functionName: string;\n  arguments: unknown;\n};\n\nexport type FunctionCallCallback = (fn: FunctionCallParams) => Promise<unknown>;\n\n// --- Message types\nexport enum LLMMessageType {\n  LLM_FUNCTION_CALL = \"llm-function-call\",\n  LLM_FUNCTION_CALL_START = \"llm-function-call-start\",\n  LLM_FUNCTION_CALL_RESULT = \"llm-function-call-result\",\n  LLM_JSON_COMPLETION = \"llm-json-completion\",\n}\n\nexport enum LLMActionType {\n  APPEND_TO_MESSAGES = \"append_to_messages\",\n  GET_CONTEXT = \"get_context\",\n  SET_CONTEXT = \"set_context\",\n  RUN = \"run\",\n}\n\n// --- Callbacks\nexport type LLMHelperCallbacks = Partial<{\n  onLLMJsonCompletion: (jsonString: string) => void;\n  onLLMFunctionCall: (func: LLMFunctionCallData) => void;\n  onLLMFunctionCallStart: (functionName: string) => void;\n  onLLMMessage: (message: LLMContextMessage) => void;\n}>;\n\n// --- Interface and class\nexport interface LLMHelperOptions extends RTVIClientHelperOptions {\n  callbacks?: LLMHelperCallbacks;\n}\n\nexport class LLMHelper extends RTVIClientHelper {\n  protected declare _options: LLMHelperOptions;\n  private _functionCallCallback: FunctionCallCallback | null;\n\n  constructor(options: LLMHelperOptions) {\n    super(options);\n\n    this._functionCallCallback = null;\n  }\n\n  public getMessageTypes(): string[] {\n    return Object.values(LLMMessageType) as string[];\n  }\n\n  // --- Actions\n\n  /**\n   * Retrieve the bot's current LLM context.\n   * @returns Promise<LLMContext>\n   */\n  public async getContext(): Promise<LLMContext> {\n    if (this._client.state !== \"ready\") {\n      throw new RTVIErrors.BotNotReadyError(\n        \"getContext called while transport not in ready state\"\n      );\n    }\n    const actionResponseMsg: RTVIActionResponse = await this._client.action({\n      service: this._service,\n      action: LLMActionType.GET_CONTEXT,\n    } as RTVIActionRequestData);\n    return actionResponseMsg.data.result as LLMContext;\n  }\n\n  /**\n   * Update the bot's LLM context.\n   * If this is called while the transport is not in the ready state, the local context will be updated\n   * @param context LLMContext - The new context\n   * @param interrupt boolean - Whether to interrupt the bot, or wait until it has finished speaking\n   * @returns Promise<boolean>\n   */\n\n  public async setContext(\n    context: LLMContext,\n    interrupt: boolean = false\n  ): Promise<boolean> {\n    if (this._client.state !== \"ready\") {\n      throw new RTVIErrors.BotNotReadyError(\n        \"setContext called while transport not in ready state\"\n      );\n    }\n\n    const actionResponse: RTVIActionResponse = (await this._client.action({\n      service: this._service,\n      action: LLMActionType.SET_CONTEXT,\n      arguments: [\n        {\n          name: \"messages\",\n          value: context.messages,\n        },\n        {\n          name: \"interrupt\",\n          value: interrupt,\n        },\n      ],\n    } as RTVIActionRequestData)) as RTVIActionResponse;\n\n    return !!actionResponse.data.result;\n  }\n\n  /**\n   * Append a new message to the LLM context.\n   * If this is called while the transport is not in the ready state, the local context will be updated\n   * @param context LLMContextMessage\n   * @param runImmediately boolean - wait until pipeline is idle before running\n   * @returns boolean\n   */\n\n  public async appendToMessages(\n    message: LLMContextMessage,\n    runImmediately: boolean = false\n  ): Promise<boolean> {\n    if (this._client.state !== \"ready\") {\n      throw new RTVIErrors.BotNotReadyError(\n        \"setContext called while transport not in ready state\"\n      );\n    }\n\n    const actionResponse = (await this._client.action({\n      service: this._service,\n      action: LLMActionType.APPEND_TO_MESSAGES,\n      arguments: [\n        {\n          name: \"messages\",\n          value: [message],\n        },\n        {\n          name: \"run_immediately\",\n          value: runImmediately,\n        },\n      ],\n    } as RTVIActionRequestData)) as RTVIActionResponse;\n    return !!actionResponse.data.result;\n  }\n\n  /**\n   * Run the bot's current LLM context.\n   * Useful when appending messages to the context without runImmediately set to true.\n   * Will do nothing if the bot is not in the ready state.\n   * @param interrupt boolean - Whether to interrupt the bot, or wait until it has finished speaking\n   * @returns Promise<unknown>\n   */\n  public async run(interrupt: boolean = false): Promise<unknown> {\n    if (this._client.state !== \"ready\") {\n      return;\n    }\n\n    return this._client.action({\n      service: this._service,\n      action: LLMActionType.RUN,\n      arguments: [\n        {\n          name: \"interrupt\",\n          value: interrupt,\n        },\n      ],\n    } as RTVIActionRequestData);\n  }\n\n  // --- Handlers\n\n  /**\n   * If the LLM wants to call a function, RTVI will invoke the callback defined\n   * here. Whatever the callback returns will be sent to the LLM as the function result.\n   * @param callback\n   * @returns void\n   */\n  public handleFunctionCall(callback: FunctionCallCallback): void {\n    this._functionCallCallback = callback;\n  }\n\n  public handleMessage(ev: RTVIMessage): void {\n    switch (ev.type) {\n      case LLMMessageType.LLM_JSON_COMPLETION:\n        this._options.callbacks?.onLLMJsonCompletion?.(ev.data as string);\n        this._client.emit(RTVIEvent.LLMJsonCompletion, ev.data as string);\n        break;\n      case LLMMessageType.LLM_FUNCTION_CALL: {\n        const d = ev.data as LLMFunctionCallData;\n        this._options.callbacks?.onLLMFunctionCall?.(\n          ev.data as LLMFunctionCallData\n        );\n        this._client.emit(\n          RTVIEvent.LLMFunctionCall,\n          ev.data as LLMFunctionCallData\n        );\n        if (this._functionCallCallback) {\n          const fn = {\n            functionName: d.function_name,\n            arguments: d.args,\n          };\n          if (this._client.state === \"ready\") {\n            this._functionCallCallback(fn).then((result) => {\n              this._client.sendMessage(\n                new RTVIMessage(LLMMessageType.LLM_FUNCTION_CALL_RESULT, {\n                  function_name: d.function_name,\n                  tool_call_id: d.tool_call_id,\n                  arguments: d.args,\n                  result,\n                })\n              );\n            });\n          } else {\n            throw new RTVIErrors.BotNotReadyError(\n              \"Attempted to send a function call result from bot while transport not in ready state\"\n            );\n          }\n        }\n        break;\n      }\n      case LLMMessageType.LLM_FUNCTION_CALL_START: {\n        const e = ev.data as LLMFunctionCallData;\n        this._options.callbacks?.onLLMFunctionCallStart?.(\n          e.function_name as string\n        );\n        this._client.emit(RTVIEvent.LLMFunctionCallStart, e.function_name);\n        break;\n      }\n    }\n  }\n}\n","/**\n * Copyright (c) 2024, Daily.\n *\n * SPDX-License-Identifier: BSD-2-Clause\n */\n\nimport { RTVIClientOptions, RTVIEventCallbacks } from \"./client\";\nimport { RTVIMessage } from \"./messages\";\n\nexport type TransportState =\n  | \"disconnected\"\n  | \"initializing\"\n  | \"initialized\"\n  | \"authenticating\"\n  | \"connecting\"\n  | \"connected\"\n  | \"ready\"\n  | \"disconnecting\"\n  | \"error\";\n\nexport type Participant = {\n  id: string;\n  name: string;\n  local: boolean;\n};\n\nexport type Tracks = {\n  local: {\n    audio?: MediaStreamTrack;\n    video?: MediaStreamTrack;\n    screenAudio?: MediaStreamTrack;\n    screenVideo?: MediaStreamTrack;\n  };\n  bot?: {\n    audio?: MediaStreamTrack;\n    screenAudio?: undefined;\n    screenVideo?: undefined;\n    video?: MediaStreamTrack;\n  };\n};\n\nexport abstract class Transport {\n  protected declare _options: RTVIClientOptions;\n  protected declare _onMessage: (ev: RTVIMessage) => void;\n  protected declare _callbacks: RTVIEventCallbacks;\n  protected _state: TransportState = \"disconnected\";\n  protected _expiry?: number = undefined;\n\n  constructor() {}\n\n  abstract initialize(\n    options: RTVIClientOptions,\n    messageHandler: (ev: RTVIMessage) => void\n  ): void;\n\n  abstract initDevices(): Promise<void>;\n\n  abstract connect(\n    authBundle: unknown,\n    abortController: AbortController\n  ): Promise<void>;\n  abstract disconnect(): Promise<void>;\n  abstract sendReadyMessage(): void;\n\n  abstract getAllMics(): Promise<MediaDeviceInfo[]>;\n  abstract getAllCams(): Promise<MediaDeviceInfo[]>;\n  abstract getAllSpeakers(): Promise<MediaDeviceInfo[]>;\n\n  abstract updateMic(micId: string): void;\n  abstract updateCam(camId: string): void;\n  abstract updateSpeaker(speakerId: string): void;\n\n  abstract get selectedMic(): MediaDeviceInfo | Record<string, never>;\n  abstract get selectedCam(): MediaDeviceInfo | Record<string, never>;\n  abstract get selectedSpeaker(): MediaDeviceInfo | Record<string, never>;\n\n  abstract enableMic(enable: boolean): void;\n  abstract enableCam(enable: boolean): void;\n  abstract enableScreenShare(enable: boolean): void;\n  abstract get isCamEnabled(): boolean;\n  abstract get isMicEnabled(): boolean;\n  abstract get isSharingScreen(): boolean;\n\n  abstract sendMessage(message: RTVIMessage): void;\n\n  abstract get state(): TransportState;\n  abstract set state(state: TransportState);\n\n  get expiry(): number | undefined {\n    return this._expiry;\n  }\n\n  abstract tracks(): Tracks;\n}\n"],"names":[],"version":3,"file":"index.js.map"}