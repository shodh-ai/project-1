import $eINDk$clonedeep from "clone-deep";
import $eINDk$events from "events";
import {v4 as $eINDk$v4} from "uuid";


function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}

function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}
/**
 * Copyright (c) 2024, Daily.
 *
 * SPDX-License-Identifier: BSD-2-Clause
 */ var $4bb349f22aee5185$exports = {};

$parcel$export($4bb349f22aee5185$exports, "httpActionGenerator", () => $4bb349f22aee5185$export$8728b60ea57bf43e);
/**
 * Copyright (c) 2024, Daily.
 *
 * SPDX-License-Identifier: BSD-2-Clause
 */ 
async function $4bb349f22aee5185$export$8728b60ea57bf43e(actionUrl, action, params, handleResponse) {
    try {
        (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("[RTVI] Fetch action", actionUrl, action);
        const headers = new Headers({
            ...Object.fromEntries((params.headers ?? new Headers()).entries())
        });
        if (!headers.has("Content-Type")) headers.set("Content-Type", "application/json");
        headers.set("Cache-Control", "no-cache");
        headers.set("Connection", "keep-alive");
        // Perform the fetch request
        const response = await fetch(actionUrl, {
            method: "POST",
            headers: headers,
            body: JSON.stringify({
                ...params.requestData,
                actions: [
                    action
                ]
            })
        });
        // Check the response content type
        const contentType = response.headers.get("content-type");
        // Handle non-ok response status
        if (!response.ok) {
            const errorMessage = await response.text();
            throw new (0, $8ead7b33b8402751$export$59b4786f333aac02)(`Failed to resolve action: ${errorMessage}`, response.status);
        }
        if (response.body && contentType?.includes("text/event-stream")) {
            // Parse streamed responses
            const reader = response.body.pipeThrough(new TextDecoderStream()).getReader();
            let buffer = "";
            while(true){
                const { value: value, done: done } = await reader.read();
                if (done) break;
                buffer += value;
                let boundary = buffer.indexOf("\n\n");
                while(boundary !== -1){
                    const message = buffer.slice(0, boundary);
                    buffer = buffer.slice(boundary + 2);
                    // Split on the first ":" to extract the JSON part
                    const lines = message.split("\n");
                    let encodedData = "";
                    for (const line of lines){
                        const colonIndex = line.indexOf(":");
                        if (colonIndex !== -1) encodedData += line.slice(colonIndex + 1).trim();
                    }
                    try {
                        const jsonData = atob(encodedData);
                        const parsedData = JSON.parse(jsonData);
                        handleResponse(parsedData);
                    } catch (error) {
                        (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).error("[RTVI] Failed to parse JSON:", error);
                        throw error;
                    }
                    boundary = buffer.indexOf("\n\n");
                }
            }
        } else {
            // For regular non-streamed responses, parse and handle the data as JSON
            const data = await response.json();
            handleResponse(data);
        }
    } catch (error) {
        (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).error("[RTVI] Error during fetch:", error);
        throw error;
    }
} /*
//@TODO: implement abortController when mode changes / bad things happen
export async function dispatchAction(
  this: RTVIClient,
  action: RTVIActionRequest
): Promise<RTVIActionResponse> {
  const promise = new Promise((resolve, reject) => {
    (async () => {
      if (this.connected) {
        return this._messageDispatcher.dispatch(action);
      } else {
        const actionUrl = this.constructUrl("action");
        try {
          const result = await httpActionGenerator(
            actionUrl,
            action,
            this.params,
            (response) => {
              this.handleMessage(response);
            }
          );
          resolve(result);
        } catch (error) {
          reject(error);
        }
      }
    })();
  });

  return promise as Promise<RTVIActionResponse>;
}
*/ 


var $a7c324a73303ad55$exports = {};

$parcel$export($a7c324a73303ad55$exports, "RTVIClient", () => $a7c324a73303ad55$export$fa42a01c1d60f4a1);
/**
 * Copyright (c) 2024, Daily.
 *
 * SPDX-License-Identifier: BSD-2-Clause
 */ 

var $e3bad9cc25e327f7$exports = {};
$e3bad9cc25e327f7$exports = JSON.parse("{\"name\":\"@pipecat-ai/client-js\",\"version\":\"0.3.4\",\"license\":\"BSD-2-Clause\",\"main\":\"dist/index.js\",\"module\":\"dist/index.module.js\",\"types\":\"dist/index.d.ts\",\"source\":\"src/index.ts\",\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/pipecat-ai/pipecat-client-web.git\"},\"files\":[\"dist\",\"package.json\",\"README.md\"],\"scripts\":{\"build\":\"jest --silent && parcel build --no-cache\",\"dev\":\"parcel watch\",\"lint\":\"eslint src/ --report-unused-disable-directives --max-warnings 0\",\"test\":\"jest\"},\"jest\":{\"preset\":\"ts-jest\",\"testEnvironment\":\"node\"},\"devDependencies\":{\"@jest/globals\":\"^29.7.0\",\"@types/clone-deep\":\"^4.0.4\",\"@types/jest\":\"^29.5.12\",\"@types/uuid\":\"^10.0.0\",\"eslint\":\"^9.11.1\",\"eslint-config-prettier\":\"^9.1.0\",\"eslint-plugin-simple-import-sort\":\"^12.1.1\",\"jest\":\"^29.7.0\",\"ts-jest\":\"^29.2.5\"},\"dependencies\":{\"@types/events\":\"^3.0.3\",\"clone-deep\":\"^4.0.1\",\"events\":\"^3.3.0\",\"typed-emitter\":\"^2.1.0\",\"uuid\":\"^10.0.0\"}}");


/**
 * Copyright (c) 2024, Daily.
 *
 * SPDX-License-Identifier: BSD-2-Clause
 */ var $8ead7b33b8402751$exports = {};

$parcel$export($8ead7b33b8402751$exports, "RTVIError", () => $8ead7b33b8402751$export$59b4786f333aac02);
$parcel$export($8ead7b33b8402751$exports, "ConnectionTimeoutError", () => $8ead7b33b8402751$export$c67992fa684a81a6);
$parcel$export($8ead7b33b8402751$exports, "StartBotError", () => $8ead7b33b8402751$export$e7544ab812238a61);
$parcel$export($8ead7b33b8402751$exports, "TransportStartError", () => $8ead7b33b8402751$export$e0624a511a2c4e9);
$parcel$export($8ead7b33b8402751$exports, "BotNotReadyError", () => $8ead7b33b8402751$export$885fb96b850e8fbb);
$parcel$export($8ead7b33b8402751$exports, "ConfigUpdateError", () => $8ead7b33b8402751$export$4eda4fd287fbbca5);
$parcel$export($8ead7b33b8402751$exports, "ActionEndpointNotSetError", () => $8ead7b33b8402751$export$be839f0100cd3132);
/**
 * Copyright (c) 2024, Daily.
 *
 * SPDX-License-Identifier: BSD-2-Clause
 */ class $8ead7b33b8402751$export$59b4786f333aac02 extends Error {
    constructor(message, status){
        super(message);
        this.status = status;
    }
}
class $8ead7b33b8402751$export$c67992fa684a81a6 extends $8ead7b33b8402751$export$59b4786f333aac02 {
    constructor(message){
        super(message ?? "Bot did not enter ready state within the specified timeout period.");
    }
}
class $8ead7b33b8402751$export$e7544ab812238a61 extends $8ead7b33b8402751$export$59b4786f333aac02 {
    constructor(message, status){
        super(message ?? `Failed to connect / invalid auth bundle from base url`, status ?? 500);
        this.error = "invalid-request-error";
    }
}
class $8ead7b33b8402751$export$e0624a511a2c4e9 extends $8ead7b33b8402751$export$59b4786f333aac02 {
    constructor(message){
        super(message ?? "Unable to connect to transport");
    }
}
class $8ead7b33b8402751$export$885fb96b850e8fbb extends $8ead7b33b8402751$export$59b4786f333aac02 {
    constructor(message){
        super(message ?? "Attempt to call action on transport when not in 'ready' state.");
    }
}
class $8ead7b33b8402751$export$4eda4fd287fbbca5 extends $8ead7b33b8402751$export$59b4786f333aac02 {
    constructor(message){
        super(message ?? "Unable to update configuration");
        this.status = 400;
    }
}
class $8ead7b33b8402751$export$be839f0100cd3132 extends $8ead7b33b8402751$export$59b4786f333aac02 {
    constructor(message){
        super(message ?? "Action endpoint is not set");
    }
}


function $16f019d4d16917df$export$f1586721024c4dab(_target, propertyKey, descriptor) {
    const originalMethod = descriptor.value;
    descriptor.value = function(...args) {
        if (this.state === "ready") return originalMethod.apply(this, args);
        else throw new (0, $8ead7b33b8402751$export$885fb96b850e8fbb)(`Attempt to call ${propertyKey.toString()} when transport not in ready state. Await connect() first.`);
    };
    return descriptor;
}
function $16f019d4d16917df$export$808994d0d8c9acb3(states) {
    return function(_target, propertyKey, descriptor) {
        const originalMethod = descriptor.value;
        descriptor.get = function(...args) {
            if (states.includes(this.state)) return originalMethod.apply(this, args);
            else throw new (0, $8ead7b33b8402751$export$885fb96b850e8fbb)(`Attempt to call ${propertyKey.toString()} when transport not in ${states}.`);
        };
        return descriptor;
    };
}
function $16f019d4d16917df$export$5c35b4fe6fa8c9a6(...states) {
    states = [
        "ready",
        ...states
    ];
    return function(_target, propertyKey, descriptor) {
        const originalGetter = descriptor.get;
        descriptor.get = function() {
            if (states.includes(this.state)) return originalGetter?.apply(this);
            else throw new (0, $8ead7b33b8402751$export$885fb96b850e8fbb)(`Attempt to call ${propertyKey.toString()} when transport not in ${states}. Await connect() first.`);
        };
        return descriptor;
    };
}



var $f9fc0c57b9aaed9c$exports = {};

$parcel$export($f9fc0c57b9aaed9c$exports, "RTVIEvent", () => $f9fc0c57b9aaed9c$export$6b4624d233c61fcb);
/**
 * Copyright (c) 2024, Daily.
 *
 * SPDX-License-Identifier: BSD-2-Clause
 */ var $f9fc0c57b9aaed9c$export$6b4624d233c61fcb;
(function(RTVIEvent) {
    RTVIEvent["MessageError"] = "messageError";
    RTVIEvent["Error"] = "error";
    RTVIEvent["Connected"] = "connected";
    RTVIEvent["Disconnected"] = "disconnected";
    RTVIEvent["TransportStateChanged"] = "transportStateChanged";
    RTVIEvent["Config"] = "config";
    RTVIEvent["ConfigDescribe"] = "configDescribe";
    RTVIEvent["ActionsAvailable"] = "actionsAvailable";
    RTVIEvent["ParticipantConnected"] = "participantConnected";
    RTVIEvent["ParticipantLeft"] = "participantLeft";
    RTVIEvent["TrackStarted"] = "trackStarted";
    RTVIEvent["TrackStopped"] = "trackStopped";
    RTVIEvent["ScreenTrackStarted"] = "screenTrackStarted";
    RTVIEvent["ScreenTrackStopped"] = "screenTrackStopped";
    RTVIEvent["ScreenShareError"] = "screenShareError";
    RTVIEvent["AvailableCamsUpdated"] = "availableCamsUpdated";
    RTVIEvent["AvailableMicsUpdated"] = "availableMicsUpdated";
    RTVIEvent["AvailableSpeakersUpdated"] = "availableSpeakersUpdated";
    RTVIEvent["CamUpdated"] = "camUpdated";
    RTVIEvent["MicUpdated"] = "micUpdated";
    RTVIEvent["SpeakerUpdated"] = "speakerUpdated";
    RTVIEvent["BotConnected"] = "botConnected";
    RTVIEvent["BotReady"] = "botReady";
    RTVIEvent["BotDisconnected"] = "botDisconnected";
    RTVIEvent["BotStartedSpeaking"] = "botStartedSpeaking";
    RTVIEvent["BotStoppedSpeaking"] = "botStoppedSpeaking";
    RTVIEvent["RemoteAudioLevel"] = "remoteAudioLevel";
    RTVIEvent["UserStartedSpeaking"] = "userStartedSpeaking";
    RTVIEvent["UserStoppedSpeaking"] = "userStoppedSpeaking";
    RTVIEvent["LocalAudioLevel"] = "localAudioLevel";
    RTVIEvent["Metrics"] = "metrics";
    RTVIEvent["UserTranscript"] = "userTranscript";
    RTVIEvent["BotTranscript"] = "botTranscript";
    RTVIEvent["BotLlmText"] = "botLlmText";
    RTVIEvent["BotLlmStarted"] = "botLlmStarted";
    RTVIEvent["BotLlmStopped"] = "botLlmStopped";
    RTVIEvent["BotTtsText"] = "botTtsText";
    RTVIEvent["BotTtsStarted"] = "botTtsStarted";
    RTVIEvent["BotTtsStopped"] = "botTtsStopped";
    RTVIEvent["LLMFunctionCall"] = "llmFunctionCall";
    RTVIEvent["LLMFunctionCallStart"] = "llmFunctionCallStart";
    RTVIEvent["LLMJsonCompletion"] = "llmJsonCompletion";
    RTVIEvent["StorageItemStored"] = "storageItemStored";
    RTVIEvent["BotLlmSearchResponse"] = "botLlmSearchResponse";
    RTVIEvent["ServerMessage"] = "serverMessage";
})($f9fc0c57b9aaed9c$export$6b4624d233c61fcb || ($f9fc0c57b9aaed9c$export$6b4624d233c61fcb = {}));


var $7614fb2168c523cc$exports = {};

$parcel$export($7614fb2168c523cc$exports, "RTVIClientHelper", () => $7614fb2168c523cc$export$23bc637255b2a471);
/**
 * Copyright (c) 2024, Daily.
 *
 * SPDX-License-Identifier: BSD-2-Clause
 */ class $7614fb2168c523cc$export$23bc637255b2a471 {
    constructor(options){
        this._options = options;
    }
    set client(client) {
        this._client = client;
    }
    set service(service) {
        this._service = service;
    }
}


var $7afbbd59ebaa42bf$exports = {};

$parcel$export($7afbbd59ebaa42bf$exports, "LogLevel", () => $7afbbd59ebaa42bf$export$243e62d78d3b544d);
$parcel$export($7afbbd59ebaa42bf$exports, "logger", () => $7afbbd59ebaa42bf$export$af88d00dbe7f521);
/**
 * Copyright (c) 2024, Daily.
 *
 * SPDX-License-Identifier: BSD-2-Clause
 */ var $7afbbd59ebaa42bf$export$243e62d78d3b544d;
(function(LogLevel) {
    LogLevel[LogLevel["NONE"] = 0] = "NONE";
    LogLevel[LogLevel["ERROR"] = 1] = "ERROR";
    LogLevel[LogLevel["WARN"] = 2] = "WARN";
    LogLevel[LogLevel["INFO"] = 3] = "INFO";
    LogLevel[LogLevel["DEBUG"] = 4] = "DEBUG";
})($7afbbd59ebaa42bf$export$243e62d78d3b544d || ($7afbbd59ebaa42bf$export$243e62d78d3b544d = {}));
class $7afbbd59ebaa42bf$var$Logger {
    constructor(){
        this.level = $7afbbd59ebaa42bf$export$243e62d78d3b544d.DEBUG;
    }
    static getInstance() {
        if (!$7afbbd59ebaa42bf$var$Logger.instance) $7afbbd59ebaa42bf$var$Logger.instance = new $7afbbd59ebaa42bf$var$Logger();
        return $7afbbd59ebaa42bf$var$Logger.instance;
    }
    setLevel(level) {
        this.level = level;
    }
    debug(...args) {
        if (this.level >= $7afbbd59ebaa42bf$export$243e62d78d3b544d.DEBUG) console.debug(...args);
    }
    info(...args) {
        if (this.level >= $7afbbd59ebaa42bf$export$243e62d78d3b544d.INFO) console.info(...args);
    }
    warn(...args) {
        if (this.level >= $7afbbd59ebaa42bf$export$243e62d78d3b544d.WARN) console.warn(...args);
    }
    error(...args) {
        if (this.level >= $7afbbd59ebaa42bf$export$243e62d78d3b544d.ERROR) console.error(...args);
    }
}
const $7afbbd59ebaa42bf$export$af88d00dbe7f521 = $7afbbd59ebaa42bf$var$Logger.getInstance();


var $b48f893ed1354c1e$exports = {};

$parcel$export($b48f893ed1354c1e$exports, "RTVI_MESSAGE_LABEL", () => $b48f893ed1354c1e$export$882b13c7fda338f5);
$parcel$export($b48f893ed1354c1e$exports, "RTVIMessageType", () => $b48f893ed1354c1e$export$38b3db05cbf0e240);
$parcel$export($b48f893ed1354c1e$exports, "RTVIMessage", () => $b48f893ed1354c1e$export$69aa9ab0334b212);
$parcel$export($b48f893ed1354c1e$exports, "RTVIActionRequest", () => $b48f893ed1354c1e$export$378529d7a8bead8b);
$parcel$export($b48f893ed1354c1e$exports, "MessageDispatcher", () => $b48f893ed1354c1e$export$e9a960646cc432aa);
/**
 * Copyright (c) 2024, Daily.
 *
 * SPDX-License-Identifier: BSD-2-Clause
 */ 



const $b48f893ed1354c1e$export$882b13c7fda338f5 = "rtvi-ai";
var $b48f893ed1354c1e$export$38b3db05cbf0e240;
(function(RTVIMessageType) {
    // Outbound
    RTVIMessageType["CLIENT_READY"] = "client-ready";
    RTVIMessageType["UPDATE_CONFIG"] = "update-config";
    RTVIMessageType["GET_CONFIG"] = "get-config";
    RTVIMessageType["DESCRIBE_CONFIG"] = "describe-config";
    RTVIMessageType["DESCRIBE_ACTIONS"] = "describe-actions";
    RTVIMessageType["DISCONNECT_BOT"] = "disconnect-bot";
    RTVIMessageType["ACTION"] = "action";
    // Inbound
    RTVIMessageType["BOT_READY"] = "bot-ready";
    RTVIMessageType["ERROR"] = "error";
    RTVIMessageType["ERROR_RESPONSE"] = "error-response";
    RTVIMessageType["CONFIG"] = "config";
    RTVIMessageType["CONFIG_AVAILABLE"] = "config-available";
    RTVIMessageType["CONFIG_ERROR"] = "config-error";
    RTVIMessageType["ACTIONS_AVAILABLE"] = "actions-available";
    RTVIMessageType["ACTION_RESPONSE"] = "action-response";
    RTVIMessageType["METRICS"] = "metrics";
    RTVIMessageType["USER_TRANSCRIPTION"] = "user-transcription";
    RTVIMessageType["BOT_TRANSCRIPTION"] = "bot-transcription";
    RTVIMessageType["USER_STARTED_SPEAKING"] = "user-started-speaking";
    RTVIMessageType["USER_STOPPED_SPEAKING"] = "user-stopped-speaking";
    RTVIMessageType["BOT_STARTED_SPEAKING"] = "bot-started-speaking";
    RTVIMessageType["BOT_STOPPED_SPEAKING"] = "bot-stopped-speaking";
    // Service-specific
    RTVIMessageType["USER_LLM_TEXT"] = "user-llm-text";
    RTVIMessageType["BOT_LLM_TEXT"] = "bot-llm-text";
    RTVIMessageType["BOT_LLM_STARTED"] = "bot-llm-started";
    RTVIMessageType["BOT_LLM_STOPPED"] = "bot-llm-stopped";
    RTVIMessageType["BOT_TTS_TEXT"] = "bot-tts-text";
    RTVIMessageType["BOT_TTS_STARTED"] = "bot-tts-started";
    RTVIMessageType["BOT_TTS_STOPPED"] = "bot-tts-stopped";
    RTVIMessageType["BOT_LLM_SEARCH_RESPONSE"] = "bot-llm-search-response";
    // Storage
    RTVIMessageType["STORAGE_ITEM_STORED"] = "storage-item-stored";
    // Server-to-client messages
    RTVIMessageType["SERVER_MESSAGE"] = "server-message";
})($b48f893ed1354c1e$export$38b3db05cbf0e240 || ($b48f893ed1354c1e$export$38b3db05cbf0e240 = {}));
class $b48f893ed1354c1e$export$69aa9ab0334b212 {
    constructor(type, data, id){
        this.label = $b48f893ed1354c1e$export$882b13c7fda338f5;
        this.type = type;
        this.data = data;
        this.id = id || (0, $eINDk$v4)().slice(0, 8);
    }
    // Outbound message types
    static clientReady() {
        return new $b48f893ed1354c1e$export$69aa9ab0334b212($b48f893ed1354c1e$export$38b3db05cbf0e240.CLIENT_READY, {});
    }
    static updateConfig(config, interrupt = false) {
        return new $b48f893ed1354c1e$export$69aa9ab0334b212($b48f893ed1354c1e$export$38b3db05cbf0e240.UPDATE_CONFIG, {
            config: config,
            interrupt: interrupt
        });
    }
    static describeConfig() {
        return new $b48f893ed1354c1e$export$69aa9ab0334b212($b48f893ed1354c1e$export$38b3db05cbf0e240.DESCRIBE_CONFIG, {});
    }
    static getBotConfig() {
        return new $b48f893ed1354c1e$export$69aa9ab0334b212($b48f893ed1354c1e$export$38b3db05cbf0e240.GET_CONFIG, {});
    }
    static describeActions() {
        return new $b48f893ed1354c1e$export$69aa9ab0334b212($b48f893ed1354c1e$export$38b3db05cbf0e240.DESCRIBE_ACTIONS, {});
    }
    static disconnectBot() {
        return new $b48f893ed1354c1e$export$69aa9ab0334b212($b48f893ed1354c1e$export$38b3db05cbf0e240.DISCONNECT_BOT, {});
    }
    static error(message, fatal = false) {
        return new $b48f893ed1354c1e$export$69aa9ab0334b212($b48f893ed1354c1e$export$38b3db05cbf0e240.ERROR, {
            message: message,
            fatal: fatal
        });
    }
}
class $b48f893ed1354c1e$export$378529d7a8bead8b extends $b48f893ed1354c1e$export$69aa9ab0334b212 {
    constructor(data){
        super($b48f893ed1354c1e$export$38b3db05cbf0e240.ACTION, data);
    }
}
class $b48f893ed1354c1e$export$e9a960646cc432aa {
    constructor(client){
        this._queue = new Array();
        this._gcTime = 10000; // How long to wait before resolving the message
        this._queue = [];
        this._client = client;
    }
    dispatch(message) {
        const promise = new Promise((resolve, reject)=>{
            this._queue.push({
                message: message,
                timestamp: Date.now(),
                resolve: resolve,
                reject: reject
            });
        });
        (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("[MessageDispatcher] dispatch", message);
        this._client.sendMessage(message);
        this._gc();
        return promise;
    }
    async dispatchAction(action, onMessage) {
        const promise = new Promise((resolve, reject)=>{
            this._queue.push({
                message: action,
                timestamp: Date.now(),
                resolve: resolve,
                reject: reject
            });
        });
        (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("[MessageDispatcher] action", action);
        if (this._client.connected) // Send message to transport when connected
        this._client.sendMessage(action);
        else {
            if (!this._client.params.endpoints?.action) {
                (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).error("[MessageDispatcher] Action endpoint is required when dispatching action in disconnected state");
                throw new (0, $8ead7b33b8402751$export$be839f0100cd3132)();
            }
            const actionUrl = this._client.constructUrl("action");
            try {
                // Dispatch action via HTTP when disconnected
                await (0, $4bb349f22aee5185$export$8728b60ea57bf43e)(actionUrl, action, this._client.params, (response)=>{
                    onMessage(response);
                });
            // On HTTP success (resolve), send `action` message (for callbacks)
            } catch (e) {
                onMessage(new $b48f893ed1354c1e$export$69aa9ab0334b212($b48f893ed1354c1e$export$38b3db05cbf0e240.ERROR_RESPONSE, `Action endpoint '${actionUrl}' returned an error response`, action.id));
            }
        }
        this._gc();
        return promise;
    }
    _resolveReject(message, resolve = true) {
        const queuedMessage = this._queue.find((msg)=>msg.message.id === message.id);
        if (queuedMessage) {
            if (resolve) {
                (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("[MessageDispatcher] Resolve", message);
                queuedMessage.resolve(message.type === $b48f893ed1354c1e$export$38b3db05cbf0e240.ACTION_RESPONSE ? message : message);
            } else {
                (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("[MessageDispatcher] Reject", message);
                queuedMessage.reject(message);
            }
            // Remove message from queue
            this._queue = this._queue.filter((msg)=>msg.message.id !== message.id);
            (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("[MessageDispatcher] Queue", this._queue);
        }
        return message;
    }
    resolve(message) {
        return this._resolveReject(message, true);
    }
    reject(message) {
        return this._resolveReject(message, false);
    }
    _gc() {
        this._queue = this._queue.filter((msg)=>{
            return Date.now() - msg.timestamp < this._gcTime;
        });
        (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("[MessageDispatcher] GC", this._queue);
    }
}


var $a7c324a73303ad55$var$__decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const $a7c324a73303ad55$var$defaultEndpoints = {
    connect: "/connect",
    action: "/action"
};
class $a7c324a73303ad55$var$TransportWrapper {
    constructor(transport){
        this._transport = transport;
        this._proxy = new Proxy(this._transport, {
            get: (target, prop, receiver)=>{
                if (typeof target[prop] === "function") {
                    let errMsg;
                    switch(String(prop)){
                        // Disable methods that modify the lifecycle of the call. These operations
                        // should be performed via the RTVI client in order to keep state in sync.
                        case "initialize":
                            errMsg = `Calls to initialize() are disabled and used internally by the RTVIClient`;
                            break;
                        case "sendReadyMessage":
                            errMsg = `Calls to sendReadyMessage() are disabled and used internally by the RTVIClient`;
                            break;
                        case "connect":
                            errMsg = `Calls to connect() are disabled. Please use RTVIClient.connect()`;
                            break;
                        case "disconnect":
                            errMsg = `Calls to disconnect() are disabled. Please use RTVIClient.disconnect()`;
                            break;
                    }
                    if (errMsg) return ()=>{
                        throw new Error(errMsg);
                    };
                    // Forward other method calls
                    return (...args)=>{
                        return target[prop](...args);
                    };
                }
                // Forward property access
                return Reflect.get(target, prop, receiver);
            }
        });
    }
    get proxy() {
        return this._proxy;
    }
}
class $a7c324a73303ad55$var$RTVIEventEmitter extends (0, $eINDk$events) {
}
class $a7c324a73303ad55$export$fa42a01c1d60f4a1 extends $a7c324a73303ad55$var$RTVIEventEmitter {
    constructor(options){
        super();
        this.params = {
            ...options.params,
            endpoints: {
                ...$a7c324a73303ad55$var$defaultEndpoints,
                ...options.params.endpoints ?? {}
            }
        };
        this._helpers = {};
        this._transport = options.transport;
        this._transportWrapper = new $a7c324a73303ad55$var$TransportWrapper(this._transport);
        // Wrap transport callbacks with event triggers
        // This allows for either functional callbacks or .on / .off event listeners
        const wrappedCallbacks = {
            ...options.callbacks,
            onMessageError: (message)=>{
                options?.callbacks?.onMessageError?.(message);
                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).MessageError, message);
            },
            onError: (message)=>{
                options?.callbacks?.onError?.(message);
                try {
                    this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).Error, message);
                } catch (e) {
                    (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("Could not emit error", message);
                }
                const data = message.data;
                if (data?.fatal) {
                    (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).error("Fatal error reported. Disconnecting...");
                    this.disconnect();
                }
            },
            onConnected: ()=>{
                options?.callbacks?.onConnected?.();
                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).Connected);
            },
            onDisconnected: ()=>{
                options?.callbacks?.onDisconnected?.();
                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).Disconnected);
            },
            onTransportStateChanged: (state)=>{
                options?.callbacks?.onTransportStateChanged?.(state);
                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).TransportStateChanged, state);
            },
            onConfig: (config)=>{
                options?.callbacks?.onConfig?.(config);
                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).Config, config);
            },
            onConfigDescribe: (configDescription)=>{
                options?.callbacks?.onConfigDescribe?.(configDescription);
                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).ConfigDescribe, configDescription);
            },
            onActionsAvailable: (actionsAvailable)=>{
                options?.callbacks?.onActionsAvailable?.(actionsAvailable);
                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).ActionsAvailable, actionsAvailable);
            },
            onParticipantJoined: (p)=>{
                options?.callbacks?.onParticipantJoined?.(p);
                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).ParticipantConnected, p);
            },
            onParticipantLeft: (p)=>{
                options?.callbacks?.onParticipantLeft?.(p);
                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).ParticipantLeft, p);
            },
            onTrackStarted: (track, p)=>{
                options?.callbacks?.onTrackStarted?.(track, p);
                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).TrackStarted, track, p);
            },
            onTrackStopped: (track, p)=>{
                options?.callbacks?.onTrackStopped?.(track, p);
                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).TrackStopped, track, p);
            },
            onScreenTrackStarted: (track, p)=>{
                options?.callbacks?.onScreenTrackStarted?.(track, p);
                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).ScreenTrackStarted, track, p);
            },
            onScreenTrackStopped: (track, p)=>{
                options?.callbacks?.onScreenTrackStopped?.(track, p);
                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).ScreenTrackStopped, track, p);
            },
            onScreenShareError: (errorMessage)=>{
                options?.callbacks?.onScreenShareError?.(errorMessage);
                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).ScreenShareError, errorMessage);
            },
            onAvailableCamsUpdated: (cams)=>{
                options?.callbacks?.onAvailableCamsUpdated?.(cams);
                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).AvailableCamsUpdated, cams);
            },
            onAvailableMicsUpdated: (mics)=>{
                options?.callbacks?.onAvailableMicsUpdated?.(mics);
                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).AvailableMicsUpdated, mics);
            },
            onAvailableSpeakersUpdated: (speakers)=>{
                options?.callbacks?.onAvailableSpeakersUpdated?.(speakers);
                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).AvailableSpeakersUpdated, speakers);
            },
            onCamUpdated: (cam)=>{
                options?.callbacks?.onCamUpdated?.(cam);
                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).CamUpdated, cam);
            },
            onMicUpdated: (mic)=>{
                options?.callbacks?.onMicUpdated?.(mic);
                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).MicUpdated, mic);
            },
            onSpeakerUpdated: (speaker)=>{
                options?.callbacks?.onSpeakerUpdated?.(speaker);
                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).SpeakerUpdated, speaker);
            },
            onBotConnected: (p)=>{
                options?.callbacks?.onBotConnected?.(p);
                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).BotConnected, p);
            },
            onBotReady: (botReadyData)=>{
                options?.callbacks?.onBotReady?.(botReadyData);
                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).BotReady, botReadyData);
            },
            onBotDisconnected: (p)=>{
                options?.callbacks?.onBotDisconnected?.(p);
                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).BotDisconnected, p);
            },
            onBotStartedSpeaking: ()=>{
                options?.callbacks?.onBotStartedSpeaking?.();
                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).BotStartedSpeaking);
            },
            onBotStoppedSpeaking: ()=>{
                options?.callbacks?.onBotStoppedSpeaking?.();
                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).BotStoppedSpeaking);
            },
            onRemoteAudioLevel: (level, p)=>{
                options?.callbacks?.onRemoteAudioLevel?.(level, p);
                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).RemoteAudioLevel, level, p);
            },
            onUserStartedSpeaking: ()=>{
                options?.callbacks?.onUserStartedSpeaking?.();
                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).UserStartedSpeaking);
            },
            onUserStoppedSpeaking: ()=>{
                options?.callbacks?.onUserStoppedSpeaking?.();
                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).UserStoppedSpeaking);
            },
            onLocalAudioLevel: (level)=>{
                options?.callbacks?.onLocalAudioLevel?.(level);
                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).LocalAudioLevel, level);
            },
            onUserTranscript: (data)=>{
                options?.callbacks?.onUserTranscript?.(data);
                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).UserTranscript, data);
            },
            onBotTranscript: (text)=>{
                options?.callbacks?.onBotTranscript?.(text);
                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).BotTranscript, text);
            },
            onBotLlmText: (text)=>{
                options?.callbacks?.onBotLlmText?.(text);
                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).BotLlmText, text);
            },
            onBotLlmStarted: ()=>{
                options?.callbacks?.onBotLlmStarted?.();
                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).BotLlmStarted);
            },
            onBotLlmStopped: ()=>{
                options?.callbacks?.onBotLlmStopped?.();
                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).BotLlmStopped);
            },
            onBotTtsText: (text)=>{
                options?.callbacks?.onBotTtsText?.(text);
                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).BotTtsText, text);
            },
            onBotTtsStarted: ()=>{
                options?.callbacks?.onBotTtsStarted?.();
                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).BotTtsStarted);
            },
            onBotTtsStopped: ()=>{
                options?.callbacks?.onBotTtsStopped?.();
                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).BotTtsStopped);
            },
            onStorageItemStored: (data)=>{
                options?.callbacks?.onStorageItemStored?.(data);
                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).StorageItemStored, data);
            }
        };
        // Update options to reference wrapped callbacks and config defaults
        this._options = {
            ...options,
            callbacks: wrappedCallbacks,
            enableMic: options.enableMic ?? true,
            enableCam: options.enableCam ?? false
        };
        // Instantiate the transport class and bind message handler
        this._initialize();
        // Get package version number
        (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("[RTVI Client] Initialized", this.version);
    }
    constructUrl(endpoint) {
        if (!this.params.baseUrl) throw new $8ead7b33b8402751$export$59b4786f333aac02("Base URL not set. Please set rtviClient.params.baseUrl");
        const baseUrl = this.params.baseUrl.replace(/\/+$/, "");
        return baseUrl + (this.params.endpoints?.[endpoint] ?? "");
    }
    setLogLevel(level) {
        (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).setLevel(level);
    }
    // ------ Transport methods
    /**
     * Initialize local media devices
     */ async initDevices() {
        (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("[RTVI Client] Initializing devices...");
        await this._transport.initDevices();
    }
    /**
     * Connect the voice client session with chosen transport
     * Call async (await) to handle errors
     */ async connect() {
        if ([
            "authenticating",
            "connecting",
            "connected",
            "ready"
        ].includes(this._transport.state)) throw new $8ead7b33b8402751$export$59b4786f333aac02("Voice client has already been started. Please call disconnect() before starting again.");
        this._abortController = new AbortController();
        // Establish transport session and await bot ready signal
        return new Promise((resolve, reject)=>{
            (async ()=>{
                this._startResolve = resolve;
                if (this._transport.state === "disconnected") await this._transport.initDevices();
                this._transport.state = "authenticating";
                // Set a timer for the bot to enter a ready state, otherwise abort the attempt
                if (this._options.timeout) this._handshakeTimeout = setTimeout(async ()=>{
                    this._abortController?.abort();
                    await this.disconnect();
                    this._transport.state = "error";
                    reject(new $8ead7b33b8402751$export$c67992fa684a81a6());
                }, this._options.timeout);
                let authBundle;
                const customConnectHandler = this._options.customConnectHandler;
                (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("[RTVI Client] Start params", this.params);
                this.params = {
                    ...this.params,
                    requestData: {
                        ...this.params.requestData,
                        rtvi_client_version: this.version
                    }
                };
                if (!this.params.baseUrl && !this.params.endpoints?.connect) {
                    // If baseUrl and endpoints.connect are not set, bypass the handshake and connect directly
                    // This is useful with transports that do not require service side auth, especially in local development
                    // Note: this is not recommended for production use, see [docs link]
                    (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("[RTVI Client] Connecting directly (skipping handshake / auth)...");
                    clearTimeout(this._handshakeTimeout);
                } else {
                    const connectUrl = this.constructUrl("connect");
                    (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("[RTVI Client] Connecting...", connectUrl);
                    (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("[RTVI Client] Start params", this.params);
                    try {
                        if (customConnectHandler) authBundle = await customConnectHandler(this.params, this._handshakeTimeout, this._abortController);
                        else authBundle = await fetch(connectUrl, {
                            method: "POST",
                            mode: "cors",
                            headers: new Headers({
                                "Content-Type": "application/json",
                                ...Object.fromEntries((this.params.headers ?? new Headers()).entries())
                            }),
                            body: JSON.stringify({
                                config: this.params.config,
                                ...this.params.services ? {
                                    services: this.params.services
                                } : {},
                                ...this.params.requestData
                            }),
                            signal: this._abortController?.signal
                        }).then((res)=>{
                            clearTimeout(this._handshakeTimeout);
                            if (res.ok) return res.json();
                            return Promise.reject(res);
                        });
                    } catch (e) {
                        clearTimeout(this._handshakeTimeout);
                        // Handle errors if the request was not aborted
                        if (this._abortController?.signal.aborted) return;
                        this._transport.state = "error";
                        if (e instanceof Response) {
                            const errorResp = await e.json();
                            reject(new $8ead7b33b8402751$export$e7544ab812238a61(errorResp.info ?? errorResp.detail ?? e.statusText, e.status));
                        } else reject(new $8ead7b33b8402751$export$e7544ab812238a61());
                        return;
                    }
                    (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("[RTVI Client] Auth bundle received", authBundle);
                }
                try {
                    await this._transport.connect(authBundle, this._abortController);
                    await this._transport.sendReadyMessage();
                } catch (e) {
                    clearTimeout(this._handshakeTimeout);
                    this.disconnect();
                    reject(e);
                    return;
                }
            })();
        });
    }
    /**
     * Disconnect the voice client from the transport
     * Reset / reinitialize transport and abort any pending requests
     */ async disconnect() {
        if (this._abortController) this._abortController.abort();
        clearTimeout(this._handshakeTimeout);
        await this._transport.disconnect();
        this._messageDispatcher = new (0, $b48f893ed1354c1e$export$e9a960646cc432aa)(this);
    }
    _initialize() {
        this._transport.initialize(this._options, this.handleMessage.bind(this));
        // Create a new message dispatch queue for async message handling
        this._messageDispatcher = new (0, $b48f893ed1354c1e$export$e9a960646cc432aa)(this);
    }
    /**
     * Get the current state of the transport
     */ get connected() {
        return [
            "connected",
            "ready"
        ].includes(this._transport.state);
    }
    get transport() {
        return this._transportWrapper.proxy;
    }
    get state() {
        return this._transport.state;
    }
    get version() {
        return (0, (/*@__PURE__*/$parcel$interopDefault($e3bad9cc25e327f7$exports))).version;
    }
    // ------ Device methods
    async getAllMics() {
        return await this._transport.getAllMics();
    }
    async getAllCams() {
        return await this._transport.getAllCams();
    }
    async getAllSpeakers() {
        return await this._transport.getAllSpeakers();
    }
    get selectedMic() {
        return this._transport.selectedMic;
    }
    get selectedCam() {
        return this._transport.selectedCam;
    }
    get selectedSpeaker() {
        return this._transport.selectedSpeaker;
    }
    updateMic(micId) {
        this._transport.updateMic(micId);
    }
    updateCam(camId) {
        this._transport.updateCam(camId);
    }
    updateSpeaker(speakerId) {
        this._transport.updateSpeaker(speakerId);
    }
    enableMic(enable) {
        this._transport.enableMic(enable);
    }
    get isMicEnabled() {
        return this._transport.isMicEnabled;
    }
    enableCam(enable) {
        this._transport.enableCam(enable);
    }
    get isCamEnabled() {
        return this._transport.isCamEnabled;
    }
    tracks() {
        return this._transport.tracks();
    }
    enableScreenShare(enable) {
        return this._transport.enableScreenShare(enable);
    }
    get isSharingScreen() {
        return this._transport.isSharingScreen;
    }
    // ------ Config methods
    /**
     * Request the bot to send the current configuration
     * @returns Promise<RTVIClientConfigOption[]> - Promise that resolves with the bot's configuration
     */ async getConfig() {
        const configMsg = await this._messageDispatcher.dispatch((0, $b48f893ed1354c1e$export$69aa9ab0334b212).getBotConfig());
        return configMsg.data.config;
    }
    /**
     * Update pipeline and services
     * @param config - RTVIClientConfigOption[] partial object with the new configuration
     * @param interrupt - boolean flag to interrupt the current pipeline, or wait until the next turn
     * @returns Promise<RTVIMessage> - Promise that resolves with the updated configuration
     */ async updateConfig(config, interrupt = false) {
        (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("[RTVI Client] Updating config", config);
        // Only send the partial config if the bot is ready to prevent
        // potential racing conditions whilst pipeline is instantiating
        return this._messageDispatcher.dispatch((0, $b48f893ed1354c1e$export$69aa9ab0334b212).updateConfig(config, interrupt));
    }
    /**
     * Request bot describe the current configuration options
     * @returns Promise<unknown> - Promise that resolves with the bot's configuration description
     */ async describeConfig() {
        return this._messageDispatcher.dispatch((0, $b48f893ed1354c1e$export$69aa9ab0334b212).describeConfig());
    }
    /**
     * Returns configuration options for specified service key
     * @param serviceKey - Service name to get options for (e.g. "llm")
     * @param config? - Optional RTVIClientConfigOption[] to query (vs. using remote config)
     * @returns RTVIClientConfigOption | undefined - Configuration options array for the service with specified key or undefined
     */ async getServiceOptionsFromConfig(serviceKey, config) {
        if (!config && this.state !== "ready") throw new $8ead7b33b8402751$export$885fb96b850e8fbb("getServiceOptionsFromConfig called without config array before bot is ready");
        return Promise.resolve().then(async ()=>{
            // Check if we have registered service with name service
            if (!serviceKey) {
                (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("Target service name is required");
                return undefined;
            }
            const passedConfig = config ?? await this.getConfig();
            // Find matching service name in the config and update the messages
            const configServiceKey = passedConfig.find((config)=>config.service === serviceKey);
            if (!configServiceKey) {
                (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("No service with name " + serviceKey + " not found in config");
                return undefined;
            }
            // Return a new object, as to not mutate existing state
            return configServiceKey;
        });
    }
    /**
     * Returns configuration option value (unknown) for specified service key and option name
     * @param serviceKey - Service name to get options for (e.g. "llm")
     * @optional option Name of option return from the config (e.g. "model")
     * @returns Promise<unknown | undefined> - Service configuration option value or undefined
     */ async getServiceOptionValueFromConfig(serviceKey, option, config) {
        const configServiceKey = await this.getServiceOptionsFromConfig(serviceKey, config);
        if (!configServiceKey) {
            (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("Service with name " + serviceKey + " not found in config");
            return undefined;
        }
        // Find matching option key in the service config
        const optionValue = configServiceKey.options.find((o)=>o.name === option);
        return optionValue ? optionValue.value : undefined;
    }
    _updateOrAddOption(existingOptions, newOption) {
        const existingOptionIndex = existingOptions.findIndex((item)=>item.name === newOption.name);
        if (existingOptionIndex !== -1) // Update existing option
        return existingOptions.map((item, index)=>index === existingOptionIndex ? {
                ...item,
                value: newOption.value
            } : item);
        else // Add new option
        return [
            ...existingOptions,
            {
                name: newOption.name,
                value: newOption.value
            }
        ];
    }
    /**
     * Returns config with updated option(s) for specified service key and option name
     * Note: does not update current config, only returns a new object (call updateConfig to apply changes)
     * @param serviceKey - Service name to get options for (e.g. "llm")
     * @param option - Service name to get options for (e.g. "model")
     * @param config - Optional RTVIClientConfigOption[] to update (vs. using current config)
     * @returns Promise<RTVIClientConfigOption[] | undefined> - Configuration options array with updated option(s) or undefined
     */ async setServiceOptionInConfig(serviceKey, option, config) {
        const newConfig = (0, $eINDk$clonedeep)(config ?? await this.getConfig());
        const serviceOptions = await this.getServiceOptionsFromConfig(serviceKey, newConfig);
        if (!serviceOptions) {
            (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("Service with name '" + serviceKey + "' not found in config");
            return newConfig;
        }
        const optionsArray = Array.isArray(option) ? option : [
            option
        ];
        for (const opt of optionsArray){
            const existingItem = newConfig.find((item)=>item.service === serviceKey);
            const updatedOptions = existingItem ? this._updateOrAddOption(existingItem.options, opt) : [
                {
                    name: opt.name,
                    value: opt.value
                }
            ];
            if (existingItem) existingItem.options = updatedOptions;
            else newConfig.push({
                service: serviceKey,
                options: updatedOptions
            });
        }
        return newConfig;
    }
    /**
     * Returns config object with updated properties from passed array.
     * @param configOptions - Array of RTVIClientConfigOption[] to update
     * @param config? - Optional RTVIClientConfigOption[] to update (vs. using current config)
     * @returns Promise<RTVIClientConfigOption[]> - Configuration options
     */ async setConfigOptions(configOptions, config) {
        let accumulator = (0, $eINDk$clonedeep)(config ?? await this.getConfig());
        for (const configOption of configOptions)accumulator = await this.setServiceOptionInConfig(configOption.service, configOption.options, accumulator) || accumulator;
        return accumulator;
    }
    // ------ Actions
    /**
     * Dispatch an action message to the bot or http single-turn endpoint
     */ async action(action) {
        return this._messageDispatcher.dispatchAction(new (0, $b48f893ed1354c1e$export$378529d7a8bead8b)(action), this.handleMessage.bind(this));
    }
    /**
     * Describe available / registered actions the bot has
     * @returns Promise<unknown> - Promise that resolves with the bot's actions
     */ async describeActions() {
        return this._messageDispatcher.dispatch((0, $b48f893ed1354c1e$export$69aa9ab0334b212).describeActions());
    }
    // ------ Transport methods
    /**
     * Get the session expiry time for the transport session (if applicable)
     * @returns number - Expiry time in milliseconds
     */ get transportExpiry() {
        return this._transport.expiry;
    }
    // ------ Messages
    /**
     * Directly send a message to the bot via the transport
     * @param message - RTVIMessage object to send
     */ sendMessage(message) {
        this._transport.sendMessage(message);
    }
    /**
     * Disconnects the bot, but keeps the session alive
     */ disconnectBot() {
        this._transport.sendMessage(new (0, $b48f893ed1354c1e$export$69aa9ab0334b212)((0, $b48f893ed1354c1e$export$38b3db05cbf0e240).DISCONNECT_BOT, {}));
    }
    handleMessage(ev) {
        (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("[RTVI Message]", ev);
        switch(ev.type){
            case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).BOT_READY:
                clearTimeout(this._handshakeTimeout);
                this._startResolve?.(ev.data);
                this._options.callbacks?.onBotReady?.(ev.data);
                break;
            case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).CONFIG_AVAILABLE:
                this._messageDispatcher.resolve(ev);
                this._options.callbacks?.onConfigDescribe?.(ev.data);
                break;
            case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).CONFIG:
                {
                    const resp = this._messageDispatcher.resolve(ev);
                    this._options.callbacks?.onConfig?.(resp.data.config);
                    break;
                }
            case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).ACTIONS_AVAILABLE:
                this._messageDispatcher.resolve(ev);
                this._options.callbacks?.onActionsAvailable?.(ev.data);
                break;
            case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).ACTION_RESPONSE:
                this._messageDispatcher.resolve(ev);
                break;
            case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).ERROR_RESPONSE:
                {
                    const resp = this._messageDispatcher.reject(ev);
                    this._options.callbacks?.onMessageError?.(resp);
                    break;
                }
            case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).ERROR:
                this._options.callbacks?.onError?.(ev);
                break;
            case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).USER_STARTED_SPEAKING:
                this._options.callbacks?.onUserStartedSpeaking?.();
                break;
            case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).USER_STOPPED_SPEAKING:
                this._options.callbacks?.onUserStoppedSpeaking?.();
                break;
            case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).BOT_STARTED_SPEAKING:
                this._options.callbacks?.onBotStartedSpeaking?.();
                break;
            case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).BOT_STOPPED_SPEAKING:
                this._options.callbacks?.onBotStoppedSpeaking?.();
                break;
            case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).USER_TRANSCRIPTION:
                {
                    const TranscriptData = ev.data;
                    this._options.callbacks?.onUserTranscript?.(TranscriptData);
                    break;
                }
            case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).BOT_TRANSCRIPTION:
                this._options.callbacks?.onBotTranscript?.(ev.data);
                break;
            case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).BOT_LLM_TEXT:
                this._options.callbacks?.onBotLlmText?.(ev.data);
                break;
            case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).BOT_LLM_STARTED:
                this._options.callbacks?.onBotLlmStarted?.();
                break;
            case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).BOT_LLM_STOPPED:
                this._options.callbacks?.onBotLlmStopped?.();
                break;
            case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).BOT_TTS_TEXT:
                this._options.callbacks?.onBotTtsText?.(ev.data);
                break;
            case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).BOT_TTS_STARTED:
                this._options.callbacks?.onBotTtsStarted?.();
                break;
            case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).BOT_TTS_STOPPED:
                this._options.callbacks?.onBotTtsStopped?.();
                break;
            case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).BOT_LLM_SEARCH_RESPONSE:
                this._options.callbacks?.onBotLlmSearchResponse?.(ev.data);
                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).BotLlmSearchResponse, ev.data);
                break;
            case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).METRICS:
                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).Metrics, ev.data);
                this._options.callbacks?.onMetrics?.(ev.data);
                break;
            case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).STORAGE_ITEM_STORED:
                this._options.callbacks?.onStorageItemStored?.(ev.data);
                break;
            case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).SERVER_MESSAGE:
                this._options.callbacks?.onServerMessage?.(ev.data);
                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).ServerMessage, ev.data);
                break;
            default:
                {
                    let match = false;
                    // Pass message to registered helpers
                    for (const helper of Object.values(this._helpers))if (helper.getMessageTypes().includes(ev.type)) {
                        match = true;
                        helper.handleMessage(ev);
                    }
                    if (!match) this._options.callbacks?.onGenericMessage?.(ev.data);
                }
        }
    }
    // ------ Helpers
    /**
     * Register a new helper to the client
     * This (optionally) provides a way to reference helpers directly
     * from the client and use the event dispatcher
     * @param service - Target service for this helper
     * @param helper - Helper instance
     * @returns RTVIClientHelper - Registered helper instance
     */ registerHelper(service, helper) {
        if (this._helpers[service]) throw new Error(`Helper with name '${service}' already registered`);
        // Check helper is instance of RTVIClientHelper
        if (!(helper instanceof (0, $7614fb2168c523cc$export$23bc637255b2a471))) throw new Error(`Helper must be an instance of RTVIClientHelper`);
        helper.service = service;
        helper.client = this;
        this._helpers[service] = helper;
        return this._helpers[service];
    }
    getHelper(service) {
        const helper = this._helpers[service];
        if (!helper) {
            (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug(`Helper targeting service '${service}' not found`);
            return undefined;
        }
        return helper;
    }
    unregisterHelper(service) {
        if (!this._helpers[service]) return;
        delete this._helpers[service];
    }
}
$a7c324a73303ad55$var$__decorate([
    (0, $16f019d4d16917df$export$f1586721024c4dab)
], $a7c324a73303ad55$export$fa42a01c1d60f4a1.prototype, "getConfig", null);
$a7c324a73303ad55$var$__decorate([
    (0, $16f019d4d16917df$export$f1586721024c4dab)
], $a7c324a73303ad55$export$fa42a01c1d60f4a1.prototype, "updateConfig", null);
$a7c324a73303ad55$var$__decorate([
    (0, $16f019d4d16917df$export$f1586721024c4dab)
], $a7c324a73303ad55$export$fa42a01c1d60f4a1.prototype, "describeConfig", null);
$a7c324a73303ad55$var$__decorate([
    (0, $16f019d4d16917df$export$f1586721024c4dab)
], $a7c324a73303ad55$export$fa42a01c1d60f4a1.prototype, "describeActions", null);
$a7c324a73303ad55$var$__decorate([
    (0, $16f019d4d16917df$export$5c35b4fe6fa8c9a6)("connected", "ready")
], $a7c324a73303ad55$export$fa42a01c1d60f4a1.prototype, "transportExpiry", null);
$a7c324a73303ad55$var$__decorate([
    (0, $16f019d4d16917df$export$f1586721024c4dab)
], $a7c324a73303ad55$export$fa42a01c1d60f4a1.prototype, "sendMessage", null);
$a7c324a73303ad55$var$__decorate([
    (0, $16f019d4d16917df$export$f1586721024c4dab)
], $a7c324a73303ad55$export$fa42a01c1d60f4a1.prototype, "disconnectBot", null);





var $0908f693e3e0724c$exports = {};

$parcel$export($0908f693e3e0724c$exports, "LLMMessageType", () => $0908f693e3e0724c$export$441bcd2e10762760);
$parcel$export($0908f693e3e0724c$exports, "LLMActionType", () => $0908f693e3e0724c$export$43cdfb26f790451);
$parcel$export($0908f693e3e0724c$exports, "LLMHelper", () => $0908f693e3e0724c$export$3cf39a62d076dd5c);
/**
 * Copyright (c) 2024, Daily.
 *
 * SPDX-License-Identifier: BSD-2-Clause
 */ 



var $0908f693e3e0724c$export$441bcd2e10762760;
(function(LLMMessageType) {
    LLMMessageType["LLM_FUNCTION_CALL"] = "llm-function-call";
    LLMMessageType["LLM_FUNCTION_CALL_START"] = "llm-function-call-start";
    LLMMessageType["LLM_FUNCTION_CALL_RESULT"] = "llm-function-call-result";
    LLMMessageType["LLM_JSON_COMPLETION"] = "llm-json-completion";
})($0908f693e3e0724c$export$441bcd2e10762760 || ($0908f693e3e0724c$export$441bcd2e10762760 = {}));
var $0908f693e3e0724c$export$43cdfb26f790451;
(function(LLMActionType) {
    LLMActionType["APPEND_TO_MESSAGES"] = "append_to_messages";
    LLMActionType["GET_CONTEXT"] = "get_context";
    LLMActionType["SET_CONTEXT"] = "set_context";
    LLMActionType["RUN"] = "run";
})($0908f693e3e0724c$export$43cdfb26f790451 || ($0908f693e3e0724c$export$43cdfb26f790451 = {}));
class $0908f693e3e0724c$export$3cf39a62d076dd5c extends (0, $7614fb2168c523cc$export$23bc637255b2a471) {
    constructor(options){
        super(options);
        this._functionCallCallback = null;
    }
    getMessageTypes() {
        return Object.values($0908f693e3e0724c$export$441bcd2e10762760);
    }
    // --- Actions
    /**
     * Retrieve the bot's current LLM context.
     * @returns Promise<LLMContext>
     */ async getContext() {
        if (this._client.state !== "ready") throw new $8ead7b33b8402751$export$885fb96b850e8fbb("getContext called while transport not in ready state");
        const actionResponseMsg = await this._client.action({
            service: this._service,
            action: $0908f693e3e0724c$export$43cdfb26f790451.GET_CONTEXT
        });
        return actionResponseMsg.data.result;
    }
    /**
     * Update the bot's LLM context.
     * If this is called while the transport is not in the ready state, the local context will be updated
     * @param context LLMContext - The new context
     * @param interrupt boolean - Whether to interrupt the bot, or wait until it has finished speaking
     * @returns Promise<boolean>
     */ async setContext(context, interrupt = false) {
        if (this._client.state !== "ready") throw new $8ead7b33b8402751$export$885fb96b850e8fbb("setContext called while transport not in ready state");
        const actionResponse = await this._client.action({
            service: this._service,
            action: $0908f693e3e0724c$export$43cdfb26f790451.SET_CONTEXT,
            arguments: [
                {
                    name: "messages",
                    value: context.messages
                },
                {
                    name: "interrupt",
                    value: interrupt
                }
            ]
        });
        return !!actionResponse.data.result;
    }
    /**
     * Append a new message to the LLM context.
     * If this is called while the transport is not in the ready state, the local context will be updated
     * @param context LLMContextMessage
     * @param runImmediately boolean - wait until pipeline is idle before running
     * @returns boolean
     */ async appendToMessages(message, runImmediately = false) {
        if (this._client.state !== "ready") throw new $8ead7b33b8402751$export$885fb96b850e8fbb("setContext called while transport not in ready state");
        const actionResponse = await this._client.action({
            service: this._service,
            action: $0908f693e3e0724c$export$43cdfb26f790451.APPEND_TO_MESSAGES,
            arguments: [
                {
                    name: "messages",
                    value: [
                        message
                    ]
                },
                {
                    name: "run_immediately",
                    value: runImmediately
                }
            ]
        });
        return !!actionResponse.data.result;
    }
    /**
     * Run the bot's current LLM context.
     * Useful when appending messages to the context without runImmediately set to true.
     * Will do nothing if the bot is not in the ready state.
     * @param interrupt boolean - Whether to interrupt the bot, or wait until it has finished speaking
     * @returns Promise<unknown>
     */ async run(interrupt = false) {
        if (this._client.state !== "ready") return;
        return this._client.action({
            service: this._service,
            action: $0908f693e3e0724c$export$43cdfb26f790451.RUN,
            arguments: [
                {
                    name: "interrupt",
                    value: interrupt
                }
            ]
        });
    }
    // --- Handlers
    /**
     * If the LLM wants to call a function, RTVI will invoke the callback defined
     * here. Whatever the callback returns will be sent to the LLM as the function result.
     * @param callback
     * @returns void
     */ handleFunctionCall(callback) {
        this._functionCallCallback = callback;
    }
    handleMessage(ev) {
        switch(ev.type){
            case $0908f693e3e0724c$export$441bcd2e10762760.LLM_JSON_COMPLETION:
                this._options.callbacks?.onLLMJsonCompletion?.(ev.data);
                this._client.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).LLMJsonCompletion, ev.data);
                break;
            case $0908f693e3e0724c$export$441bcd2e10762760.LLM_FUNCTION_CALL:
                {
                    const d = ev.data;
                    this._options.callbacks?.onLLMFunctionCall?.(ev.data);
                    this._client.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).LLMFunctionCall, ev.data);
                    if (this._functionCallCallback) {
                        const fn = {
                            functionName: d.function_name,
                            arguments: d.args
                        };
                        if (this._client.state === "ready") this._functionCallCallback(fn).then((result)=>{
                            this._client.sendMessage(new (0, $b48f893ed1354c1e$export$69aa9ab0334b212)($0908f693e3e0724c$export$441bcd2e10762760.LLM_FUNCTION_CALL_RESULT, {
                                function_name: d.function_name,
                                tool_call_id: d.tool_call_id,
                                arguments: d.args,
                                result: result
                            }));
                        });
                        else throw new $8ead7b33b8402751$export$885fb96b850e8fbb("Attempted to send a function call result from bot while transport not in ready state");
                    }
                    break;
                }
            case $0908f693e3e0724c$export$441bcd2e10762760.LLM_FUNCTION_CALL_START:
                {
                    const e = ev.data;
                    this._options.callbacks?.onLLMFunctionCallStart?.(e.function_name);
                    this._client.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).LLMFunctionCallStart, e.function_name);
                    break;
                }
        }
    }
}




var $4086f06442fcb7d7$exports = {};

$parcel$export($4086f06442fcb7d7$exports, "Transport", () => $4086f06442fcb7d7$export$86495b081fef8e52);
/**
 * Copyright (c) 2024, Daily.
 *
 * SPDX-License-Identifier: BSD-2-Clause
 */ class $4086f06442fcb7d7$export$86495b081fef8e52 {
    constructor(){
        this._state = "disconnected";
        this._expiry = undefined;
    }
    get expiry() {
        return this._expiry;
    }
}




export {$4bb349f22aee5185$export$8728b60ea57bf43e as httpActionGenerator, $a7c324a73303ad55$export$fa42a01c1d60f4a1 as RTVIClient, $8ead7b33b8402751$export$59b4786f333aac02 as RTVIError, $8ead7b33b8402751$export$c67992fa684a81a6 as ConnectionTimeoutError, $8ead7b33b8402751$export$e7544ab812238a61 as StartBotError, $8ead7b33b8402751$export$e0624a511a2c4e9 as TransportStartError, $8ead7b33b8402751$export$885fb96b850e8fbb as BotNotReadyError, $8ead7b33b8402751$export$4eda4fd287fbbca5 as ConfigUpdateError, $8ead7b33b8402751$export$be839f0100cd3132 as ActionEndpointNotSetError, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb as RTVIEvent, $7614fb2168c523cc$export$23bc637255b2a471 as RTVIClientHelper, $0908f693e3e0724c$export$441bcd2e10762760 as LLMMessageType, $0908f693e3e0724c$export$43cdfb26f790451 as LLMActionType, $0908f693e3e0724c$export$3cf39a62d076dd5c as LLMHelper, $7afbbd59ebaa42bf$export$243e62d78d3b544d as LogLevel, $7afbbd59ebaa42bf$export$af88d00dbe7f521 as logger, $b48f893ed1354c1e$export$882b13c7fda338f5 as RTVI_MESSAGE_LABEL, $b48f893ed1354c1e$export$38b3db05cbf0e240 as RTVIMessageType, $b48f893ed1354c1e$export$69aa9ab0334b212 as RTVIMessage, $b48f893ed1354c1e$export$378529d7a8bead8b as RTVIActionRequest, $b48f893ed1354c1e$export$e9a960646cc432aa as MessageDispatcher, $4086f06442fcb7d7$export$86495b081fef8e52 as Transport};
//# sourceMappingURL=index.module.js.map
