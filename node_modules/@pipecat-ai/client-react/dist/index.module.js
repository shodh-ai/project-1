import {jsx as $h9lXz$jsx, Fragment as $h9lXz$Fragment} from "react/jsx-runtime";
import {RTVIEvent as $h9lXz$RTVIEvent} from "@pipecat-ai/client-js";
import $h9lXz$react, {useRef as $h9lXz$useRef, useEffect as $h9lXz$useEffect, useCallback as $h9lXz$useCallback, useContext as $h9lXz$useContext, createContext as $h9lXz$createContext, forwardRef as $h9lXz$forwardRef} from "react";
import {createStore as $h9lXz$createStore, atom as $h9lXz$atom, useAtomValue as $h9lXz$useAtomValue, useAtom as $h9lXz$useAtom} from "jotai";
import {Provider as $h9lXz$Provider} from "jotai/react";
import {atomFamily as $h9lXz$atomFamily, useAtomCallback as $h9lXz$useAtomCallback} from "jotai/utils";

/**
 * Copyright (c) 2024, Daily.
 *
 * SPDX-License-Identifier: BSD-2-Clause
 */ 


/**
 * Copyright (c) 2024, Daily.
 *
 * SPDX-License-Identifier: BSD-2-Clause
 */ 
/**
 * Copyright (c) 2024, Daily.
 *
 * SPDX-License-Identifier: BSD-2-Clause
 */ 




const $f3f7d4263dc13c6a$var$defaultStore = (0, $h9lXz$createStore)();
const $f3f7d4263dc13c6a$export$8d2b07cbee622e7c = /*#__PURE__*/ (0, $h9lXz$createContext)({});
const $f3f7d4263dc13c6a$export$4a4ae2d5dc96782 = ({ children: children, client: client, jotaiStore: jotaiStore = $f3f7d4263dc13c6a$var$defaultStore })=>{
    return (0, $h9lXz$jsx)((0, $h9lXz$Provider), {
        store: jotaiStore,
        children: (0, $h9lXz$jsx)($f3f7d4263dc13c6a$export$8d2b07cbee622e7c.Provider, {
            value: {
                client: client
            },
            children: children
        })
    });
};
$f3f7d4263dc13c6a$export$4a4ae2d5dc96782.displayName = "RTVIClientProvider";


const $54a3c9f5bdbf0854$export$31a5f6a22c9b8fba = ()=>{
    const { client: client } = (0, $h9lXz$useContext)((0, $f3f7d4263dc13c6a$export$8d2b07cbee622e7c));
    return client;
};


const $824ea64b5f757259$export$33a6ac53b8f02625 = (event, handler)=>{
    const client = (0, $54a3c9f5bdbf0854$export$31a5f6a22c9b8fba)();
    (0, $h9lXz$useEffect)(()=>{
        if (!client) return;
        client.on(event, handler);
        return ()=>{
            client.off(event, handler);
        };
    }, [
        event,
        handler,
        client
    ]);
};


/**
 * Copyright (c) 2024, Daily.
 *
 * SPDX-License-Identifier: BSD-2-Clause
 */ 





const $194c75143b7a1fa0$var$localAudioTrackAtom = (0, $h9lXz$atom)(null);
const $194c75143b7a1fa0$var$localVideoTrackAtom = (0, $h9lXz$atom)(null);
const $194c75143b7a1fa0$var$localScreenAudioTrackAtom = (0, $h9lXz$atom)(null);
const $194c75143b7a1fa0$var$localScreenVideoTrackAtom = (0, $h9lXz$atom)(null);
const $194c75143b7a1fa0$var$botAudioTrackAtom = (0, $h9lXz$atom)(null);
const $194c75143b7a1fa0$var$botVideoTrackAtom = (0, $h9lXz$atom)(null);
const $194c75143b7a1fa0$var$trackAtom = (0, $h9lXz$atomFamily)(({ local: local, trackType: trackType })=>{
    if (local) switch(trackType){
        case "audio":
            return $194c75143b7a1fa0$var$localAudioTrackAtom;
        case "screenAudio":
            return $194c75143b7a1fa0$var$localScreenAudioTrackAtom;
        case "screenVideo":
            return $194c75143b7a1fa0$var$localScreenVideoTrackAtom;
        case "video":
            return $194c75143b7a1fa0$var$localVideoTrackAtom;
    }
    return trackType === "audio" ? $194c75143b7a1fa0$var$botAudioTrackAtom : $194c75143b7a1fa0$var$botVideoTrackAtom;
});
const $194c75143b7a1fa0$export$7c03381e0d26a6c3 = (trackType, participantType)=>{
    const client = (0, $54a3c9f5bdbf0854$export$31a5f6a22c9b8fba)();
    const track = (0, $h9lXz$useAtomValue)($194c75143b7a1fa0$var$trackAtom({
        local: participantType === "local",
        trackType: trackType
    }));
    const updateTrack = (0, $h9lXz$useAtomCallback)((0, $h9lXz$useCallback)((get, set, track, trackType, local)=>{
        const atom = $194c75143b7a1fa0$var$trackAtom({
            local: local,
            trackType: trackType
        });
        const oldTrack = get(atom);
        if (oldTrack?.id === track.id) return;
        set(atom, track);
    }, [
        participantType,
        track,
        trackType
    ]));
    (0, $824ea64b5f757259$export$33a6ac53b8f02625)((0, $h9lXz$RTVIEvent).TrackStarted, (0, $h9lXz$useCallback)((track, participant)=>{
        updateTrack(track, track.kind, Boolean(participant?.local));
    }, []));
    (0, $824ea64b5f757259$export$33a6ac53b8f02625)((0, $h9lXz$RTVIEvent).ScreenTrackStarted, (0, $h9lXz$useCallback)((track, participant)=>{
        const trackType = track.kind === "audio" ? "screenAudio" : "screenVideo";
        updateTrack(track, trackType, Boolean(participant?.local));
    }, []));
    (0, $h9lXz$useEffect)(()=>{
        if (!client) return;
        const tracks = client.tracks();
        const track = tracks?.[participantType]?.[trackType];
        if (!track) return;
        updateTrack(track, trackType, participantType === "local");
    }, [
        participantType,
        trackType,
        updateTrack,
        client
    ]);
    return track;
};


const $f8b885726fc652c0$export$ba1245f7cbf3ae02 = ()=>{
    const botAudioRef = (0, $h9lXz$useRef)(null);
    const botAudioTrack = (0, $194c75143b7a1fa0$export$7c03381e0d26a6c3)("audio", "bot");
    (0, $h9lXz$useEffect)(()=>{
        if (!botAudioRef.current || !botAudioTrack) return;
        if (botAudioRef.current.srcObject) {
            const oldTrack = botAudioRef.current.srcObject.getAudioTracks()[0];
            if (oldTrack.id === botAudioTrack.id) return;
        }
        botAudioRef.current.srcObject = new MediaStream([
            botAudioTrack
        ]);
    }, [
        botAudioTrack
    ]);
    (0, $824ea64b5f757259$export$33a6ac53b8f02625)((0, $h9lXz$RTVIEvent).SpeakerUpdated, (0, $h9lXz$useCallback)((speaker)=>{
        if (!botAudioRef.current) return;
        if (typeof botAudioRef.current.setSinkId !== "function") return;
        botAudioRef.current.setSinkId(speaker.deviceId);
    }, []));
    return (0, $h9lXz$jsx)((0, $h9lXz$Fragment), {
        children: (0, $h9lXz$jsx)("audio", {
            ref: botAudioRef,
            autoPlay: true
        })
    });
};
$f8b885726fc652c0$export$ba1245f7cbf3ae02.displayName = "RTVIClientAudio";





/**
 * Copyright (c) 2024, Daily.
 *
 * SPDX-License-Identifier: BSD-2-Clause
 *
 * This file contains code derived from:
 * https://github.com/jaredLunde/react-hook/blob/master/packages/merged-ref/src/index.tsx
 * Original author: Jared Lunde (https://github.com/jaredLunde)
 * Original license: MIT (https://github.com/jaredLunde/react-hook/blob/master/LICENSE)
 */ 
function $9098519210cf34e2$var$useMergedRef(...refs) {
    return (0, $h9lXz$useCallback)((element)=>{
        for(let i = 0; i < refs.length; i++){
            const ref = refs[i];
            if (typeof ref === "function") ref(element);
            else if (ref && typeof ref === "object") ref.current = element;
        }
    }, // eslint-disable-next-line react-hooks/exhaustive-deps
    refs);
}
var $9098519210cf34e2$export$2e2bcd8739ae039 = $9098519210cf34e2$var$useMergedRef;



const $b76d887910983811$export$d090a384943608eb = /*#__PURE__*/ (0, $h9lXz$forwardRef)(function VoiceClientVideo({ participant: participant = "local", fit: fit = "contain", mirror: mirror, onResize: onResize, style: style = {}, trackType: trackType = "video", ...props }, ref) {
    const videoTrack = (0, $194c75143b7a1fa0$export$7c03381e0d26a6c3)(trackType, participant);
    const videoEl = (0, $h9lXz$useRef)(null);
    const videoRef = (0, $9098519210cf34e2$export$2e2bcd8739ae039)(videoEl, ref);
    /**
     * Handle canplay & picture-in-picture events.
     */ (0, $h9lXz$useEffect)(function setupVideoEvents() {
        const video = videoEl.current;
        if (!video) return;
        const playVideo = ()=>{
            const promise = video.play();
            if (promise !== undefined) promise.then(()=>{
                // All good, playback started.
                video.controls = false;
            }).catch((error)=>{
                // Auto-play was prevented. Show video controls, so user can play video manually.
                video.controls = true;
                console.warn("Failed to play video", error);
            });
        };
        const handleCanPlay = ()=>{
            if (!video.paused) return;
            playVideo();
        };
        const handleEnterPIP = ()=>{
            video.style.transform = "scale(1)";
        };
        const handleLeavePIP = ()=>{
            video.style.transform = "";
            setTimeout(()=>{
                if (video.paused) playVideo();
            }, 100);
        };
        const handleVisibilityChange = ()=>{
            if (document.visibilityState === "hidden") return;
            if (!video.paused) return;
            playVideo();
        };
        video.addEventListener("canplay", handleCanPlay);
        video.addEventListener("enterpictureinpicture", handleEnterPIP);
        video.addEventListener("leavepictureinpicture", handleLeavePIP);
        // Videos can be paused if media was played in another app on iOS.
        document.addEventListener("visibilitychange", handleVisibilityChange);
        return ()=>{
            video.removeEventListener("canplay", handleCanPlay);
            video.removeEventListener("enterpictureinpicture", handleEnterPIP);
            video.removeEventListener("leavepictureinpicture", handleLeavePIP);
            document.removeEventListener("visibilitychange", handleVisibilityChange);
        };
    }, []);
    /**
     * Update srcObject.
     */ (0, $h9lXz$useEffect)(function updateSrcObject() {
        const video = videoEl.current;
        if (!video || !videoTrack) return;
        video.srcObject = new MediaStream([
            videoTrack
        ]);
        video.load();
        return ()=>{
            // clean up when unmounted
            video.srcObject = null;
            video.load();
        };
    }, [
        videoTrack,
        videoTrack?.id
    ]);
    /**
     * Add optional event listener for resize event so the parent component
     * can know the video's native aspect ratio.
     */ (0, $h9lXz$useEffect)(function reportVideoDimensions() {
        const video = videoEl.current;
        if (!onResize || !video) return;
        let frame;
        function handleResize() {
            if (frame) cancelAnimationFrame(frame);
            frame = requestAnimationFrame(()=>{
                const video = videoEl.current;
                if (!video || document.hidden) return;
                const videoWidth = video.videoWidth;
                const videoHeight = video.videoHeight;
                if (videoWidth && videoHeight) onResize?.({
                    aspectRatio: videoWidth / videoHeight,
                    height: videoHeight,
                    width: videoWidth
                });
            });
        }
        handleResize();
        video.addEventListener("loadedmetadata", handleResize);
        video.addEventListener("resize", handleResize);
        return ()=>{
            if (frame) cancelAnimationFrame(frame);
            video.removeEventListener("loadedmetadata", handleResize);
            video.removeEventListener("resize", handleResize);
        };
    }, [
        onResize
    ]);
    return (0, $h9lXz$jsx)("video", {
        autoPlay: true,
        muted: true,
        playsInline: true,
        ref: videoRef,
        style: {
            objectFit: fit,
            transform: mirror ? "scale(-1, 1)" : "",
            ...style
        },
        ...props
    });
});
$b76d887910983811$export$d090a384943608eb.displayName = "RTVIClientVideo";










const $c7d06534b21735c2$var$availableMicsAtom = (0, $h9lXz$atom)([]);
const $c7d06534b21735c2$var$availableCamsAtom = (0, $h9lXz$atom)([]);
const $c7d06534b21735c2$var$availableSpeakersAtom = (0, $h9lXz$atom)([]);
const $c7d06534b21735c2$var$selectedMicAtom = (0, $h9lXz$atom)({});
const $c7d06534b21735c2$var$selectedCamAtom = (0, $h9lXz$atom)({});
const $c7d06534b21735c2$var$selectedSpeakerAtom = (0, $h9lXz$atom)({});
const $c7d06534b21735c2$export$652c54907b83a48d = ()=>{
    const client = (0, $54a3c9f5bdbf0854$export$31a5f6a22c9b8fba)();
    const availableCams = (0, $h9lXz$useAtomValue)($c7d06534b21735c2$var$availableCamsAtom);
    const availableMics = (0, $h9lXz$useAtomValue)($c7d06534b21735c2$var$availableMicsAtom);
    const availableSpeakers = (0, $h9lXz$useAtomValue)($c7d06534b21735c2$var$availableSpeakersAtom);
    const selectedCam = (0, $h9lXz$useAtomValue)($c7d06534b21735c2$var$selectedCamAtom);
    const selectedMic = (0, $h9lXz$useAtomValue)($c7d06534b21735c2$var$selectedMicAtom);
    const selectedSpeaker = (0, $h9lXz$useAtomValue)($c7d06534b21735c2$var$selectedSpeakerAtom);
    (0, $824ea64b5f757259$export$33a6ac53b8f02625)((0, $h9lXz$RTVIEvent).AvailableCamsUpdated, (0, $h9lXz$useAtomCallback)((0, $h9lXz$useCallback)((_get, set, cams)=>{
        set($c7d06534b21735c2$var$availableCamsAtom, cams);
    }, [])));
    (0, $824ea64b5f757259$export$33a6ac53b8f02625)((0, $h9lXz$RTVIEvent).AvailableMicsUpdated, (0, $h9lXz$useAtomCallback)((0, $h9lXz$useCallback)((_get, set, mics)=>{
        set($c7d06534b21735c2$var$availableMicsAtom, mics);
    }, [])));
    (0, $824ea64b5f757259$export$33a6ac53b8f02625)((0, $h9lXz$RTVIEvent).AvailableSpeakersUpdated, (0, $h9lXz$useAtomCallback)((0, $h9lXz$useCallback)((_get, set, speakers)=>{
        set($c7d06534b21735c2$var$availableSpeakersAtom, speakers);
    }, [])));
    (0, $824ea64b5f757259$export$33a6ac53b8f02625)((0, $h9lXz$RTVIEvent).CamUpdated, (0, $h9lXz$useAtomCallback)((0, $h9lXz$useCallback)((_get, set, cam)=>{
        set($c7d06534b21735c2$var$selectedCamAtom, cam);
    }, [])));
    (0, $824ea64b5f757259$export$33a6ac53b8f02625)((0, $h9lXz$RTVIEvent).MicUpdated, (0, $h9lXz$useAtomCallback)((0, $h9lXz$useCallback)((_get, set, mic)=>{
        set($c7d06534b21735c2$var$selectedMicAtom, mic);
    }, [])));
    (0, $824ea64b5f757259$export$33a6ac53b8f02625)((0, $h9lXz$RTVIEvent).SpeakerUpdated, (0, $h9lXz$useAtomCallback)((0, $h9lXz$useCallback)((_get, set, speaker)=>{
        set($c7d06534b21735c2$var$selectedSpeakerAtom, speaker);
    }, [])));
    const updateCam = (0, $h9lXz$useCallback)((id)=>{
        client?.updateCam(id);
    }, [
        client
    ]);
    const updateMic = (0, $h9lXz$useCallback)((id)=>{
        client?.updateMic(id);
    }, [
        client
    ]);
    const updateSpeaker = (0, $h9lXz$useCallback)((id)=>{
        client?.updateSpeaker(id);
    }, [
        client
    ]);
    return {
        availableCams: availableCams,
        availableMics: availableMics,
        availableSpeakers: availableSpeakers,
        selectedCam: selectedCam,
        selectedMic: selectedMic,
        selectedSpeaker: selectedSpeaker,
        updateCam: updateCam,
        updateMic: updateMic,
        updateSpeaker: updateSpeaker
    };
};



/**
 * Copyright (c) 2024, Daily.
 *
 * SPDX-License-Identifier: BSD-2-Clause
 */ 


const $8376ffbc1b1f3c97$var$transportStateAtom = (0, $h9lXz$atom)("disconnected");
const $8376ffbc1b1f3c97$export$599fa01283bd4ece = ()=>{
    const [transportState, setTransportState] = (0, $h9lXz$useAtom)($8376ffbc1b1f3c97$var$transportStateAtom);
    (0, $824ea64b5f757259$export$33a6ac53b8f02625)((0, $h9lXz$RTVIEvent).TransportStateChanged, setTransportState);
    return transportState;
};





const $993a744193844a95$export$59bf27bd43679db6 = /*#__PURE__*/ (0, $h9lXz$react).memo(({ backgroundColor: backgroundColor = "transparent", barColor: barColor = "black", barWidth: barWidth = 30, barGap: barGap = 12, barMaxHeight: barMaxHeight = 120, participantType: participantType })=>{
    const canvasRef = (0, $h9lXz$useRef)(null);
    const track = (0, $194c75143b7a1fa0$export$7c03381e0d26a6c3)("audio", participantType);
    (0, $h9lXz$useEffect)(()=>{
        if (!canvasRef.current) return;
        const canvasWidth = 5 * barWidth + 4 * barGap;
        const canvasHeight = barMaxHeight;
        const canvas = canvasRef.current;
        const scaleFactor = 2;
        // Make canvas fill the width and height of its container
        const resizeCanvas = ()=>{
            canvas.width = canvasWidth * scaleFactor;
            canvas.height = canvasHeight * scaleFactor;
            canvas.style.width = `${canvasWidth}px`;
            canvas.style.height = `${canvasHeight}px`;
            canvasCtx.lineCap = "round";
            canvasCtx.scale(scaleFactor, scaleFactor);
        };
        const canvasCtx = canvas.getContext("2d");
        resizeCanvas();
        if (!track) return;
        const audioContext = new AudioContext();
        const source = audioContext.createMediaStreamSource(new MediaStream([
            track
        ]));
        const analyser = audioContext.createAnalyser();
        analyser.fftSize = 1024;
        source.connect(analyser);
        const frequencyData = new Uint8Array(analyser.frequencyBinCount);
        canvasCtx.lineCap = "round";
        const bands = [
            {
                startFreq: 85,
                endFreq: 255,
                smoothValue: 0
            },
            {
                startFreq: 255,
                endFreq: 500,
                smoothValue: 0
            },
            {
                startFreq: 500,
                endFreq: 2000,
                smoothValue: 0
            },
            {
                startFreq: 2000,
                endFreq: 4000,
                smoothValue: 0
            },
            {
                startFreq: 4000,
                endFreq: 8000,
                smoothValue: 0
            }
        ];
        const getFrequencyBinIndex = (frequency)=>{
            const nyquist = audioContext.sampleRate / 2;
            return Math.round(frequency / nyquist * (analyser.frequencyBinCount - 1));
        };
        function drawSpectrum() {
            analyser.getByteFrequencyData(frequencyData);
            canvasCtx.clearRect(0, 0, canvas.width / scaleFactor, canvas.height / scaleFactor);
            canvasCtx.fillStyle = backgroundColor;
            canvasCtx.fillRect(0, 0, canvas.width / scaleFactor, canvas.height / scaleFactor);
            let isActive = false;
            const totalBarsWidth = bands.length * barWidth + (bands.length - 1) * barGap;
            const startX = (canvas.width / scaleFactor - totalBarsWidth) / 2; // Center bars
            const adjustedCircleRadius = barWidth / 2; // Fixed radius for reset circles
            bands.forEach((band, i)=>{
                const startIndex = getFrequencyBinIndex(band.startFreq);
                const endIndex = getFrequencyBinIndex(band.endFreq);
                const bandData = frequencyData.slice(startIndex, endIndex);
                const bandValue = bandData.reduce((acc, val)=>acc + val, 0) / bandData.length;
                const smoothingFactor = 0.2;
                if (bandValue < 1) band.smoothValue = Math.max(band.smoothValue - smoothingFactor * 5, 0);
                else {
                    band.smoothValue = band.smoothValue + (bandValue - band.smoothValue) * smoothingFactor;
                    isActive = true;
                }
                const x = startX + i * (barWidth + barGap);
                // Calculate bar height with a maximum cap
                const barHeight = Math.min(band.smoothValue / 255 * barMaxHeight, barMaxHeight);
                const yTop = Math.max(canvas.height / scaleFactor / 2 - barHeight / 2, adjustedCircleRadius);
                const yBottom = Math.min(canvas.height / scaleFactor / 2 + barHeight / 2, canvas.height / scaleFactor - adjustedCircleRadius);
                if (band.smoothValue > 0) {
                    canvasCtx.beginPath();
                    canvasCtx.moveTo(x + barWidth / 2, yTop);
                    canvasCtx.lineTo(x + barWidth / 2, yBottom);
                    canvasCtx.lineWidth = barWidth;
                    canvasCtx.strokeStyle = barColor;
                    canvasCtx.stroke();
                } else {
                    canvasCtx.beginPath();
                    canvasCtx.arc(x + barWidth / 2, canvas.height / scaleFactor / 2, adjustedCircleRadius, 0, 2 * Math.PI);
                    canvasCtx.fillStyle = barColor;
                    canvasCtx.fill();
                    canvasCtx.closePath();
                }
            });
            if (!isActive) drawInactiveCircles(adjustedCircleRadius, barColor);
            requestAnimationFrame(drawSpectrum);
        }
        function drawInactiveCircles(circleRadius, color) {
            const totalBarsWidth = bands.length * barWidth + (bands.length - 1) * barGap;
            const startX = (canvas.width / scaleFactor - totalBarsWidth) / 2;
            const y = canvas.height / scaleFactor / 2;
            bands.forEach((_, i)=>{
                const x = startX + i * (barWidth + barGap);
                canvasCtx.beginPath();
                canvasCtx.arc(x + barWidth / 2, y, circleRadius, 0, 2 * Math.PI);
                canvasCtx.fillStyle = color;
                canvasCtx.fill();
                canvasCtx.closePath();
            });
        }
        drawSpectrum();
        // Handle resizing
        window.addEventListener("resize", resizeCanvas);
        return ()=>{
            audioContext.close();
            window.removeEventListener("resize", resizeCanvas);
        };
    }, [
        backgroundColor,
        barColor,
        barGap,
        barMaxHeight,
        barWidth,
        track
    ]);
    return (0, $h9lXz$jsx)("canvas", {
        ref: canvasRef,
        style: {
            display: "block",
            width: "100%",
            height: "100%"
        }
    });
});
$993a744193844a95$export$59bf27bd43679db6.displayName = "VoiceVisualizer";




export {$f8b885726fc652c0$export$ba1245f7cbf3ae02 as RTVIClientAudio, $f3f7d4263dc13c6a$export$4a4ae2d5dc96782 as RTVIClientProvider, $b76d887910983811$export$d090a384943608eb as RTVIClientVideo, $54a3c9f5bdbf0854$export$31a5f6a22c9b8fba as useRTVIClient, $824ea64b5f757259$export$33a6ac53b8f02625 as useRTVIClientEvent, $c7d06534b21735c2$export$652c54907b83a48d as useRTVIClientMediaDevices, $194c75143b7a1fa0$export$7c03381e0d26a6c3 as useRTVIClientMediaTrack, $8376ffbc1b1f3c97$export$599fa01283bd4ece as useRTVIClientTransportState, $993a744193844a95$export$59bf27bd43679db6 as VoiceVisualizer};
//# sourceMappingURL=index.module.js.map
